/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_react-owl-carousel_umd_OwlCarousel_js"],{

/***/ "./node_modules/react-owl-carousel/umd/OwlCarousel.js":
/*!************************************************************!*\
  !*** ./node_modules/react-owl-carousel/umd/OwlCarousel.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* provided dependency */ var __webpack_provided_window_dot_jQuery = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n(function (global, factory) {\n     true ? module.exports = factory(__webpack_require__(/*! react */ \"./node_modules/react/index.js\")) :\n    0;\n}(this, (function (React) { 'use strict';\n\n    var React__default = 'default' in React ? React['default'] : React;\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    function __rest(s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n                t[p[i]] = s[p[i]];\r\n        return t;\r\n    }\n\n    /**\n     * Owl Carousel v2.3.4\n     * Copyright 2013-2018 David Deutsch\n     * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE\n     */\n    (function($, window, document, undefined) {\n\n    \t/**\n    \t * Creates a carousel.\n    \t * @class The Owl Carousel.\n    \t * @public\n    \t * @param {HTMLElement|jQuery} element - The element to create the carousel for.\n    \t * @param {Object} [options] - The options\n    \t */\n    \tfunction Owl(element, options) {\n\n    \t\t/**\n    \t\t * Current settings for the carousel.\n    \t\t * @public\n    \t\t */\n    \t\tthis.settings = null;\n\n    \t\t/**\n    \t\t * Current options set by the caller including defaults.\n    \t\t * @public\n    \t\t */\n    \t\tthis.options = $.extend({}, Owl.Defaults, options);\n\n    \t\t/**\n    \t\t * Plugin element.\n    \t\t * @public\n    \t\t */\n    \t\tthis.$element = $(element);\n\n    \t\t/**\n    \t\t * Proxied event handlers.\n    \t\t * @protected\n    \t\t */\n    \t\tthis._handlers = {};\n\n    \t\t/**\n    \t\t * References to the running plugins of this carousel.\n    \t\t * @protected\n    \t\t */\n    \t\tthis._plugins = {};\n\n    \t\t/**\n    \t\t * Currently suppressed events to prevent them from being retriggered.\n    \t\t * @protected\n    \t\t */\n    \t\tthis._supress = {};\n\n    \t\t/**\n    \t\t * Absolute current position.\n    \t\t * @protected\n    \t\t */\n    \t\tthis._current = null;\n\n    \t\t/**\n    \t\t * Animation speed in milliseconds.\n    \t\t * @protected\n    \t\t */\n    \t\tthis._speed = null;\n\n    \t\t/**\n    \t\t * Coordinates of all items in pixel.\n    \t\t * @todo The name of this member is missleading.\n    \t\t * @protected\n    \t\t */\n    \t\tthis._coordinates = [];\n\n    \t\t/**\n    \t\t * Current breakpoint.\n    \t\t * @todo Real media queries would be nice.\n    \t\t * @protected\n    \t\t */\n    \t\tthis._breakpoint = null;\n\n    \t\t/**\n    \t\t * Current width of the plugin element.\n    \t\t */\n    \t\tthis._width = null;\n\n    \t\t/**\n    \t\t * All real items.\n    \t\t * @protected\n    \t\t */\n    \t\tthis._items = [];\n\n    \t\t/**\n    \t\t * All cloned items.\n    \t\t * @protected\n    \t\t */\n    \t\tthis._clones = [];\n\n    \t\t/**\n    \t\t * Merge values of all items.\n    \t\t * @todo Maybe this could be part of a plugin.\n    \t\t * @protected\n    \t\t */\n    \t\tthis._mergers = [];\n\n    \t\t/**\n    \t\t * Widths of all items.\n    \t\t */\n    \t\tthis._widths = [];\n\n    \t\t/**\n    \t\t * Invalidated parts within the update process.\n    \t\t * @protected\n    \t\t */\n    \t\tthis._invalidated = {};\n\n    \t\t/**\n    \t\t * Ordered list of workers for the update process.\n    \t\t * @protected\n    \t\t */\n    \t\tthis._pipe = [];\n\n    \t\t/**\n    \t\t * Current state information for the drag operation.\n    \t\t * @todo #261\n    \t\t * @protected\n    \t\t */\n    \t\tthis._drag = {\n    \t\t\ttime: null,\n    \t\t\ttarget: null,\n    \t\t\tpointer: null,\n    \t\t\tstage: {\n    \t\t\t\tstart: null,\n    \t\t\t\tcurrent: null\n    \t\t\t},\n    \t\t\tdirection: null\n    \t\t};\n\n    \t\t/**\n    \t\t * Current state information and their tags.\n    \t\t * @type {Object}\n    \t\t * @protected\n    \t\t */\n    \t\tthis._states = {\n    \t\t\tcurrent: {},\n    \t\t\ttags: {\n    \t\t\t\t'initializing': [ 'busy' ],\n    \t\t\t\t'animating': [ 'busy' ],\n    \t\t\t\t'dragging': [ 'interacting' ]\n    \t\t\t}\n    \t\t};\n\n    \t\t$.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {\n    \t\t\tthis._handlers[handler] = $.proxy(this[handler], this);\n    \t\t}, this));\n\n    \t\t$.each(Owl.Plugins, $.proxy(function(key, plugin) {\n    \t\t\tthis._plugins[key.charAt(0).toLowerCase() + key.slice(1)]\n    \t\t\t\t= new plugin(this);\n    \t\t}, this));\n\n    \t\t$.each(Owl.Workers, $.proxy(function(priority, worker) {\n    \t\t\tthis._pipe.push({\n    \t\t\t\t'filter': worker.filter,\n    \t\t\t\t'run': $.proxy(worker.run, this)\n    \t\t\t});\n    \t\t}, this));\n\n    \t\tthis.setup();\n    \t\tthis.initialize();\n    \t}\n\n    \t/**\n    \t * Default options for the carousel.\n    \t * @public\n    \t */\n    \tOwl.Defaults = {\n    \t\titems: 3,\n    \t\tloop: false,\n    \t\tcenter: false,\n    \t\trewind: false,\n    \t\tcheckVisibility: true,\n\n    \t\tmouseDrag: true,\n    \t\ttouchDrag: true,\n    \t\tpullDrag: true,\n    \t\tfreeDrag: false,\n\n    \t\tmargin: 0,\n    \t\tstagePadding: 0,\n\n    \t\tmerge: false,\n    \t\tmergeFit: true,\n    \t\tautoWidth: false,\n\n    \t\tstartPosition: 0,\n    \t\trtl: false,\n\n    \t\tsmartSpeed: 250,\n    \t\tfluidSpeed: false,\n    \t\tdragEndSpeed: false,\n\n    \t\tresponsive: {},\n    \t\tresponsiveRefreshRate: 200,\n    \t\tresponsiveBaseElement: window,\n\n    \t\tfallbackEasing: 'swing',\n    \t\tslideTransition: '',\n\n    \t\tinfo: false,\n\n    \t\tnestedItemSelector: false,\n    \t\titemElement: 'div',\n    \t\tstageElement: 'div',\n\n    \t\trefreshClass: 'owl-refresh',\n    \t\tloadedClass: 'owl-loaded',\n    \t\tloadingClass: 'owl-loading',\n    \t\trtlClass: 'owl-rtl',\n    \t\tresponsiveClass: 'owl-responsive',\n    \t\tdragClass: 'owl-drag',\n    \t\titemClass: 'owl-item',\n    \t\tstageClass: 'owl-stage',\n    \t\tstageOuterClass: 'owl-stage-outer',\n    \t\tgrabClass: 'owl-grab'\n    \t};\n\n    \t/**\n    \t * Enumeration for width.\n    \t * @public\n    \t * @readonly\n    \t * @enum {String}\n    \t */\n    \tOwl.Width = {\n    \t\tDefault: 'default',\n    \t\tInner: 'inner',\n    \t\tOuter: 'outer'\n    \t};\n\n    \t/**\n    \t * Enumeration for types.\n    \t * @public\n    \t * @readonly\n    \t * @enum {String}\n    \t */\n    \tOwl.Type = {\n    \t\tEvent: 'event',\n    \t\tState: 'state'\n    \t};\n\n    \t/**\n    \t * Contains all registered plugins.\n    \t * @public\n    \t */\n    \tOwl.Plugins = {};\n\n    \t/**\n    \t * List of workers involved in the update process.\n    \t */\n    \tOwl.Workers = [ {\n    \t\tfilter: [ 'width', 'settings' ],\n    \t\trun: function() {\n    \t\t\tthis._width = this.$element.width();\n    \t\t}\n    \t}, {\n    \t\tfilter: [ 'width', 'items', 'settings' ],\n    \t\trun: function(cache) {\n    \t\t\tcache.current = this._items && this._items[this.relative(this._current)];\n    \t\t}\n    \t}, {\n    \t\tfilter: [ 'items', 'settings' ],\n    \t\trun: function() {\n    \t\t\tthis.$stage.children('.cloned').remove();\n    \t\t}\n    \t}, {\n    \t\tfilter: [ 'width', 'items', 'settings' ],\n    \t\trun: function(cache) {\n    \t\t\tvar margin = this.settings.margin || '',\n    \t\t\t\tgrid = !this.settings.autoWidth,\n    \t\t\t\trtl = this.settings.rtl,\n    \t\t\t\tcss = {\n    \t\t\t\t\t'width': 'auto',\n    \t\t\t\t\t'margin-left': rtl ? margin : '',\n    \t\t\t\t\t'margin-right': rtl ? '' : margin\n    \t\t\t\t};\n\n    \t\t\t!grid && this.$stage.children().css(css);\n\n    \t\t\tcache.css = css;\n    \t\t}\n    \t}, {\n    \t\tfilter: [ 'width', 'items', 'settings' ],\n    \t\trun: function(cache) {\n    \t\t\tvar width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\n    \t\t\t\tmerge = null,\n    \t\t\t\titerator = this._items.length,\n    \t\t\t\tgrid = !this.settings.autoWidth,\n    \t\t\t\twidths = [];\n\n    \t\t\tcache.items = {\n    \t\t\t\tmerge: false,\n    \t\t\t\twidth: width\n    \t\t\t};\n\n    \t\t\twhile (iterator--) {\n    \t\t\t\tmerge = this._mergers[iterator];\n    \t\t\t\tmerge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;\n\n    \t\t\t\tcache.items.merge = merge > 1 || cache.items.merge;\n\n    \t\t\t\twidths[iterator] = !grid ? this._items[iterator].width() : width * merge;\n    \t\t\t}\n\n    \t\t\tthis._widths = widths;\n    \t\t}\n    \t}, {\n    \t\tfilter: [ 'items', 'settings' ],\n    \t\trun: function() {\n    \t\t\tvar clones = [],\n    \t\t\t\titems = this._items,\n    \t\t\t\tsettings = this.settings,\n    \t\t\t\t// TODO: Should be computed from number of min width items in stage\n    \t\t\t\tview = Math.max(settings.items * 2, 4),\n    \t\t\t\tsize = Math.ceil(items.length / 2) * 2,\n    \t\t\t\trepeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,\n    \t\t\t\tappend = '',\n    \t\t\t\tprepend = '';\n\n    \t\t\trepeat /= 2;\n\n    \t\t\twhile (repeat > 0) {\n    \t\t\t\t// Switch to only using appended clones\n    \t\t\t\tclones.push(this.normalize(clones.length / 2, true));\n    \t\t\t\tappend = append + items[clones[clones.length - 1]][0].outerHTML;\n    \t\t\t\tclones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));\n    \t\t\t\tprepend = items[clones[clones.length - 1]][0].outerHTML + prepend;\n    \t\t\t\trepeat -= 1;\n    \t\t\t}\n\n    \t\t\tthis._clones = clones;\n\n    \t\t\t$(append).addClass('cloned').appendTo(this.$stage);\n    \t\t\t$(prepend).addClass('cloned').prependTo(this.$stage);\n    \t\t}\n    \t}, {\n    \t\tfilter: [ 'width', 'items', 'settings' ],\n    \t\trun: function() {\n    \t\t\tvar rtl = this.settings.rtl ? 1 : -1,\n    \t\t\t\tsize = this._clones.length + this._items.length,\n    \t\t\t\titerator = -1,\n    \t\t\t\tprevious = 0,\n    \t\t\t\tcurrent = 0,\n    \t\t\t\tcoordinates = [];\n\n    \t\t\twhile (++iterator < size) {\n    \t\t\t\tprevious = coordinates[iterator - 1] || 0;\n    \t\t\t\tcurrent = this._widths[this.relative(iterator)] + this.settings.margin;\n    \t\t\t\tcoordinates.push(previous + current * rtl);\n    \t\t\t}\n\n    \t\t\tthis._coordinates = coordinates;\n    \t\t}\n    \t}, {\n    \t\tfilter: [ 'width', 'items', 'settings' ],\n    \t\trun: function() {\n    \t\t\tvar padding = this.settings.stagePadding,\n    \t\t\t\tcoordinates = this._coordinates,\n    \t\t\t\tcss = {\n    \t\t\t\t\t'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,\n    \t\t\t\t\t'padding-left': padding || '',\n    \t\t\t\t\t'padding-right': padding || ''\n    \t\t\t\t};\n\n    \t\t\tthis.$stage.css(css);\n    \t\t}\n    \t}, {\n    \t\tfilter: [ 'width', 'items', 'settings' ],\n    \t\trun: function(cache) {\n    \t\t\tvar iterator = this._coordinates.length,\n    \t\t\t\tgrid = !this.settings.autoWidth,\n    \t\t\t\titems = this.$stage.children();\n\n    \t\t\tif (grid && cache.items.merge) {\n    \t\t\t\twhile (iterator--) {\n    \t\t\t\t\tcache.css.width = this._widths[this.relative(iterator)];\n    \t\t\t\t\titems.eq(iterator).css(cache.css);\n    \t\t\t\t}\n    \t\t\t} else if (grid) {\n    \t\t\t\tcache.css.width = cache.items.width;\n    \t\t\t\titems.css(cache.css);\n    \t\t\t}\n    \t\t}\n    \t}, {\n    \t\tfilter: [ 'items' ],\n    \t\trun: function() {\n    \t\t\tthis._coordinates.length < 1 && this.$stage.removeAttr('style');\n    \t\t}\n    \t}, {\n    \t\tfilter: [ 'width', 'items', 'settings' ],\n    \t\trun: function(cache) {\n    \t\t\tcache.current = cache.current ? this.$stage.children().index(cache.current) : 0;\n    \t\t\tcache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));\n    \t\t\tthis.reset(cache.current);\n    \t\t}\n    \t}, {\n    \t\tfilter: [ 'position' ],\n    \t\trun: function() {\n    \t\t\tthis.animate(this.coordinates(this._current));\n    \t\t}\n    \t}, {\n    \t\tfilter: [ 'width', 'position', 'items', 'settings' ],\n    \t\trun: function() {\n    \t\t\tvar rtl = this.settings.rtl ? 1 : -1,\n    \t\t\t\tpadding = this.settings.stagePadding * 2,\n    \t\t\t\tbegin = this.coordinates(this.current()) + padding,\n    \t\t\t\tend = begin + this.width() * rtl,\n    \t\t\t\tinner, outer, matches = [], i, n;\n\n    \t\t\tfor (i = 0, n = this._coordinates.length; i < n; i++) {\n    \t\t\t\tinner = this._coordinates[i - 1] || 0;\n    \t\t\t\touter = Math.abs(this._coordinates[i]) + padding * rtl;\n\n    \t\t\t\tif ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))\n    \t\t\t\t\t|| (this.op(outer, '<', begin) && this.op(outer, '>', end))) {\n    \t\t\t\t\tmatches.push(i);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tthis.$stage.children('.active').removeClass('active');\n    \t\t\tthis.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');\n\n    \t\t\tthis.$stage.children('.center').removeClass('center');\n    \t\t\tif (this.settings.center) {\n    \t\t\t\tthis.$stage.children().eq(this.current()).addClass('center');\n    \t\t\t}\n    \t\t}\n    \t} ];\n\n    \t/**\n    \t * Create the stage DOM element\n    \t */\n    \tOwl.prototype.initializeStage = function() {\n    \t\tthis.$stage = this.$element.find('.' + this.settings.stageClass);\n\n    \t\t// if the stage is already in the DOM, grab it and skip stage initialization\n    \t\tif (this.$stage.length) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\tthis.$element.addClass(this.options.loadingClass);\n\n    \t\t// create stage\n    \t\tthis.$stage = $('<' + this.settings.stageElement + '>', {\n    \t\t\t\"class\": this.settings.stageClass\n    \t\t}).wrap( $( '<div/>', {\n    \t\t\t\"class\": this.settings.stageOuterClass\n    \t\t}));\n\n    \t\t// append stage\n    \t\tthis.$element.append(this.$stage.parent());\n    \t};\n\n    \t/**\n    \t * Create item DOM elements\n    \t */\n    \tOwl.prototype.initializeItems = function() {\n    \t\tvar $items = this.$element.find('.owl-item');\n\n    \t\t// if the items are already in the DOM, grab them and skip item initialization\n    \t\tif ($items.length) {\n    \t\t\tthis._items = $items.get().map(function(item) {\n    \t\t\t\treturn $(item);\n    \t\t\t});\n\n    \t\t\tthis._mergers = this._items.map(function() {\n    \t\t\t\treturn 1;\n    \t\t\t});\n\n    \t\t\tthis.refresh();\n\n    \t\t\treturn;\n    \t\t}\n\n    \t\t// append content\n    \t\tthis.replace(this.$element.children().not(this.$stage.parent()));\n\n    \t\t// check visibility\n    \t\tif (this.isVisible()) {\n    \t\t\t// update view\n    \t\t\tthis.refresh();\n    \t\t} else {\n    \t\t\t// invalidate width\n    \t\t\tthis.invalidate('width');\n    \t\t}\n\n    \t\tthis.$element\n    \t\t\t.removeClass(this.options.loadingClass)\n    \t\t\t.addClass(this.options.loadedClass);\n    \t};\n\n    \t/**\n    \t * Initializes the carousel.\n    \t * @protected\n    \t */\n    \tOwl.prototype.initialize = function() {\n    \t\tthis.enter('initializing');\n    \t\tthis.trigger('initialize');\n\n    \t\tthis.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);\n\n    \t\tif (this.settings.autoWidth && !this.is('pre-loading')) {\n    \t\t\tvar imgs, nestedSelector, width;\n    \t\t\timgs = this.$element.find('img');\n    \t\t\tnestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;\n    \t\t\twidth = this.$element.children(nestedSelector).width();\n\n    \t\t\tif (imgs.length && width <= 0) {\n    \t\t\t\tthis.preloadAutoWidthImages(imgs);\n    \t\t\t}\n    \t\t}\n\n    \t\tthis.initializeStage();\n    \t\tthis.initializeItems();\n\n    \t\t// register event handlers\n    \t\tthis.registerEventHandlers();\n\n    \t\tthis.leave('initializing');\n    \t\tthis.trigger('initialized');\n    \t};\n\n    \t/**\n    \t * @returns {Boolean} visibility of $element\n    \t *                    if you know the carousel will always be visible you can set `checkVisibility` to `false` to\n    \t *                    prevent the expensive browser layout forced reflow the $element.is(':visible') does\n    \t */\n    \tOwl.prototype.isVisible = function() {\n    \t\treturn this.settings.checkVisibility\n    \t\t\t? this.$element.is(':visible')\n    \t\t\t: true;\n    \t};\n\n    \t/**\n    \t * Setups the current settings.\n    \t * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\n    \t * @todo Support for media queries by using `matchMedia` would be nice.\n    \t * @public\n    \t */\n    \tOwl.prototype.setup = function() {\n    \t\tvar viewport = this.viewport(),\n    \t\t\toverwrites = this.options.responsive,\n    \t\t\tmatch = -1,\n    \t\t\tsettings = null;\n\n    \t\tif (!overwrites) {\n    \t\t\tsettings = $.extend({}, this.options);\n    \t\t} else {\n    \t\t\t$.each(overwrites, function(breakpoint) {\n    \t\t\t\tif (breakpoint <= viewport && breakpoint > match) {\n    \t\t\t\t\tmatch = Number(breakpoint);\n    \t\t\t\t}\n    \t\t\t});\n\n    \t\t\tsettings = $.extend({}, this.options, overwrites[match]);\n    \t\t\tif (typeof settings.stagePadding === 'function') {\n    \t\t\t\tsettings.stagePadding = settings.stagePadding();\n    \t\t\t}\n    \t\t\tdelete settings.responsive;\n\n    \t\t\t// responsive class\n    \t\t\tif (settings.responsiveClass) {\n    \t\t\t\tthis.$element.attr('class',\n    \t\t\t\t\tthis.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\\\S+\\\\s', 'g'), '$1' + match)\n    \t\t\t\t);\n    \t\t\t}\n    \t\t}\n\n    \t\tthis.trigger('change', { property: { name: 'settings', value: settings } });\n    \t\tthis._breakpoint = match;\n    \t\tthis.settings = settings;\n    \t\tthis.invalidate('settings');\n    \t\tthis.trigger('changed', { property: { name: 'settings', value: this.settings } });\n    \t};\n\n    \t/**\n    \t * Updates option logic if necessery.\n    \t * @protected\n    \t */\n    \tOwl.prototype.optionsLogic = function() {\n    \t\tif (this.settings.autoWidth) {\n    \t\t\tthis.settings.stagePadding = false;\n    \t\t\tthis.settings.merge = false;\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Prepares an item before add.\n    \t * @todo Rename event parameter `content` to `item`.\n    \t * @protected\n    \t * @returns {jQuery|HTMLElement} - The item container.\n    \t */\n    \tOwl.prototype.prepare = function(item) {\n    \t\tvar event = this.trigger('prepare', { content: item });\n\n    \t\tif (!event.data) {\n    \t\t\tevent.data = $('<' + this.settings.itemElement + '/>')\n    \t\t\t\t.addClass(this.options.itemClass).append(item);\n    \t\t}\n\n    \t\tthis.trigger('prepared', { content: event.data });\n\n    \t\treturn event.data;\n    \t};\n\n    \t/**\n    \t * Updates the view.\n    \t * @public\n    \t */\n    \tOwl.prototype.update = function() {\n    \t\tvar i = 0,\n    \t\t\tn = this._pipe.length,\n    \t\t\tfilter = $.proxy(function(p) { return this[p] }, this._invalidated),\n    \t\t\tcache = {};\n\n    \t\twhile (i < n) {\n    \t\t\tif (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {\n    \t\t\t\tthis._pipe[i].run(cache);\n    \t\t\t}\n    \t\t\ti++;\n    \t\t}\n\n    \t\tthis._invalidated = {};\n\n    \t\t!this.is('valid') && this.enter('valid');\n    \t};\n\n    \t/**\n    \t * Gets the width of the view.\n    \t * @public\n    \t * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\n    \t * @returns {Number} - The width of the view in pixel.\n    \t */\n    \tOwl.prototype.width = function(dimension) {\n    \t\tdimension = dimension || Owl.Width.Default;\n    \t\tswitch (dimension) {\n    \t\t\tcase Owl.Width.Inner:\n    \t\t\tcase Owl.Width.Outer:\n    \t\t\t\treturn this._width;\n    \t\t\tdefault:\n    \t\t\t\treturn this._width - this.settings.stagePadding * 2 + this.settings.margin;\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Refreshes the carousel primarily for adaptive purposes.\n    \t * @public\n    \t */\n    \tOwl.prototype.refresh = function() {\n    \t\tthis.enter('refreshing');\n    \t\tthis.trigger('refresh');\n\n    \t\tthis.setup();\n\n    \t\tthis.optionsLogic();\n\n    \t\tthis.$element.addClass(this.options.refreshClass);\n\n    \t\tthis.update();\n\n    \t\tthis.$element.removeClass(this.options.refreshClass);\n\n    \t\tthis.leave('refreshing');\n    \t\tthis.trigger('refreshed');\n    \t};\n\n    \t/**\n    \t * Checks window `resize` event.\n    \t * @protected\n    \t */\n    \tOwl.prototype.onThrottledResize = function() {\n    \t\twindow.clearTimeout(this.resizeTimer);\n    \t\tthis.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\n    \t};\n\n    \t/**\n    \t * Checks window `resize` event.\n    \t * @protected\n    \t */\n    \tOwl.prototype.onResize = function() {\n    \t\tif (!this._items.length) {\n    \t\t\treturn false;\n    \t\t}\n\n    \t\tif (this._width === this.$element.width()) {\n    \t\t\treturn false;\n    \t\t}\n\n    \t\tif (!this.isVisible()) {\n    \t\t\treturn false;\n    \t\t}\n\n    \t\tthis.enter('resizing');\n\n    \t\tif (this.trigger('resize').isDefaultPrevented()) {\n    \t\t\tthis.leave('resizing');\n    \t\t\treturn false;\n    \t\t}\n\n    \t\tthis.invalidate('width');\n\n    \t\tthis.refresh();\n\n    \t\tthis.leave('resizing');\n    \t\tthis.trigger('resized');\n    \t};\n\n    \t/**\n    \t * Registers event handlers.\n    \t * @todo Check `msPointerEnabled`\n    \t * @todo #261\n    \t * @protected\n    \t */\n    \tOwl.prototype.registerEventHandlers = function() {\n    \t\tif ($.support.transition) {\n    \t\t\tthis.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));\n    \t\t}\n\n    \t\tif (this.settings.responsive !== false) {\n    \t\t\tthis.on(window, 'resize', this._handlers.onThrottledResize);\n    \t\t}\n\n    \t\tif (this.settings.mouseDrag) {\n    \t\t\tthis.$element.addClass(this.options.dragClass);\n    \t\t\tthis.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));\n    \t\t\tthis.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });\n    \t\t}\n\n    \t\tif (this.settings.touchDrag){\n    \t\t\tthis.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));\n    \t\t\tthis.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Handles `touchstart` and `mousedown` events.\n    \t * @todo Horizontal swipe threshold as option\n    \t * @todo #261\n    \t * @protected\n    \t * @param {Event} event - The event arguments.\n    \t */\n    \tOwl.prototype.onDragStart = function(event) {\n    \t\tvar stage = null;\n\n    \t\tif (event.which === 3) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\tif ($.support.transform) {\n    \t\t\tstage = this.$stage.css('transform').replace(/.*\\(|\\)| /g, '').split(',');\n    \t\t\tstage = {\n    \t\t\t\tx: stage[stage.length === 16 ? 12 : 4],\n    \t\t\t\ty: stage[stage.length === 16 ? 13 : 5]\n    \t\t\t};\n    \t\t} else {\n    \t\t\tstage = this.$stage.position();\n    \t\t\tstage = {\n    \t\t\t\tx: this.settings.rtl ?\n    \t\t\t\t\tstage.left + this.$stage.width() - this.width() + this.settings.margin :\n    \t\t\t\t\tstage.left,\n    \t\t\t\ty: stage.top\n    \t\t\t};\n    \t\t}\n\n    \t\tif (this.is('animating')) {\n    \t\t\t$.support.transform ? this.animate(stage.x) : this.$stage.stop();\n    \t\t\tthis.invalidate('position');\n    \t\t}\n\n    \t\tthis.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');\n\n    \t\tthis.speed(0);\n\n    \t\tthis._drag.time = new Date().getTime();\n    \t\tthis._drag.target = $(event.target);\n    \t\tthis._drag.stage.start = stage;\n    \t\tthis._drag.stage.current = stage;\n    \t\tthis._drag.pointer = this.pointer(event);\n\n    \t\t$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));\n\n    \t\t$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {\n    \t\t\tvar delta = this.difference(this._drag.pointer, this.pointer(event));\n\n    \t\t\t$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));\n\n    \t\t\tif (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {\n    \t\t\t\treturn;\n    \t\t\t}\n\n    \t\t\tevent.preventDefault();\n\n    \t\t\tthis.enter('dragging');\n    \t\t\tthis.trigger('drag');\n    \t\t}, this));\n    \t};\n\n    \t/**\n    \t * Handles the `touchmove` and `mousemove` events.\n    \t * @todo #261\n    \t * @protected\n    \t * @param {Event} event - The event arguments.\n    \t */\n    \tOwl.prototype.onDragMove = function(event) {\n    \t\tvar minimum = null,\n    \t\t\tmaximum = null,\n    \t\t\tpull = null,\n    \t\t\tdelta = this.difference(this._drag.pointer, this.pointer(event)),\n    \t\t\tstage = this.difference(this._drag.stage.start, delta);\n\n    \t\tif (!this.is('dragging')) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\tevent.preventDefault();\n\n    \t\tif (this.settings.loop) {\n    \t\t\tminimum = this.coordinates(this.minimum());\n    \t\t\tmaximum = this.coordinates(this.maximum() + 1) - minimum;\n    \t\t\tstage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;\n    \t\t} else {\n    \t\t\tminimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());\n    \t\t\tmaximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());\n    \t\t\tpull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;\n    \t\t\tstage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);\n    \t\t}\n\n    \t\tthis._drag.stage.current = stage;\n\n    \t\tthis.animate(stage.x);\n    \t};\n\n    \t/**\n    \t * Handles the `touchend` and `mouseup` events.\n    \t * @todo #261\n    \t * @todo Threshold for click event\n    \t * @protected\n    \t * @param {Event} event - The event arguments.\n    \t */\n    \tOwl.prototype.onDragEnd = function(event) {\n    \t\tvar delta = this.difference(this._drag.pointer, this.pointer(event)),\n    \t\t\tstage = this._drag.stage.current,\n    \t\t\tdirection = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';\n\n    \t\t$(document).off('.owl.core');\n\n    \t\tthis.$element.removeClass(this.options.grabClass);\n\n    \t\tif (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {\n    \t\t\tthis.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\n    \t\t\tthis.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));\n    \t\t\tthis.invalidate('position');\n    \t\t\tthis.update();\n\n    \t\t\tthis._drag.direction = direction;\n\n    \t\t\tif (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {\n    \t\t\t\tthis._drag.target.one('click.owl.core', function() { return false; });\n    \t\t\t}\n    \t\t}\n\n    \t\tif (!this.is('dragging')) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\tthis.leave('dragging');\n    \t\tthis.trigger('dragged');\n    \t};\n\n    \t/**\n    \t * Gets absolute position of the closest item for a coordinate.\n    \t * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\n    \t * @protected\n    \t * @param {Number} coordinate - The coordinate in pixel.\n    \t * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.\n    \t * @return {Number} - The absolute position of the closest item.\n    \t */\n    \tOwl.prototype.closest = function(coordinate, direction) {\n    \t\tvar position = -1,\n    \t\t\tpull = 30,\n    \t\t\twidth = this.width(),\n    \t\t\tcoordinates = this.coordinates();\n\n    \t\tif (!this.settings.freeDrag) {\n    \t\t\t// check closest item\n    \t\t\t$.each(coordinates, $.proxy(function(index, value) {\n    \t\t\t\t// on a left pull, check on current index\n    \t\t\t\tif (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {\n    \t\t\t\t\tposition = index;\n    \t\t\t\t// on a right pull, check on previous index\n    \t\t\t\t// to do so, subtract width from value and set position = index + 1\n    \t\t\t\t} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {\n    \t\t\t\t\tposition = index + 1;\n    \t\t\t\t} else if (this.op(coordinate, '<', value)\n    \t\t\t\t\t&& this.op(coordinate, '>', coordinates[index + 1] !== undefined ? coordinates[index + 1] : value - width)) {\n    \t\t\t\t\tposition = direction === 'left' ? index + 1 : index;\n    \t\t\t\t}\n    \t\t\t\treturn position === -1;\n    \t\t\t}, this));\n    \t\t}\n\n    \t\tif (!this.settings.loop) {\n    \t\t\t// non loop boundries\n    \t\t\tif (this.op(coordinate, '>', coordinates[this.minimum()])) {\n    \t\t\t\tposition = coordinate = this.minimum();\n    \t\t\t} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {\n    \t\t\t\tposition = coordinate = this.maximum();\n    \t\t\t}\n    \t\t}\n\n    \t\treturn position;\n    \t};\n\n    \t/**\n    \t * Animates the stage.\n    \t * @todo #270\n    \t * @public\n    \t * @param {Number} coordinate - The coordinate in pixels.\n    \t */\n    \tOwl.prototype.animate = function(coordinate) {\n    \t\tvar animate = this.speed() > 0;\n\n    \t\tthis.is('animating') && this.onTransitionEnd();\n\n    \t\tif (animate) {\n    \t\t\tthis.enter('animating');\n    \t\t\tthis.trigger('translate');\n    \t\t}\n\n    \t\tif ($.support.transform3d && $.support.transition) {\n    \t\t\tthis.$stage.css({\n    \t\t\t\ttransform: 'translate3d(' + coordinate + 'px,0px,0px)',\n    \t\t\t\ttransition: (this.speed() / 1000) + 's' + (\n    \t\t\t\t\tthis.settings.slideTransition ? ' ' + this.settings.slideTransition : ''\n    \t\t\t\t)\n    \t\t\t});\n    \t\t} else if (animate) {\n    \t\t\tthis.$stage.animate({\n    \t\t\t\tleft: coordinate + 'px'\n    \t\t\t}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));\n    \t\t} else {\n    \t\t\tthis.$stage.css({\n    \t\t\t\tleft: coordinate + 'px'\n    \t\t\t});\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Checks whether the carousel is in a specific state or not.\n    \t * @param {String} state - The state to check.\n    \t * @returns {Boolean} - The flag which indicates if the carousel is busy.\n    \t */\n    \tOwl.prototype.is = function(state) {\n    \t\treturn this._states.current[state] && this._states.current[state] > 0;\n    \t};\n\n    \t/**\n    \t * Sets the absolute position of the current item.\n    \t * @public\n    \t * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\n    \t * @returns {Number} - The absolute position of the current item.\n    \t */\n    \tOwl.prototype.current = function(position) {\n    \t\tif (position === undefined) {\n    \t\t\treturn this._current;\n    \t\t}\n\n    \t\tif (this._items.length === 0) {\n    \t\t\treturn undefined;\n    \t\t}\n\n    \t\tposition = this.normalize(position);\n\n    \t\tif (this._current !== position) {\n    \t\t\tvar event = this.trigger('change', { property: { name: 'position', value: position } });\n\n    \t\t\tif (event.data !== undefined) {\n    \t\t\t\tposition = this.normalize(event.data);\n    \t\t\t}\n\n    \t\t\tthis._current = position;\n\n    \t\t\tthis.invalidate('position');\n\n    \t\t\tthis.trigger('changed', { property: { name: 'position', value: this._current } });\n    \t\t}\n\n    \t\treturn this._current;\n    \t};\n\n    \t/**\n    \t * Invalidates the given part of the update routine.\n    \t * @param {String} [part] - The part to invalidate.\n    \t * @returns {Array.<String>} - The invalidated parts.\n    \t */\n    \tOwl.prototype.invalidate = function(part) {\n    \t\tif ($.type(part) === 'string') {\n    \t\t\tthis._invalidated[part] = true;\n    \t\t\tthis.is('valid') && this.leave('valid');\n    \t\t}\n    \t\treturn $.map(this._invalidated, function(v, i) { return i });\n    \t};\n\n    \t/**\n    \t * Resets the absolute position of the current item.\n    \t * @public\n    \t * @param {Number} position - The absolute position of the new item.\n    \t */\n    \tOwl.prototype.reset = function(position) {\n    \t\tposition = this.normalize(position);\n\n    \t\tif (position === undefined) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\tthis._speed = 0;\n    \t\tthis._current = position;\n\n    \t\tthis.suppress([ 'translate', 'translated' ]);\n\n    \t\tthis.animate(this.coordinates(position));\n\n    \t\tthis.release([ 'translate', 'translated' ]);\n    \t};\n\n    \t/**\n    \t * Normalizes an absolute or a relative position of an item.\n    \t * @public\n    \t * @param {Number} position - The absolute or relative position to normalize.\n    \t * @param {Boolean} [relative=false] - Whether the given position is relative or not.\n    \t * @returns {Number} - The normalized position.\n    \t */\n    \tOwl.prototype.normalize = function(position, relative) {\n    \t\tvar n = this._items.length,\n    \t\t\tm = relative ? 0 : this._clones.length;\n\n    \t\tif (!this.isNumeric(position) || n < 1) {\n    \t\t\tposition = undefined;\n    \t\t} else if (position < 0 || position >= n + m) {\n    \t\t\tposition = ((position - m / 2) % n + n) % n + m / 2;\n    \t\t}\n\n    \t\treturn position;\n    \t};\n\n    \t/**\n    \t * Converts an absolute position of an item into a relative one.\n    \t * @public\n    \t * @param {Number} position - The absolute position to convert.\n    \t * @returns {Number} - The converted position.\n    \t */\n    \tOwl.prototype.relative = function(position) {\n    \t\tposition -= this._clones.length / 2;\n    \t\treturn this.normalize(position, true);\n    \t};\n\n    \t/**\n    \t * Gets the maximum position for the current item.\n    \t * @public\n    \t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n    \t * @returns {Number}\n    \t */\n    \tOwl.prototype.maximum = function(relative) {\n    \t\tvar settings = this.settings,\n    \t\t\tmaximum = this._coordinates.length,\n    \t\t\titerator,\n    \t\t\treciprocalItemsWidth,\n    \t\t\telementWidth;\n\n    \t\tif (settings.loop) {\n    \t\t\tmaximum = this._clones.length / 2 + this._items.length - 1;\n    \t\t} else if (settings.autoWidth || settings.merge) {\n    \t\t\titerator = this._items.length;\n    \t\t\tif (iterator) {\n    \t\t\t\treciprocalItemsWidth = this._items[--iterator].width();\n    \t\t\t\telementWidth = this.$element.width();\n    \t\t\t\twhile (iterator--) {\n    \t\t\t\t\treciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;\n    \t\t\t\t\tif (reciprocalItemsWidth > elementWidth) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tmaximum = iterator + 1;\n    \t\t} else if (settings.center) {\n    \t\t\tmaximum = this._items.length - 1;\n    \t\t} else {\n    \t\t\tmaximum = this._items.length - settings.items;\n    \t\t}\n\n    \t\tif (relative) {\n    \t\t\tmaximum -= this._clones.length / 2;\n    \t\t}\n\n    \t\treturn Math.max(maximum, 0);\n    \t};\n\n    \t/**\n    \t * Gets the minimum position for the current item.\n    \t * @public\n    \t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n    \t * @returns {Number}\n    \t */\n    \tOwl.prototype.minimum = function(relative) {\n    \t\treturn relative ? 0 : this._clones.length / 2;\n    \t};\n\n    \t/**\n    \t * Gets an item at the specified relative position.\n    \t * @public\n    \t * @param {Number} [position] - The relative position of the item.\n    \t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n    \t */\n    \tOwl.prototype.items = function(position) {\n    \t\tif (position === undefined) {\n    \t\t\treturn this._items.slice();\n    \t\t}\n\n    \t\tposition = this.normalize(position, true);\n    \t\treturn this._items[position];\n    \t};\n\n    \t/**\n    \t * Gets an item at the specified relative position.\n    \t * @public\n    \t * @param {Number} [position] - The relative position of the item.\n    \t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n    \t */\n    \tOwl.prototype.mergers = function(position) {\n    \t\tif (position === undefined) {\n    \t\t\treturn this._mergers.slice();\n    \t\t}\n\n    \t\tposition = this.normalize(position, true);\n    \t\treturn this._mergers[position];\n    \t};\n\n    \t/**\n    \t * Gets the absolute positions of clones for an item.\n    \t * @public\n    \t * @param {Number} [position] - The relative position of the item.\n    \t * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\n    \t */\n    \tOwl.prototype.clones = function(position) {\n    \t\tvar odd = this._clones.length / 2,\n    \t\t\teven = odd + this._items.length,\n    \t\t\tmap = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };\n\n    \t\tif (position === undefined) {\n    \t\t\treturn $.map(this._clones, function(v, i) { return map(i) });\n    \t\t}\n\n    \t\treturn $.map(this._clones, function(v, i) { return v === position ? map(i) : null });\n    \t};\n\n    \t/**\n    \t * Sets the current animation speed.\n    \t * @public\n    \t * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\n    \t * @returns {Number} - The current animation speed in milliseconds.\n    \t */\n    \tOwl.prototype.speed = function(speed) {\n    \t\tif (speed !== undefined) {\n    \t\t\tthis._speed = speed;\n    \t\t}\n\n    \t\treturn this._speed;\n    \t};\n\n    \t/**\n    \t * Gets the coordinate of an item.\n    \t * @todo The name of this method is missleanding.\n    \t * @public\n    \t * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\n    \t * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\n    \t */\n    \tOwl.prototype.coordinates = function(position) {\n    \t\tvar multiplier = 1,\n    \t\t\tnewPosition = position - 1,\n    \t\t\tcoordinate;\n\n    \t\tif (position === undefined) {\n    \t\t\treturn $.map(this._coordinates, $.proxy(function(coordinate, index) {\n    \t\t\t\treturn this.coordinates(index);\n    \t\t\t}, this));\n    \t\t}\n\n    \t\tif (this.settings.center) {\n    \t\t\tif (this.settings.rtl) {\n    \t\t\t\tmultiplier = -1;\n    \t\t\t\tnewPosition = position + 1;\n    \t\t\t}\n\n    \t\t\tcoordinate = this._coordinates[position];\n    \t\t\tcoordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;\n    \t\t} else {\n    \t\t\tcoordinate = this._coordinates[newPosition] || 0;\n    \t\t}\n\n    \t\tcoordinate = Math.ceil(coordinate);\n\n    \t\treturn coordinate;\n    \t};\n\n    \t/**\n    \t * Calculates the speed for a translation.\n    \t * @protected\n    \t * @param {Number} from - The absolute position of the start item.\n    \t * @param {Number} to - The absolute position of the target item.\n    \t * @param {Number} [factor=undefined] - The time factor in milliseconds.\n    \t * @returns {Number} - The time in milliseconds for the translation.\n    \t */\n    \tOwl.prototype.duration = function(from, to, factor) {\n    \t\tif (factor === 0) {\n    \t\t\treturn 0;\n    \t\t}\n\n    \t\treturn Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));\n    \t};\n\n    \t/**\n    \t * Slides to the specified item.\n    \t * @public\n    \t * @param {Number} position - The position of the item.\n    \t * @param {Number} [speed] - The time in milliseconds for the transition.\n    \t */\n    \tOwl.prototype.to = function(position, speed) {\n    \t\tvar current = this.current(),\n    \t\t\trevert = null,\n    \t\t\tdistance = position - this.relative(current),\n    \t\t\tdirection = (distance > 0) - (distance < 0),\n    \t\t\titems = this._items.length,\n    \t\t\tminimum = this.minimum(),\n    \t\t\tmaximum = this.maximum();\n\n    \t\tif (this.settings.loop) {\n    \t\t\tif (!this.settings.rewind && Math.abs(distance) > items / 2) {\n    \t\t\t\tdistance += direction * -1 * items;\n    \t\t\t}\n\n    \t\t\tposition = current + distance;\n    \t\t\trevert = ((position - minimum) % items + items) % items + minimum;\n\n    \t\t\tif (revert !== position && revert - distance <= maximum && revert - distance > 0) {\n    \t\t\t\tcurrent = revert - distance;\n    \t\t\t\tposition = revert;\n    \t\t\t\tthis.reset(current);\n    \t\t\t}\n    \t\t} else if (this.settings.rewind) {\n    \t\t\tmaximum += 1;\n    \t\t\tposition = (position % maximum + maximum) % maximum;\n    \t\t} else {\n    \t\t\tposition = Math.max(minimum, Math.min(maximum, position));\n    \t\t}\n\n    \t\tthis.speed(this.duration(current, position, speed));\n    \t\tthis.current(position);\n\n    \t\tif (this.isVisible()) {\n    \t\t\tthis.update();\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Slides to the next item.\n    \t * @public\n    \t * @param {Number} [speed] - The time in milliseconds for the transition.\n    \t */\n    \tOwl.prototype.next = function(speed) {\n    \t\tspeed = speed || false;\n    \t\tthis.to(this.relative(this.current()) + 1, speed);\n    \t};\n\n    \t/**\n    \t * Slides to the previous item.\n    \t * @public\n    \t * @param {Number} [speed] - The time in milliseconds for the transition.\n    \t */\n    \tOwl.prototype.prev = function(speed) {\n    \t\tspeed = speed || false;\n    \t\tthis.to(this.relative(this.current()) - 1, speed);\n    \t};\n\n    \t/**\n    \t * Handles the end of an animation.\n    \t * @protected\n    \t * @param {Event} event - The event arguments.\n    \t */\n    \tOwl.prototype.onTransitionEnd = function(event) {\n\n    \t\t// if css2 animation then event object is undefined\n    \t\tif (event !== undefined) {\n    \t\t\tevent.stopPropagation();\n\n    \t\t\t// Catch only owl-stage transitionEnd event\n    \t\t\tif ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {\n    \t\t\t\treturn false;\n    \t\t\t}\n    \t\t}\n\n    \t\tthis.leave('animating');\n    \t\tthis.trigger('translated');\n    \t};\n\n    \t/**\n    \t * Gets viewport width.\n    \t * @protected\n    \t * @return {Number} - The width in pixel.\n    \t */\n    \tOwl.prototype.viewport = function() {\n    \t\tvar width;\n    \t\tif (this.options.responsiveBaseElement !== window) {\n    \t\t\twidth = $(this.options.responsiveBaseElement).width();\n    \t\t} else if (window.innerWidth) {\n    \t\t\twidth = window.innerWidth;\n    \t\t} else if (document.documentElement && document.documentElement.clientWidth) {\n    \t\t\twidth = document.documentElement.clientWidth;\n    \t\t} else {\n    \t\t\tconsole.warn('Can not detect viewport width.');\n    \t\t}\n    \t\treturn width;\n    \t};\n\n    \t/**\n    \t * Replaces the current content.\n    \t * @public\n    \t * @param {HTMLElement|jQuery|String} content - The new content.\n    \t */\n    \tOwl.prototype.replace = function(content) {\n    \t\tthis.$stage.empty();\n    \t\tthis._items = [];\n\n    \t\tif (content) {\n    \t\t\tcontent = (content instanceof jQuery) ? content : $(content);\n    \t\t}\n\n    \t\tif (this.settings.nestedItemSelector) {\n    \t\t\tcontent = content.find('.' + this.settings.nestedItemSelector);\n    \t\t}\n\n    \t\tcontent.filter(function() {\n    \t\t\treturn this.nodeType === 1;\n    \t\t}).each($.proxy(function(index, item) {\n    \t\t\titem = this.prepare(item);\n    \t\t\tthis.$stage.append(item);\n    \t\t\tthis._items.push(item);\n    \t\t\tthis._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n    \t\t}, this));\n\n    \t\tthis.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);\n\n    \t\tthis.invalidate('items');\n    \t};\n\n    \t/**\n    \t * Adds an item.\n    \t * @todo Use `item` instead of `content` for the event arguments.\n    \t * @public\n    \t * @param {HTMLElement|jQuery|String} content - The item content to add.\n    \t * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\n    \t */\n    \tOwl.prototype.add = function(content, position) {\n    \t\tvar current = this.relative(this._current);\n\n    \t\tposition = position === undefined ? this._items.length : this.normalize(position, true);\n    \t\tcontent = content instanceof jQuery ? content : $(content);\n\n    \t\tthis.trigger('add', { content: content, position: position });\n\n    \t\tcontent = this.prepare(content);\n\n    \t\tif (this._items.length === 0 || position === this._items.length) {\n    \t\t\tthis._items.length === 0 && this.$stage.append(content);\n    \t\t\tthis._items.length !== 0 && this._items[position - 1].after(content);\n    \t\t\tthis._items.push(content);\n    \t\t\tthis._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n    \t\t} else {\n    \t\t\tthis._items[position].before(content);\n    \t\t\tthis._items.splice(position, 0, content);\n    \t\t\tthis._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n    \t\t}\n\n    \t\tthis._items[current] && this.reset(this._items[current].index());\n\n    \t\tthis.invalidate('items');\n\n    \t\tthis.trigger('added', { content: content, position: position });\n    \t};\n\n    \t/**\n    \t * Removes an item by its position.\n    \t * @todo Use `item` instead of `content` for the event arguments.\n    \t * @public\n    \t * @param {Number} position - The relative position of the item to remove.\n    \t */\n    \tOwl.prototype.remove = function(position) {\n    \t\tposition = this.normalize(position, true);\n\n    \t\tif (position === undefined) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\tthis.trigger('remove', { content: this._items[position], position: position });\n\n    \t\tthis._items[position].remove();\n    \t\tthis._items.splice(position, 1);\n    \t\tthis._mergers.splice(position, 1);\n\n    \t\tthis.invalidate('items');\n\n    \t\tthis.trigger('removed', { content: null, position: position });\n    \t};\n\n    \t/**\n    \t * Preloads images with auto width.\n    \t * @todo Replace by a more generic approach\n    \t * @protected\n    \t */\n    \tOwl.prototype.preloadAutoWidthImages = function(images) {\n    \t\timages.each($.proxy(function(i, element) {\n    \t\t\tthis.enter('pre-loading');\n    \t\t\telement = $(element);\n    \t\t\t$(new Image()).one('load', $.proxy(function(e) {\n    \t\t\t\telement.attr('src', e.target.src);\n    \t\t\t\telement.css('opacity', 1);\n    \t\t\t\tthis.leave('pre-loading');\n    \t\t\t\t!this.is('pre-loading') && !this.is('initializing') && this.refresh();\n    \t\t\t}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));\n    \t\t}, this));\n    \t};\n\n    \t/**\n    \t * Destroys the carousel.\n    \t * @public\n    \t */\n    \tOwl.prototype.destroy = function() {\n\n    \t\tthis.$element.off('.owl.core');\n    \t\tthis.$stage.off('.owl.core');\n    \t\t$(document).off('.owl.core');\n\n    \t\tif (this.settings.responsive !== false) {\n    \t\t\twindow.clearTimeout(this.resizeTimer);\n    \t\t\tthis.off(window, 'resize', this._handlers.onThrottledResize);\n    \t\t}\n\n    \t\tfor (var i in this._plugins) {\n    \t\t\tthis._plugins[i].destroy();\n    \t\t}\n\n    \t\tthis.$stage.children('.cloned').remove();\n\n    \t\tthis.$stage.unwrap();\n    \t\tthis.$stage.children().contents().unwrap();\n    \t\tthis.$stage.children().unwrap();\n    \t\tthis.$stage.remove();\n    \t\tthis.$element\n    \t\t\t.removeClass(this.options.refreshClass)\n    \t\t\t.removeClass(this.options.loadingClass)\n    \t\t\t.removeClass(this.options.loadedClass)\n    \t\t\t.removeClass(this.options.rtlClass)\n    \t\t\t.removeClass(this.options.dragClass)\n    \t\t\t.removeClass(this.options.grabClass)\n    \t\t\t.attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\\\S+\\\\s', 'g'), ''))\n    \t\t\t.removeData('owl.carousel');\n    \t};\n\n    \t/**\n    \t * Operators to calculate right-to-left and left-to-right.\n    \t * @protected\n    \t * @param {Number} [a] - The left side operand.\n    \t * @param {String} [o] - The operator.\n    \t * @param {Number} [b] - The right side operand.\n    \t */\n    \tOwl.prototype.op = function(a, o, b) {\n    \t\tvar rtl = this.settings.rtl;\n    \t\tswitch (o) {\n    \t\t\tcase '<':\n    \t\t\t\treturn rtl ? a > b : a < b;\n    \t\t\tcase '>':\n    \t\t\t\treturn rtl ? a < b : a > b;\n    \t\t\tcase '>=':\n    \t\t\t\treturn rtl ? a <= b : a >= b;\n    \t\t\tcase '<=':\n    \t\t\t\treturn rtl ? a >= b : a <= b;\n    \t\t\tdefault:\n    \t\t\t\tbreak;\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Attaches to an internal event.\n    \t * @protected\n    \t * @param {HTMLElement} element - The event source.\n    \t * @param {String} event - The event name.\n    \t * @param {Function} listener - The event handler to attach.\n    \t * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\n    \t */\n    \tOwl.prototype.on = function(element, event, listener, capture) {\n    \t\tif (element.addEventListener) {\n    \t\t\telement.addEventListener(event, listener, capture);\n    \t\t} else if (element.attachEvent) {\n    \t\t\telement.attachEvent('on' + event, listener);\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Detaches from an internal event.\n    \t * @protected\n    \t * @param {HTMLElement} element - The event source.\n    \t * @param {String} event - The event name.\n    \t * @param {Function} listener - The attached event handler to detach.\n    \t * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\n    \t */\n    \tOwl.prototype.off = function(element, event, listener, capture) {\n    \t\tif (element.removeEventListener) {\n    \t\t\telement.removeEventListener(event, listener, capture);\n    \t\t} else if (element.detachEvent) {\n    \t\t\telement.detachEvent('on' + event, listener);\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Triggers a public event.\n    \t * @todo Remove `status`, `relatedTarget` should be used instead.\n    \t * @protected\n    \t * @param {String} name - The event name.\n    \t * @param {*} [data=null] - The event data.\n    \t * @param {String} [namespace=carousel] - The event namespace.\n    \t * @param {String} [state] - The state which is associated with the event.\n    \t * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.\n    \t * @returns {Event} - The event arguments.\n    \t */\n    \tOwl.prototype.trigger = function(name, data, namespace, state, enter) {\n    \t\tvar status = {\n    \t\t\titem: { count: this._items.length, index: this.current() }\n    \t\t}, handler = $.camelCase(\n    \t\t\t$.grep([ 'on', name, namespace ], function(v) { return v })\n    \t\t\t\t.join('-').toLowerCase()\n    \t\t), event = $.Event(\n    \t\t\t[ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),\n    \t\t\t$.extend({ relatedTarget: this }, status, data)\n    \t\t);\n\n    \t\tif (!this._supress[name]) {\n    \t\t\t$.each(this._plugins, function(name, plugin) {\n    \t\t\t\tif (plugin.onTrigger) {\n    \t\t\t\t\tplugin.onTrigger(event);\n    \t\t\t\t}\n    \t\t\t});\n\n    \t\t\tthis.register({ type: Owl.Type.Event, name: name });\n    \t\t\tthis.$element.trigger(event);\n\n    \t\t\tif (this.settings && typeof this.settings[handler] === 'function') {\n    \t\t\t\tthis.settings[handler].call(this, event);\n    \t\t\t}\n    \t\t}\n\n    \t\treturn event;\n    \t};\n\n    \t/**\n    \t * Enters a state.\n    \t * @param name - The state name.\n    \t */\n    \tOwl.prototype.enter = function(name) {\n    \t\t$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\n    \t\t\tif (this._states.current[name] === undefined) {\n    \t\t\t\tthis._states.current[name] = 0;\n    \t\t\t}\n\n    \t\t\tthis._states.current[name]++;\n    \t\t}, this));\n    \t};\n\n    \t/**\n    \t * Leaves a state.\n    \t * @param name - The state name.\n    \t */\n    \tOwl.prototype.leave = function(name) {\n    \t\t$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\n    \t\t\tthis._states.current[name]--;\n    \t\t}, this));\n    \t};\n\n    \t/**\n    \t * Registers an event or state.\n    \t * @public\n    \t * @param {Object} object - The event or state to register.\n    \t */\n    \tOwl.prototype.register = function(object) {\n    \t\tif (object.type === Owl.Type.Event) {\n    \t\t\tif (!$.event.special[object.name]) {\n    \t\t\t\t$.event.special[object.name] = {};\n    \t\t\t}\n\n    \t\t\tif (!$.event.special[object.name].owl) {\n    \t\t\t\tvar _default = $.event.special[object.name]._default;\n    \t\t\t\t$.event.special[object.name]._default = function(e) {\n    \t\t\t\t\tif (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {\n    \t\t\t\t\t\treturn _default.apply(this, arguments);\n    \t\t\t\t\t}\n    \t\t\t\t\treturn e.namespace && e.namespace.indexOf('owl') > -1;\n    \t\t\t\t};\n    \t\t\t\t$.event.special[object.name].owl = true;\n    \t\t\t}\n    \t\t} else if (object.type === Owl.Type.State) {\n    \t\t\tif (!this._states.tags[object.name]) {\n    \t\t\t\tthis._states.tags[object.name] = object.tags;\n    \t\t\t} else {\n    \t\t\t\tthis._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);\n    \t\t\t}\n\n    \t\t\tthis._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {\n    \t\t\t\treturn $.inArray(tag, this._states.tags[object.name]) === i;\n    \t\t\t}, this));\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Suppresses events.\n    \t * @protected\n    \t * @param {Array.<String>} events - The events to suppress.\n    \t */\n    \tOwl.prototype.suppress = function(events) {\n    \t\t$.each(events, $.proxy(function(index, event) {\n    \t\t\tthis._supress[event] = true;\n    \t\t}, this));\n    \t};\n\n    \t/**\n    \t * Releases suppressed events.\n    \t * @protected\n    \t * @param {Array.<String>} events - The events to release.\n    \t */\n    \tOwl.prototype.release = function(events) {\n    \t\t$.each(events, $.proxy(function(index, event) {\n    \t\t\tdelete this._supress[event];\n    \t\t}, this));\n    \t};\n\n    \t/**\n    \t * Gets unified pointer coordinates from event.\n    \t * @todo #261\n    \t * @protected\n    \t * @param {Event} - The `mousedown` or `touchstart` event.\n    \t * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.\n    \t */\n    \tOwl.prototype.pointer = function(event) {\n    \t\tvar result = { x: null, y: null };\n\n    \t\tevent = event.originalEvent || event || window.event;\n\n    \t\tevent = event.touches && event.touches.length ?\n    \t\t\tevent.touches[0] : event.changedTouches && event.changedTouches.length ?\n    \t\t\t\tevent.changedTouches[0] : event;\n\n    \t\tif (event.pageX) {\n    \t\t\tresult.x = event.pageX;\n    \t\t\tresult.y = event.pageY;\n    \t\t} else {\n    \t\t\tresult.x = event.clientX;\n    \t\t\tresult.y = event.clientY;\n    \t\t}\n\n    \t\treturn result;\n    \t};\n\n    \t/**\n    \t * Determines if the input is a Number or something that can be coerced to a Number\n    \t * @protected\n    \t * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested\n    \t * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number\n    \t */\n    \tOwl.prototype.isNumeric = function(number) {\n    \t\treturn !isNaN(parseFloat(number));\n    \t};\n\n    \t/**\n    \t * Gets the difference of two vectors.\n    \t * @todo #261\n    \t * @protected\n    \t * @param {Object} - The first vector.\n    \t * @param {Object} - The second vector.\n    \t * @returns {Object} - The difference.\n    \t */\n    \tOwl.prototype.difference = function(first, second) {\n    \t\treturn {\n    \t\t\tx: first.x - second.x,\n    \t\t\ty: first.y - second.y\n    \t\t};\n    \t};\n\n    \t/**\n    \t * The jQuery Plugin for the Owl Carousel\n    \t * @todo Navigation plugin `next` and `prev`\n    \t * @public\n    \t */\n    \t$.fn.owlCarousel = function(option) {\n    \t\tvar args = Array.prototype.slice.call(arguments, 1);\n\n    \t\treturn this.each(function() {\n    \t\t\tvar $this = $(this),\n    \t\t\t\tdata = $this.data('owl.carousel');\n\n    \t\t\tif (!data) {\n    \t\t\t\tdata = new Owl(this, typeof option == 'object' && option);\n    \t\t\t\t$this.data('owl.carousel', data);\n\n    \t\t\t\t$.each([\n    \t\t\t\t\t'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'\n    \t\t\t\t], function(i, event) {\n    \t\t\t\t\tdata.register({ type: Owl.Type.Event, name: event });\n    \t\t\t\t\tdata.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {\n    \t\t\t\t\t\tif (e.namespace && e.relatedTarget !== this) {\n    \t\t\t\t\t\t\tthis.suppress([ event ]);\n    \t\t\t\t\t\t\tdata[event].apply(this, [].slice.call(arguments, 1));\n    \t\t\t\t\t\t\tthis.release([ event ]);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}, data));\n    \t\t\t\t});\n    \t\t\t}\n\n    \t\t\tif (typeof option == 'string' && option.charAt(0) !== '_') {\n    \t\t\t\tdata[option].apply(data, args);\n    \t\t\t}\n    \t\t});\n    \t};\n\n    \t/**\n    \t * The constructor for the jQuery Plugin\n    \t * @public\n    \t */\n    \t$.fn.owlCarousel.Constructor = Owl;\n\n    })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n    (function($, window, document, undefined) {\n\n    \t/**\n    \t * Creates the auto refresh plugin.\n    \t * @class The Auto Refresh Plugin\n    \t * @param {Owl} carousel - The Owl Carousel\n    \t */\n    \tvar AutoRefresh = function(carousel) {\n    \t\t/**\n    \t\t * Reference to the core.\n    \t\t * @protected\n    \t\t * @type {Owl}\n    \t\t */\n    \t\tthis._core = carousel;\n\n    \t\t/**\n    \t\t * Refresh interval.\n    \t\t * @protected\n    \t\t * @type {number}\n    \t\t */\n    \t\tthis._interval = null;\n\n    \t\t/**\n    \t\t * Whether the element is currently visible or not.\n    \t\t * @protected\n    \t\t * @type {Boolean}\n    \t\t */\n    \t\tthis._visible = null;\n\n    \t\t/**\n    \t\t * All event handlers.\n    \t\t * @protected\n    \t\t * @type {Object}\n    \t\t */\n    \t\tthis._handlers = {\n    \t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this._core.settings.autoRefresh) {\n    \t\t\t\t\tthis.watch();\n    \t\t\t\t}\n    \t\t\t}, this)\n    \t\t};\n\n    \t\t// set default options\n    \t\tthis._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);\n\n    \t\t// register event handlers\n    \t\tthis._core.$element.on(this._handlers);\n    \t};\n\n    \t/**\n    \t * Default options.\n    \t * @public\n    \t */\n    \tAutoRefresh.Defaults = {\n    \t\tautoRefresh: true,\n    \t\tautoRefreshInterval: 500\n    \t};\n\n    \t/**\n    \t * Watches the element.\n    \t */\n    \tAutoRefresh.prototype.watch = function() {\n    \t\tif (this._interval) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\tthis._visible = this._core.isVisible();\n    \t\tthis._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);\n    \t};\n\n    \t/**\n    \t * Refreshes the element.\n    \t */\n    \tAutoRefresh.prototype.refresh = function() {\n    \t\tif (this._core.isVisible() === this._visible) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\tthis._visible = !this._visible;\n\n    \t\tthis._core.$element.toggleClass('owl-hidden', !this._visible);\n\n    \t\tthis._visible && (this._core.invalidate('width') && this._core.refresh());\n    \t};\n\n    \t/**\n    \t * Destroys the plugin.\n    \t */\n    \tAutoRefresh.prototype.destroy = function() {\n    \t\tvar handler, property;\n\n    \t\twindow.clearInterval(this._interval);\n\n    \t\tfor (handler in this._handlers) {\n    \t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n    \t\t}\n    \t\tfor (property in Object.getOwnPropertyNames(this)) {\n    \t\t\ttypeof this[property] != 'function' && (this[property] = null);\n    \t\t}\n    \t};\n\n    \t$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;\n\n    })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n    (function($, window, document, undefined) {\n\n    \t/**\n    \t * Creates the lazy plugin.\n    \t * @class The Lazy Plugin\n    \t * @param {Owl} carousel - The Owl Carousel\n    \t */\n    \tvar Lazy = function(carousel) {\n\n    \t\t/**\n    \t\t * Reference to the core.\n    \t\t * @protected\n    \t\t * @type {Owl}\n    \t\t */\n    \t\tthis._core = carousel;\n\n    \t\t/**\n    \t\t * Already loaded items.\n    \t\t * @protected\n    \t\t * @type {Array.<jQuery>}\n    \t\t */\n    \t\tthis._loaded = [];\n\n    \t\t/**\n    \t\t * Event handlers.\n    \t\t * @protected\n    \t\t * @type {Object}\n    \t\t */\n    \t\tthis._handlers = {\n    \t\t\t'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (!e.namespace) {\n    \t\t\t\t\treturn;\n    \t\t\t\t}\n\n    \t\t\t\tif (!this._core.settings || !this._core.settings.lazyLoad) {\n    \t\t\t\t\treturn;\n    \t\t\t\t}\n\n    \t\t\t\tif ((e.property && e.property.name == 'position') || e.type == 'initialized') {\n    \t\t\t\t\tvar settings = this._core.settings,\n    \t\t\t\t\t\tn = (settings.center && Math.ceil(settings.items / 2) || settings.items),\n    \t\t\t\t\t\ti = ((settings.center && n * -1) || 0),\n    \t\t\t\t\t\tposition = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,\n    \t\t\t\t\t\tclones = this._core.clones().length,\n    \t\t\t\t\t\tload = $.proxy(function(i, v) { this.load(v); }, this);\n    \t\t\t\t\t//TODO: Need documentation for this new option\n    \t\t\t\t\tif (settings.lazyLoadEager > 0) {\n    \t\t\t\t\t\tn += settings.lazyLoadEager;\n    \t\t\t\t\t\t// If the carousel is looping also preload images that are to the \"left\"\n    \t\t\t\t\t\tif (settings.loop) {\n                  position -= settings.lazyLoadEager;\n                  n++;\n                }\n    \t\t\t\t\t}\n\n    \t\t\t\t\twhile (i++ < n) {\n    \t\t\t\t\t\tthis.load(clones / 2 + this._core.relative(position));\n    \t\t\t\t\t\tclones && $.each(this._core.clones(this._core.relative(position)), load);\n    \t\t\t\t\t\tposition++;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}, this)\n    \t\t};\n\n    \t\t// set the default options\n    \t\tthis._core.options = $.extend({}, Lazy.Defaults, this._core.options);\n\n    \t\t// register event handler\n    \t\tthis._core.$element.on(this._handlers);\n    \t};\n\n    \t/**\n    \t * Default options.\n    \t * @public\n    \t */\n    \tLazy.Defaults = {\n    \t\tlazyLoad: false,\n    \t\tlazyLoadEager: 0\n    \t};\n\n    \t/**\n    \t * Loads all resources of an item at the specified position.\n    \t * @param {Number} position - The absolute position of the item.\n    \t * @protected\n    \t */\n    \tLazy.prototype.load = function(position) {\n    \t\tvar $item = this._core.$stage.children().eq(position),\n    \t\t\t$elements = $item && $item.find('.owl-lazy');\n\n    \t\tif (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\t$elements.each($.proxy(function(index, element) {\n    \t\t\tvar $element = $(element), image,\n                    url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src') || $element.attr('data-srcset');\n\n    \t\t\tthis._core.trigger('load', { element: $element, url: url }, 'lazy');\n\n    \t\t\tif ($element.is('img')) {\n    \t\t\t\t$element.one('load.owl.lazy', $.proxy(function() {\n    \t\t\t\t\t$element.css('opacity', 1);\n    \t\t\t\t\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n    \t\t\t\t}, this)).attr('src', url);\n                } else if ($element.is('source')) {\n                    $element.one('load.owl.lazy', $.proxy(function() {\n                        this._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n                    }, this)).attr('srcset', url);\n    \t\t\t} else {\n    \t\t\t\timage = new Image();\n    \t\t\t\timage.onload = $.proxy(function() {\n    \t\t\t\t\t$element.css({\n    \t\t\t\t\t\t'background-image': 'url(\"' + url + '\")',\n    \t\t\t\t\t\t'opacity': '1'\n    \t\t\t\t\t});\n    \t\t\t\t\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n    \t\t\t\t}, this);\n    \t\t\t\timage.src = url;\n    \t\t\t}\n    \t\t}, this));\n\n    \t\tthis._loaded.push($item.get(0));\n    \t};\n\n    \t/**\n    \t * Destroys the plugin.\n    \t * @public\n    \t */\n    \tLazy.prototype.destroy = function() {\n    \t\tvar handler, property;\n\n    \t\tfor (handler in this.handlers) {\n    \t\t\tthis._core.$element.off(handler, this.handlers[handler]);\n    \t\t}\n    \t\tfor (property in Object.getOwnPropertyNames(this)) {\n    \t\t\ttypeof this[property] != 'function' && (this[property] = null);\n    \t\t}\n    \t};\n\n    \t$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\n\n    })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n    (function($, window, document, undefined) {\n\n    \t/**\n    \t * Creates the auto height plugin.\n    \t * @class The Auto Height Plugin\n    \t * @param {Owl} carousel - The Owl Carousel\n    \t */\n    \tvar AutoHeight = function(carousel) {\n    \t\t/**\n    \t\t * Reference to the core.\n    \t\t * @protected\n    \t\t * @type {Owl}\n    \t\t */\n    \t\tthis._core = carousel;\n\n    \t\tthis._previousHeight = null;\n\n    \t\t/**\n    \t\t * All event handlers.\n    \t\t * @protected\n    \t\t * @type {Object}\n    \t\t */\n    \t\tthis._handlers = {\n    \t\t\t'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this._core.settings.autoHeight) {\n    \t\t\t\t\tthis.update();\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'changed.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this._core.settings.autoHeight && e.property.name === 'position'){\n    \t\t\t\t\tthis.update();\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'loaded.owl.lazy': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this._core.settings.autoHeight\n    \t\t\t\t\t&& e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {\n    \t\t\t\t\tthis.update();\n    \t\t\t\t}\n    \t\t\t}, this)\n    \t\t};\n\n    \t\t// set default options\n    \t\tthis._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);\n\n    \t\t// register event handlers\n    \t\tthis._core.$element.on(this._handlers);\n    \t\tthis._intervalId = null;\n    \t\tvar refThis = this;\n\n    \t\t// These changes have been taken from a PR by gavrochelegnou proposed in #1575\n    \t\t// and have been made compatible with the latest jQuery version\n    \t\t$(window).on('load', function() {\n    \t\t\tif (refThis._core.settings.autoHeight) {\n    \t\t\t\trefThis.update();\n    \t\t\t}\n    \t\t});\n\n    \t\t// Autoresize the height of the carousel when window is resized\n    \t\t// When carousel has images, the height is dependent on the width\n    \t\t// and should also change on resize\n    \t\t$(window).resize(function() {\n    \t\t\tif (refThis._core.settings.autoHeight) {\n    \t\t\t\tif (refThis._intervalId != null) {\n    \t\t\t\t\tclearTimeout(refThis._intervalId);\n    \t\t\t\t}\n\n    \t\t\t\trefThis._intervalId = setTimeout(function() {\n    \t\t\t\t\trefThis.update();\n    \t\t\t\t}, 250);\n    \t\t\t}\n    \t\t});\n\n    \t};\n\n    \t/**\n    \t * Default options.\n    \t * @public\n    \t */\n    \tAutoHeight.Defaults = {\n    \t\tautoHeight: false,\n    \t\tautoHeightClass: 'owl-height'\n    \t};\n\n    \t/**\n    \t * Updates the view.\n    \t */\n    \tAutoHeight.prototype.update = function() {\n    \t\tvar start = this._core._current,\n    \t\t\tend = start + this._core.settings.items,\n    \t\t\tlazyLoadEnabled = this._core.settings.lazyLoad,\n    \t\t\tvisible = this._core.$stage.children().toArray().slice(start, end),\n    \t\t\theights = [],\n    \t\t\tmaxheight = 0;\n\n    \t\t$.each(visible, function(index, item) {\n    \t\t\theights.push($(item).height());\n    \t\t});\n\n    \t\tmaxheight = Math.max.apply(null, heights);\n\n    \t\tif (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {\n    \t\t\tmaxheight = this._previousHeight;\n    \t\t}\n\n    \t\tthis._previousHeight = maxheight;\n\n    \t\tthis._core.$stage.parent()\n    \t\t\t.height(maxheight)\n    \t\t\t.addClass(this._core.settings.autoHeightClass);\n    \t};\n\n    \tAutoHeight.prototype.destroy = function() {\n    \t\tvar handler, property;\n\n    \t\tfor (handler in this._handlers) {\n    \t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n    \t\t}\n    \t\tfor (property in Object.getOwnPropertyNames(this)) {\n    \t\t\ttypeof this[property] !== 'function' && (this[property] = null);\n    \t\t}\n    \t};\n\n    \t$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\n\n    })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n    (function($, window, document, undefined) {\n\n    \t/**\n    \t * Creates the video plugin.\n    \t * @class The Video Plugin\n    \t * @param {Owl} carousel - The Owl Carousel\n    \t */\n    \tvar Video = function(carousel) {\n    \t\t/**\n    \t\t * Reference to the core.\n    \t\t * @protected\n    \t\t * @type {Owl}\n    \t\t */\n    \t\tthis._core = carousel;\n\n    \t\t/**\n    \t\t * Cache all video URLs.\n    \t\t * @protected\n    \t\t * @type {Object}\n    \t\t */\n    \t\tthis._videos = {};\n\n    \t\t/**\n    \t\t * Current playing item.\n    \t\t * @protected\n    \t\t * @type {jQuery}\n    \t\t */\n    \t\tthis._playing = null;\n\n    \t\t/**\n    \t\t * All event handlers.\n    \t\t * @todo The cloned content removale is too late\n    \t\t * @protected\n    \t\t * @type {Object}\n    \t\t */\n    \t\tthis._handlers = {\n    \t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace) {\n    \t\t\t\t\tthis._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'resize.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this._core.settings.video && this.isInFullScreen()) {\n    \t\t\t\t\te.preventDefault();\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'refreshed.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this._core.is('resizing')) {\n    \t\t\t\t\tthis._core.$stage.find('.cloned .owl-video-frame').remove();\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'changed.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && e.property.name === 'position' && this._playing) {\n    \t\t\t\t\tthis.stop();\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'prepared.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (!e.namespace) {\n    \t\t\t\t\treturn;\n    \t\t\t\t}\n\n    \t\t\t\tvar $element = $(e.content).find('.owl-video');\n\n    \t\t\t\tif ($element.length) {\n    \t\t\t\t\t$element.css('display', 'none');\n    \t\t\t\t\tthis.fetch($element, $(e.content));\n    \t\t\t\t}\n    \t\t\t}, this)\n    \t\t};\n\n    \t\t// set default options\n    \t\tthis._core.options = $.extend({}, Video.Defaults, this._core.options);\n\n    \t\t// register event handlers\n    \t\tthis._core.$element.on(this._handlers);\n\n    \t\tthis._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {\n    \t\t\tthis.play(e);\n    \t\t}, this));\n    \t};\n\n    \t/**\n    \t * Default options.\n    \t * @public\n    \t */\n    \tVideo.Defaults = {\n    \t\tvideo: false,\n    \t\tvideoHeight: false,\n    \t\tvideoWidth: false\n    \t};\n\n    \t/**\n    \t * Gets the video ID and the type (YouTube/Vimeo/vzaar only).\n    \t * @protected\n    \t * @param {jQuery} target - The target containing the video data.\n    \t * @param {jQuery} item - The item containing the video.\n    \t */\n    \tVideo.prototype.fetch = function(target, item) {\n    \t\t\tvar type = (function() {\n    \t\t\t\t\tif (target.attr('data-vimeo-id')) {\n    \t\t\t\t\t\treturn 'vimeo';\n    \t\t\t\t\t} else if (target.attr('data-vzaar-id')) {\n    \t\t\t\t\t\treturn 'vzaar'\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\treturn 'youtube';\n    \t\t\t\t\t}\n    \t\t\t\t})(),\n    \t\t\t\tid = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),\n    \t\t\t\twidth = target.attr('data-width') || this._core.settings.videoWidth,\n    \t\t\t\theight = target.attr('data-height') || this._core.settings.videoHeight,\n    \t\t\t\turl = target.attr('href');\n\n    \t\tif (url) {\n\n    \t\t\t/*\n    \t\t\t\t\tParses the id's out of the following urls (and probably more):\n    \t\t\t\t\thttps://www.youtube.com/watch?v=:id\n    \t\t\t\t\thttps://youtu.be/:id\n    \t\t\t\t\thttps://vimeo.com/:id\n    \t\t\t\t\thttps://vimeo.com/channels/:channel/:id\n    \t\t\t\t\thttps://vimeo.com/groups/:group/videos/:id\n    \t\t\t\t\thttps://app.vzaar.com/videos/:id\n\n    \t\t\t\t\tVisual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F\n    \t\t\t*/\n\n    \t\t\tid = url.match(/(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com|be\\-nocookie\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/);\n\n    \t\t\tif (id[3].indexOf('youtu') > -1) {\n    \t\t\t\ttype = 'youtube';\n    \t\t\t} else if (id[3].indexOf('vimeo') > -1) {\n    \t\t\t\ttype = 'vimeo';\n    \t\t\t} else if (id[3].indexOf('vzaar') > -1) {\n    \t\t\t\ttype = 'vzaar';\n    \t\t\t} else {\n    \t\t\t\tthrow new Error('Video URL not supported.');\n    \t\t\t}\n    \t\t\tid = id[6];\n    \t\t} else {\n    \t\t\tthrow new Error('Missing video URL.');\n    \t\t}\n\n    \t\tthis._videos[url] = {\n    \t\t\ttype: type,\n    \t\t\tid: id,\n    \t\t\twidth: width,\n    \t\t\theight: height\n    \t\t};\n\n    \t\titem.attr('data-video', url);\n\n    \t\tthis.thumbnail(target, this._videos[url]);\n    \t};\n\n    \t/**\n    \t * Creates video thumbnail.\n    \t * @protected\n    \t * @param {jQuery} target - The target containing the video data.\n    \t * @param {Object} info - The video info object.\n    \t * @see `fetch`\n    \t */\n    \tVideo.prototype.thumbnail = function(target, video) {\n    \t\tvar tnLink,\n    \t\t\ticon,\n    \t\t\tpath,\n    \t\t\tdimensions = video.width && video.height ? 'width:' + video.width + 'px;height:' + video.height + 'px;' : '',\n    \t\t\tcustomTn = target.find('img'),\n    \t\t\tsrcType = 'src',\n    \t\t\tlazyClass = '',\n    \t\t\tsettings = this._core.settings,\n    \t\t\tcreate = function(path) {\n    \t\t\t\ticon = '<div class=\"owl-video-play-icon\"></div>';\n\n    \t\t\t\tif (settings.lazyLoad) {\n    \t\t\t\t\ttnLink = $('<div/>',{\n    \t\t\t\t\t\t\"class\": 'owl-video-tn ' + lazyClass,\n    \t\t\t\t\t\t\"srcType\": path\n    \t\t\t\t\t});\n    \t\t\t\t} else {\n    \t\t\t\t\ttnLink = $( '<div/>', {\n    \t\t\t\t\t\t\"class\": \"owl-video-tn\",\n    \t\t\t\t\t\t\"style\": 'opacity:1;background-image:url(' + path + ')'\n    \t\t\t\t\t});\n    \t\t\t\t}\n    \t\t\t\ttarget.after(tnLink);\n    \t\t\t\ttarget.after(icon);\n    \t\t\t};\n\n    \t\t// wrap video content into owl-video-wrapper div\n    \t\ttarget.wrap( $( '<div/>', {\n    \t\t\t\"class\": \"owl-video-wrapper\",\n    \t\t\t\"style\": dimensions\n    \t\t}));\n\n    \t\tif (this._core.settings.lazyLoad) {\n    \t\t\tsrcType = 'data-src';\n    \t\t\tlazyClass = 'owl-lazy';\n    \t\t}\n\n    \t\t// custom thumbnail\n    \t\tif (customTn.length) {\n    \t\t\tcreate(customTn.attr(srcType));\n    \t\t\tcustomTn.remove();\n    \t\t\treturn false;\n    \t\t}\n\n    \t\tif (video.type === 'youtube') {\n    \t\t\tpath = \"//img.youtube.com/vi/\" + video.id + \"/hqdefault.jpg\";\n    \t\t\tcreate(path);\n    \t\t} else if (video.type === 'vimeo') {\n    \t\t\t$.ajax({\n    \t\t\t\ttype: 'GET',\n    \t\t\t\turl: '//vimeo.com/api/v2/video/' + video.id + '.json',\n    \t\t\t\tjsonp: 'callback',\n    \t\t\t\tdataType: 'jsonp',\n    \t\t\t\tsuccess: function(data) {\n    \t\t\t\t\tpath = data[0].thumbnail_large;\n    \t\t\t\t\tcreate(path);\n    \t\t\t\t}\n    \t\t\t});\n    \t\t} else if (video.type === 'vzaar') {\n    \t\t\t$.ajax({\n    \t\t\t\ttype: 'GET',\n    \t\t\t\turl: '//vzaar.com/api/videos/' + video.id + '.json',\n    \t\t\t\tjsonp: 'callback',\n    \t\t\t\tdataType: 'jsonp',\n    \t\t\t\tsuccess: function(data) {\n    \t\t\t\t\tpath = data.framegrab_url;\n    \t\t\t\t\tcreate(path);\n    \t\t\t\t}\n    \t\t\t});\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Stops the current video.\n    \t * @public\n    \t */\n    \tVideo.prototype.stop = function() {\n    \t\tthis._core.trigger('stop', null, 'video');\n    \t\tthis._playing.find('.owl-video-frame').remove();\n    \t\tthis._playing.removeClass('owl-video-playing');\n    \t\tthis._playing = null;\n    \t\tthis._core.leave('playing');\n    \t\tthis._core.trigger('stopped', null, 'video');\n    \t};\n\n    \t/**\n    \t * Starts the current video.\n    \t * @public\n    \t * @param {Event} event - The event arguments.\n    \t */\n    \tVideo.prototype.play = function(event) {\n    \t\tvar target = $(event.target),\n    \t\t\titem = target.closest('.' + this._core.settings.itemClass),\n    \t\t\tvideo = this._videos[item.attr('data-video')],\n    \t\t\twidth = video.width || '100%',\n    \t\t\theight = video.height || this._core.$stage.height(),\n    \t\t\thtml,\n    \t\t\tiframe;\n\n    \t\tif (this._playing) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\tthis._core.enter('playing');\n    \t\tthis._core.trigger('play', null, 'video');\n\n    \t\titem = this._core.items(this._core.relative(item.index()));\n\n    \t\tthis._core.reset(item.index());\n\n    \t\thtml = $( '<iframe frameborder=\"0\" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>' );\n    \t\thtml.attr( 'height', height );\n    \t\thtml.attr( 'width', width );\n    \t\tif (video.type === 'youtube') {\n    \t\t\thtml.attr( 'src', '//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id );\n    \t\t} else if (video.type === 'vimeo') {\n    \t\t\thtml.attr( 'src', '//player.vimeo.com/video/' + video.id + '?autoplay=1' );\n    \t\t} else if (video.type === 'vzaar') {\n    \t\t\thtml.attr( 'src', '//view.vzaar.com/' + video.id + '/player?autoplay=true' );\n    \t\t}\n\n    \t\tiframe = $(html).wrap( '<div class=\"owl-video-frame\" />' ).insertAfter(item.find('.owl-video'));\n\n    \t\tthis._playing = item.addClass('owl-video-playing');\n    \t};\n\n    \t/**\n    \t * Checks whether an video is currently in full screen mode or not.\n    \t * @todo Bad style because looks like a readonly method but changes members.\n    \t * @protected\n    \t * @returns {Boolean}\n    \t */\n    \tVideo.prototype.isInFullScreen = function() {\n    \t\tvar element = document.fullscreenElement || document.mozFullScreenElement ||\n    \t\t\t\tdocument.webkitFullscreenElement;\n\n    \t\treturn element && $(element).parent().hasClass('owl-video-frame');\n    \t};\n\n    \t/**\n    \t * Destroys the plugin.\n    \t */\n    \tVideo.prototype.destroy = function() {\n    \t\tvar handler, property;\n\n    \t\tthis._core.$element.off('click.owl.video');\n\n    \t\tfor (handler in this._handlers) {\n    \t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n    \t\t}\n    \t\tfor (property in Object.getOwnPropertyNames(this)) {\n    \t\t\ttypeof this[property] != 'function' && (this[property] = null);\n    \t\t}\n    \t};\n\n    \t$.fn.owlCarousel.Constructor.Plugins.Video = Video;\n\n    })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n    (function($, window, document, undefined) {\n\n    \t/**\n    \t * Creates the animate plugin.\n    \t * @class The Navigation Plugin\n    \t * @param {Owl} scope - The Owl Carousel\n    \t */\n    \tvar Animate = function(scope) {\n    \t\tthis.core = scope;\n    \t\tthis.core.options = $.extend({}, Animate.Defaults, this.core.options);\n    \t\tthis.swapping = true;\n    \t\tthis.previous = undefined;\n    \t\tthis.next = undefined;\n\n    \t\tthis.handlers = {\n    \t\t\t'change.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && e.property.name == 'position') {\n    \t\t\t\t\tthis.previous = this.core.current();\n    \t\t\t\t\tthis.next = e.property.value;\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace) {\n    \t\t\t\t\tthis.swapping = e.type == 'translated';\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'translate.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\n    \t\t\t\t\tthis.swap();\n    \t\t\t\t}\n    \t\t\t}, this)\n    \t\t};\n\n    \t\tthis.core.$element.on(this.handlers);\n    \t};\n\n    \t/**\n    \t * Default options.\n    \t * @public\n    \t */\n    \tAnimate.Defaults = {\n    \t\tanimateOut: false,\n    \t\tanimateIn: false\n    \t};\n\n    \t/**\n    \t * Toggles the animation classes whenever an translations starts.\n    \t * @protected\n    \t * @returns {Boolean|undefined}\n    \t */\n    \tAnimate.prototype.swap = function() {\n\n    \t\tif (this.core.settings.items !== 1) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\tif (!$.support.animation || !$.support.transition) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\tthis.core.speed(0);\n\n    \t\tvar left,\n    \t\t\tclear = $.proxy(this.clear, this),\n    \t\t\tprevious = this.core.$stage.children().eq(this.previous),\n    \t\t\tnext = this.core.$stage.children().eq(this.next),\n    \t\t\tincoming = this.core.settings.animateIn,\n    \t\t\toutgoing = this.core.settings.animateOut;\n\n    \t\tif (this.core.current() === this.previous) {\n    \t\t\treturn;\n    \t\t}\n\n    \t\tif (outgoing) {\n    \t\t\tleft = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\n    \t\t\tprevious.one($.support.animation.end, clear)\n    \t\t\t\t.css( { 'left': left + 'px' } )\n    \t\t\t\t.addClass('animated owl-animated-out')\n    \t\t\t\t.addClass(outgoing);\n    \t\t}\n\n    \t\tif (incoming) {\n    \t\t\tnext.one($.support.animation.end, clear)\n    \t\t\t\t.addClass('animated owl-animated-in')\n    \t\t\t\t.addClass(incoming);\n    \t\t}\n    \t};\n\n    \tAnimate.prototype.clear = function(e) {\n    \t\t$(e.target).css( { 'left': '' } )\n    \t\t\t.removeClass('animated owl-animated-out owl-animated-in')\n    \t\t\t.removeClass(this.core.settings.animateIn)\n    \t\t\t.removeClass(this.core.settings.animateOut);\n    \t\tthis.core.onTransitionEnd();\n    \t};\n\n    \t/**\n    \t * Destroys the plugin.\n    \t * @public\n    \t */\n    \tAnimate.prototype.destroy = function() {\n    \t\tvar handler, property;\n\n    \t\tfor (handler in this.handlers) {\n    \t\t\tthis.core.$element.off(handler, this.handlers[handler]);\n    \t\t}\n    \t\tfor (property in Object.getOwnPropertyNames(this)) {\n    \t\t\ttypeof this[property] != 'function' && (this[property] = null);\n    \t\t}\n    \t};\n\n    \t$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\n\n    })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n    (function($, window, document, undefined) {\n\n    \t/**\n    \t * Creates the autoplay plugin.\n    \t * @class The Autoplay Plugin\n    \t * @param {Owl} scope - The Owl Carousel\n    \t */\n    \tvar Autoplay = function(carousel) {\n    \t\t/**\n    \t\t * Reference to the core.\n    \t\t * @protected\n    \t\t * @type {Owl}\n    \t\t */\n    \t\tthis._core = carousel;\n\n    \t\t/**\n    \t\t * The autoplay timeout id.\n    \t\t * @type {Number}\n    \t\t */\n    \t\tthis._call = null;\n\n    \t\t/**\n    \t\t * Depending on the state of the plugin, this variable contains either\n    \t\t * the start time of the timer or the current timer value if it's\n    \t\t * paused. Since we start in a paused state we initialize the timer\n    \t\t * value.\n    \t\t * @type {Number}\n    \t\t */\n    \t\tthis._time = 0;\n\n    \t\t/**\n    \t\t * Stores the timeout currently used.\n    \t\t * @type {Number}\n    \t\t */\n    \t\tthis._timeout = 0;\n\n    \t\t/**\n    \t\t * Indicates whenever the autoplay is paused.\n    \t\t * @type {Boolean}\n    \t\t */\n    \t\tthis._paused = true;\n\n    \t\t/**\n    \t\t * All event handlers.\n    \t\t * @protected\n    \t\t * @type {Object}\n    \t\t */\n    \t\tthis._handlers = {\n    \t\t\t'changed.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && e.property.name === 'settings') {\n    \t\t\t\t\tif (this._core.settings.autoplay) {\n    \t\t\t\t\t\tthis.play();\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tthis.stop();\n    \t\t\t\t\t}\n    \t\t\t\t} else if (e.namespace && e.property.name === 'position' && this._paused) {\n    \t\t\t\t\t// Reset the timer. This code is triggered when the position\n    \t\t\t\t\t// of the carousel was changed through user interaction.\n    \t\t\t\t\tthis._time = 0;\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this._core.settings.autoplay) {\n    \t\t\t\t\tthis.play();\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'play.owl.autoplay': $.proxy(function(e, t, s) {\n    \t\t\t\tif (e.namespace) {\n    \t\t\t\t\tthis.play(t, s);\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'stop.owl.autoplay': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace) {\n    \t\t\t\t\tthis.stop();\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'mouseover.owl.autoplay': $.proxy(function() {\n    \t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n    \t\t\t\t\tthis.pause();\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'mouseleave.owl.autoplay': $.proxy(function() {\n    \t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n    \t\t\t\t\tthis.play();\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'touchstart.owl.core': $.proxy(function() {\n    \t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n    \t\t\t\t\tthis.pause();\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'touchend.owl.core': $.proxy(function() {\n    \t\t\t\tif (this._core.settings.autoplayHoverPause) {\n    \t\t\t\t\tthis.play();\n    \t\t\t\t}\n    \t\t\t}, this)\n    \t\t};\n\n    \t\t// register event handlers\n    \t\tthis._core.$element.on(this._handlers);\n\n    \t\t// set default options\n    \t\tthis._core.options = $.extend({}, Autoplay.Defaults, this._core.options);\n    \t};\n\n    \t/**\n    \t * Default options.\n    \t * @public\n    \t */\n    \tAutoplay.Defaults = {\n    \t\tautoplay: false,\n    \t\tautoplayTimeout: 5000,\n    \t\tautoplayHoverPause: false,\n    \t\tautoplaySpeed: false\n    \t};\n\n    \t/**\n    \t * Transition to the next slide and set a timeout for the next transition.\n    \t * @private\n    \t * @param {Number} [speed] - The animation speed for the animations.\n    \t */\n    \tAutoplay.prototype._next = function(speed) {\n    \t\tthis._call = window.setTimeout(\n    \t\t\t$.proxy(this._next, this, speed),\n    \t\t\tthis._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()\n    \t\t);\n\n    \t\tif (this._core.is('interacting') || document.hidden) {\n    \t\t\treturn;\n    \t\t}\n    \t\tthis._core.next(speed || this._core.settings.autoplaySpeed);\n    \t};\n\n    \t/**\n    \t * Reads the current timer value when the timer is playing.\n    \t * @public\n    \t */\n    \tAutoplay.prototype.read = function() {\n    \t\treturn new Date().getTime() - this._time;\n    \t};\n\n    \t/**\n    \t * Starts the autoplay.\n    \t * @public\n    \t * @param {Number} [timeout] - The interval before the next animation starts.\n    \t * @param {Number} [speed] - The animation speed for the animations.\n    \t */\n    \tAutoplay.prototype.play = function(timeout, speed) {\n    \t\tvar elapsed;\n\n    \t\tif (!this._core.is('rotating')) {\n    \t\t\tthis._core.enter('rotating');\n    \t\t}\n\n    \t\ttimeout = timeout || this._core.settings.autoplayTimeout;\n\n    \t\t// Calculate the elapsed time since the last transition. If the carousel\n    \t\t// wasn't playing this calculation will yield zero.\n    \t\telapsed = Math.min(this._time % (this._timeout || timeout), timeout);\n\n    \t\tif (this._paused) {\n    \t\t\t// Start the clock.\n    \t\t\tthis._time = this.read();\n    \t\t\tthis._paused = false;\n    \t\t} else {\n    \t\t\t// Clear the active timeout to allow replacement.\n    \t\t\twindow.clearTimeout(this._call);\n    \t\t}\n\n    \t\t// Adjust the origin of the timer to match the new timeout value.\n    \t\tthis._time += this.read() % timeout - elapsed;\n\n    \t\tthis._timeout = timeout;\n    \t\tthis._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed);\n    \t};\n\n    \t/**\n    \t * Stops the autoplay.\n    \t * @public\n    \t */\n    \tAutoplay.prototype.stop = function() {\n    \t\tif (this._core.is('rotating')) {\n    \t\t\t// Reset the clock.\n    \t\t\tthis._time = 0;\n    \t\t\tthis._paused = true;\n\n    \t\t\twindow.clearTimeout(this._call);\n    \t\t\tthis._core.leave('rotating');\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Pauses the autoplay.\n    \t * @public\n    \t */\n    \tAutoplay.prototype.pause = function() {\n    \t\tif (this._core.is('rotating') && !this._paused) {\n    \t\t\t// Pause the clock.\n    \t\t\tthis._time = this.read();\n    \t\t\tthis._paused = true;\n\n    \t\t\twindow.clearTimeout(this._call);\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Destroys the plugin.\n    \t */\n    \tAutoplay.prototype.destroy = function() {\n    \t\tvar handler, property;\n\n    \t\tthis.stop();\n\n    \t\tfor (handler in this._handlers) {\n    \t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n    \t\t}\n    \t\tfor (property in Object.getOwnPropertyNames(this)) {\n    \t\t\ttypeof this[property] != 'function' && (this[property] = null);\n    \t\t}\n    \t};\n\n    \t$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\n\n    })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n    (function($, window, document, undefined) {\n\n    \t/**\n    \t * Creates the navigation plugin.\n    \t * @class The Navigation Plugin\n    \t * @param {Owl} carousel - The Owl Carousel.\n    \t */\n    \tvar Navigation = function(carousel) {\n    \t\t/**\n    \t\t * Reference to the core.\n    \t\t * @protected\n    \t\t * @type {Owl}\n    \t\t */\n    \t\tthis._core = carousel;\n\n    \t\t/**\n    \t\t * Indicates whether the plugin is initialized or not.\n    \t\t * @protected\n    \t\t * @type {Boolean}\n    \t\t */\n    \t\tthis._initialized = false;\n\n    \t\t/**\n    \t\t * The current paging indexes.\n    \t\t * @protected\n    \t\t * @type {Array}\n    \t\t */\n    \t\tthis._pages = [];\n\n    \t\t/**\n    \t\t * All DOM elements of the user interface.\n    \t\t * @protected\n    \t\t * @type {Object}\n    \t\t */\n    \t\tthis._controls = {};\n\n    \t\t/**\n    \t\t * Markup for an indicator.\n    \t\t * @protected\n    \t\t * @type {Array.<String>}\n    \t\t */\n    \t\tthis._templates = [];\n\n    \t\t/**\n    \t\t * The carousel element.\n    \t\t * @type {jQuery}\n    \t\t */\n    \t\tthis.$element = this._core.$element;\n\n    \t\t/**\n    \t\t * Overridden methods of the carousel.\n    \t\t * @protected\n    \t\t * @type {Object}\n    \t\t */\n    \t\tthis._overrides = {\n    \t\t\tnext: this._core.next,\n    \t\t\tprev: this._core.prev,\n    \t\t\tto: this._core.to\n    \t\t};\n\n    \t\t/**\n    \t\t * All event handlers.\n    \t\t * @protected\n    \t\t * @type {Object}\n    \t\t */\n    \t\tthis._handlers = {\n    \t\t\t'prepared.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n    \t\t\t\t\tthis._templates.push('<div class=\"' + this._core.settings.dotClass + '\">' +\n    \t\t\t\t\t\t$(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'added.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n    \t\t\t\t\tthis._templates.splice(e.position, 0, this._templates.pop());\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'remove.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n    \t\t\t\t\tthis._templates.splice(e.position, 1);\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'changed.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && e.property.name == 'position') {\n    \t\t\t\t\tthis.draw();\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && !this._initialized) {\n    \t\t\t\t\tthis._core.trigger('initialize', null, 'navigation');\n    \t\t\t\t\tthis.initialize();\n    \t\t\t\t\tthis.update();\n    \t\t\t\t\tthis.draw();\n    \t\t\t\t\tthis._initialized = true;\n    \t\t\t\t\tthis._core.trigger('initialized', null, 'navigation');\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'refreshed.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this._initialized) {\n    \t\t\t\t\tthis._core.trigger('refresh', null, 'navigation');\n    \t\t\t\t\tthis.update();\n    \t\t\t\t\tthis.draw();\n    \t\t\t\t\tthis._core.trigger('refreshed', null, 'navigation');\n    \t\t\t\t}\n    \t\t\t}, this)\n    \t\t};\n\n    \t\t// set default options\n    \t\tthis._core.options = $.extend({}, Navigation.Defaults, this._core.options);\n\n    \t\t// register event handlers\n    \t\tthis.$element.on(this._handlers);\n    \t};\n\n    \t/**\n    \t * Default options.\n    \t * @public\n    \t * @todo Rename `slideBy` to `navBy`\n    \t */\n    \tNavigation.Defaults = {\n    \t\tnav: false,\n    \t\tnavText: [\n    \t\t\t'<span aria-label=\"' + 'Previous' + '\">&#x2039;</span>',\n    \t\t\t'<span aria-label=\"' + 'Next' + '\">&#x203a;</span>'\n    \t\t],\n    \t\tnavSpeed: false,\n    \t\tnavElement: 'button type=\"button\" role=\"presentation\"',\n    \t\tnavContainer: false,\n    \t\tnavContainerClass: 'owl-nav',\n    \t\tnavClass: [\n    \t\t\t'owl-prev',\n    \t\t\t'owl-next'\n    \t\t],\n    \t\tslideBy: 1,\n    \t\tdotClass: 'owl-dot',\n    \t\tdotsClass: 'owl-dots',\n    \t\tdots: true,\n    \t\tdotsEach: false,\n    \t\tdotsData: false,\n    \t\tdotsSpeed: false,\n    \t\tdotsContainer: false\n    \t};\n\n    \t/**\n    \t * Initializes the layout of the plugin and extends the carousel.\n    \t * @protected\n    \t */\n    \tNavigation.prototype.initialize = function() {\n    \t\tvar override,\n    \t\t\tsettings = this._core.settings;\n\n    \t\t// create DOM structure for relative navigation\n    \t\tthis._controls.$relative = (settings.navContainer ? $(settings.navContainer)\n    \t\t\t: $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');\n\n    \t\tthis._controls.$previous = $('<' + settings.navElement + '>')\n    \t\t\t.addClass(settings.navClass[0])\n    \t\t\t.html(settings.navText[0])\n    \t\t\t.prependTo(this._controls.$relative)\n    \t\t\t.on('click', $.proxy(function(e) {\n    \t\t\t\tthis.prev(settings.navSpeed);\n    \t\t\t}, this));\n    \t\tthis._controls.$next = $('<' + settings.navElement + '>')\n    \t\t\t.addClass(settings.navClass[1])\n    \t\t\t.html(settings.navText[1])\n    \t\t\t.appendTo(this._controls.$relative)\n    \t\t\t.on('click', $.proxy(function(e) {\n    \t\t\t\tthis.next(settings.navSpeed);\n    \t\t\t}, this));\n\n    \t\t// create DOM structure for absolute navigation\n    \t\tif (!settings.dotsData) {\n    \t\t\tthis._templates = [ $('<button role=\"button\">')\n    \t\t\t\t.addClass(settings.dotClass)\n    \t\t\t\t.append($('<span>'))\n    \t\t\t\t.prop('outerHTML') ];\n    \t\t}\n\n    \t\tthis._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)\n    \t\t\t: $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');\n\n    \t\tthis._controls.$absolute.on('click', 'button', $.proxy(function(e) {\n    \t\t\tvar index = $(e.target).parent().is(this._controls.$absolute)\n    \t\t\t\t? $(e.target).index() : $(e.target).parent().index();\n\n    \t\t\te.preventDefault();\n\n    \t\t\tthis.to(index, settings.dotsSpeed);\n    \t\t}, this));\n\n    \t\t/*$el.on('focusin', function() {\n    \t\t\t$(document).off(\".carousel\");\n\n    \t\t\t$(document).on('keydown.carousel', function(e) {\n    \t\t\t\tif(e.keyCode == 37) {\n    \t\t\t\t\t$el.trigger('prev.owl')\n    \t\t\t\t}\n    \t\t\t\tif(e.keyCode == 39) {\n    \t\t\t\t\t$el.trigger('next.owl')\n    \t\t\t\t}\n    \t\t\t});\n    \t\t});*/\n\n    \t\t// override public methods of the carousel\n    \t\tfor (override in this._overrides) {\n    \t\t\tthis._core[override] = $.proxy(this[override], this);\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Destroys the plugin.\n    \t * @protected\n    \t */\n    \tNavigation.prototype.destroy = function() {\n    \t\tvar handler, control, property, override, settings;\n    \t\tsettings = this._core.settings;\n\n    \t\tfor (handler in this._handlers) {\n    \t\t\tthis.$element.off(handler, this._handlers[handler]);\n    \t\t}\n    \t\tfor (control in this._controls) {\n    \t\t\tif (control === '$relative' && settings.navContainer) {\n    \t\t\t\tthis._controls[control].html('');\n    \t\t\t} else {\n    \t\t\t\tthis._controls[control].remove();\n    \t\t\t}\n    \t\t}\n    \t\tfor (override in this.overides) {\n    \t\t\tthis._core[override] = this._overrides[override];\n    \t\t}\n    \t\tfor (property in Object.getOwnPropertyNames(this)) {\n    \t\t\ttypeof this[property] != 'function' && (this[property] = null);\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Updates the internal state.\n    \t * @protected\n    \t */\n    \tNavigation.prototype.update = function() {\n    \t\tvar i, j, k,\n    \t\t\tlower = this._core.clones().length / 2,\n    \t\t\tupper = lower + this._core.items().length,\n    \t\t\tmaximum = this._core.maximum(true),\n    \t\t\tsettings = this._core.settings,\n    \t\t\tsize = settings.center || settings.autoWidth || settings.dotsData\n    \t\t\t\t? 1 : settings.dotsEach || settings.items;\n\n    \t\tif (settings.slideBy !== 'page') {\n    \t\t\tsettings.slideBy = Math.min(settings.slideBy, settings.items);\n    \t\t}\n\n    \t\tif (settings.dots || settings.slideBy == 'page') {\n    \t\t\tthis._pages = [];\n\n    \t\t\tfor (i = lower, j = 0, k = 0; i < upper; i++) {\n    \t\t\t\tif (j >= size || j === 0) {\n    \t\t\t\t\tthis._pages.push({\n    \t\t\t\t\t\tstart: Math.min(maximum, i - lower),\n    \t\t\t\t\t\tend: i - lower + size - 1\n    \t\t\t\t\t});\n    \t\t\t\t\tif (Math.min(maximum, i - lower) === maximum) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t\tj = 0, ++k;\n    \t\t\t\t}\n    \t\t\t\tj += this._core.mergers(this._core.relative(i));\n    \t\t\t}\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Draws the user interface.\n    \t * @todo The option `dotsData` wont work.\n    \t * @protected\n    \t */\n    \tNavigation.prototype.draw = function() {\n    \t\tvar difference,\n    \t\t\tsettings = this._core.settings,\n    \t\t\tdisabled = this._core.items().length <= settings.items,\n    \t\t\tindex = this._core.relative(this._core.current()),\n    \t\t\tloop = settings.loop || settings.rewind;\n\n    \t\tthis._controls.$relative.toggleClass('disabled', !settings.nav || disabled);\n\n    \t\tif (settings.nav) {\n    \t\t\tthis._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));\n    \t\t\tthis._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));\n    \t\t}\n\n    \t\tthis._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);\n\n    \t\tif (settings.dots) {\n    \t\t\tdifference = this._pages.length - this._controls.$absolute.children().length;\n\n    \t\t\tif (settings.dotsData && difference !== 0) {\n    \t\t\t\tthis._controls.$absolute.html(this._templates.join(''));\n    \t\t\t} else if (difference > 0) {\n    \t\t\t\tthis._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));\n    \t\t\t} else if (difference < 0) {\n    \t\t\t\tthis._controls.$absolute.children().slice(difference).remove();\n    \t\t\t}\n\n    \t\t\tthis._controls.$absolute.find('.active').removeClass('active');\n    \t\t\tthis._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');\n    \t\t}\n    \t};\n\n    \t/**\n    \t * Extends event data.\n    \t * @protected\n    \t * @param {Event} event - The event object which gets thrown.\n    \t */\n    \tNavigation.prototype.onTrigger = function(event) {\n    \t\tvar settings = this._core.settings;\n\n    \t\tevent.page = {\n    \t\t\tindex: $.inArray(this.current(), this._pages),\n    \t\t\tcount: this._pages.length,\n    \t\t\tsize: settings && (settings.center || settings.autoWidth || settings.dotsData\n    \t\t\t\t? 1 : settings.dotsEach || settings.items)\n    \t\t};\n    \t};\n\n    \t/**\n    \t * Gets the current page position of the carousel.\n    \t * @protected\n    \t * @returns {Number}\n    \t */\n    \tNavigation.prototype.current = function() {\n    \t\tvar current = this._core.relative(this._core.current());\n    \t\treturn $.grep(this._pages, $.proxy(function(page, index) {\n    \t\t\treturn page.start <= current && page.end >= current;\n    \t\t}, this)).pop();\n    \t};\n\n    \t/**\n    \t * Gets the current succesor/predecessor position.\n    \t * @protected\n    \t * @returns {Number}\n    \t */\n    \tNavigation.prototype.getPosition = function(successor) {\n    \t\tvar position, length,\n    \t\t\tsettings = this._core.settings;\n\n    \t\tif (settings.slideBy == 'page') {\n    \t\t\tposition = $.inArray(this.current(), this._pages);\n    \t\t\tlength = this._pages.length;\n    \t\t\tsuccessor ? ++position : --position;\n    \t\t\tposition = this._pages[((position % length) + length) % length].start;\n    \t\t} else {\n    \t\t\tposition = this._core.relative(this._core.current());\n    \t\t\tlength = this._core.items().length;\n    \t\t\tsuccessor ? position += settings.slideBy : position -= settings.slideBy;\n    \t\t}\n\n    \t\treturn position;\n    \t};\n\n    \t/**\n    \t * Slides to the next item or page.\n    \t * @public\n    \t * @param {Number} [speed=false] - The time in milliseconds for the transition.\n    \t */\n    \tNavigation.prototype.next = function(speed) {\n    \t\t$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\n    \t};\n\n    \t/**\n    \t * Slides to the previous item or page.\n    \t * @public\n    \t * @param {Number} [speed=false] - The time in milliseconds for the transition.\n    \t */\n    \tNavigation.prototype.prev = function(speed) {\n    \t\t$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\n    \t};\n\n    \t/**\n    \t * Slides to the specified item or page.\n    \t * @public\n    \t * @param {Number} position - The position of the item or page.\n    \t * @param {Number} [speed] - The time in milliseconds for the transition.\n    \t * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\n    \t */\n    \tNavigation.prototype.to = function(position, speed, standard) {\n    \t\tvar length;\n\n    \t\tif (!standard && this._pages.length) {\n    \t\t\tlength = this._pages.length;\n    \t\t\t$.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);\n    \t\t} else {\n    \t\t\t$.proxy(this._overrides.to, this._core)(position, speed);\n    \t\t}\n    \t};\n\n    \t$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\n\n    })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n    (function($, window, document, undefined) {\n\n    \t/**\n    \t * Creates the hash plugin.\n    \t * @class The Hash Plugin\n    \t * @param {Owl} carousel - The Owl Carousel\n    \t */\n    \tvar Hash = function(carousel) {\n    \t\t/**\n    \t\t * Reference to the core.\n    \t\t * @protected\n    \t\t * @type {Owl}\n    \t\t */\n    \t\tthis._core = carousel;\n\n    \t\t/**\n    \t\t * Hash index for the items.\n    \t\t * @protected\n    \t\t * @type {Object}\n    \t\t */\n    \t\tthis._hashes = {};\n\n    \t\t/**\n    \t\t * The carousel element.\n    \t\t * @type {jQuery}\n    \t\t */\n    \t\tthis.$element = this._core.$element;\n\n    \t\t/**\n    \t\t * All event handlers.\n    \t\t * @protected\n    \t\t * @type {Object}\n    \t\t */\n    \t\tthis._handlers = {\n    \t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && this._core.settings.startPosition === 'URLHash') {\n    \t\t\t\t\t$(window).trigger('hashchange.owl.navigation');\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'prepared.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace) {\n    \t\t\t\t\tvar hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');\n\n    \t\t\t\t\tif (!hash) {\n    \t\t\t\t\t\treturn;\n    \t\t\t\t\t}\n\n    \t\t\t\t\tthis._hashes[hash] = e.content;\n    \t\t\t\t}\n    \t\t\t}, this),\n    \t\t\t'changed.owl.carousel': $.proxy(function(e) {\n    \t\t\t\tif (e.namespace && e.property.name === 'position') {\n    \t\t\t\t\tvar current = this._core.items(this._core.relative(this._core.current())),\n    \t\t\t\t\t\thash = $.map(this._hashes, function(item, hash) {\n    \t\t\t\t\t\t\treturn item === current ? hash : null;\n    \t\t\t\t\t\t}).join();\n\n    \t\t\t\t\tif (!hash || window.location.hash.slice(1) === hash) {\n    \t\t\t\t\t\treturn;\n    \t\t\t\t\t}\n\n    \t\t\t\t\twindow.location.hash = hash;\n    \t\t\t\t}\n    \t\t\t}, this)\n    \t\t};\n\n    \t\t// set default options\n    \t\tthis._core.options = $.extend({}, Hash.Defaults, this._core.options);\n\n    \t\t// register the event handlers\n    \t\tthis.$element.on(this._handlers);\n\n    \t\t// register event listener for hash navigation\n    \t\t$(window).on('hashchange.owl.navigation', $.proxy(function(e) {\n    \t\t\tvar hash = window.location.hash.substring(1),\n    \t\t\t\titems = this._core.$stage.children(),\n    \t\t\t\tposition = this._hashes[hash] && items.index(this._hashes[hash]);\n\n    \t\t\tif (position === undefined || position === this._core.current()) {\n    \t\t\t\treturn;\n    \t\t\t}\n\n    \t\t\tthis._core.to(this._core.relative(position), false, true);\n    \t\t}, this));\n    \t};\n\n    \t/**\n    \t * Default options.\n    \t * @public\n    \t */\n    \tHash.Defaults = {\n    \t\tURLhashListener: false\n    \t};\n\n    \t/**\n    \t * Destroys the plugin.\n    \t * @public\n    \t */\n    \tHash.prototype.destroy = function() {\n    \t\tvar handler, property;\n\n    \t\t$(window).off('hashchange.owl.navigation');\n\n    \t\tfor (handler in this._handlers) {\n    \t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n    \t\t}\n    \t\tfor (property in Object.getOwnPropertyNames(this)) {\n    \t\t\ttypeof this[property] != 'function' && (this[property] = null);\n    \t\t}\n    \t};\n\n    \t$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\n\n    })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n    (function($, window, document, undefined) {\n\n    \tvar style = $('<support>').get(0).style,\n    \t\tprefixes = 'Webkit Moz O ms'.split(' '),\n    \t\tevents = {\n    \t\t\ttransition: {\n    \t\t\t\tend: {\n    \t\t\t\t\tWebkitTransition: 'webkitTransitionEnd',\n    \t\t\t\t\tMozTransition: 'transitionend',\n    \t\t\t\t\tOTransition: 'oTransitionEnd',\n    \t\t\t\t\ttransition: 'transitionend'\n    \t\t\t\t}\n    \t\t\t},\n    \t\t\tanimation: {\n    \t\t\t\tend: {\n    \t\t\t\t\tWebkitAnimation: 'webkitAnimationEnd',\n    \t\t\t\t\tMozAnimation: 'animationend',\n    \t\t\t\t\tOAnimation: 'oAnimationEnd',\n    \t\t\t\t\tanimation: 'animationend'\n    \t\t\t\t}\n    \t\t\t}\n    \t\t},\n    \t\ttests = {\n    \t\t\tcsstransforms: function() {\n    \t\t\t\treturn !!test('transform');\n    \t\t\t},\n    \t\t\tcsstransforms3d: function() {\n    \t\t\t\treturn !!test('perspective');\n    \t\t\t},\n    \t\t\tcsstransitions: function() {\n    \t\t\t\treturn !!test('transition');\n    \t\t\t},\n    \t\t\tcssanimations: function() {\n    \t\t\t\treturn !!test('animation');\n    \t\t\t}\n    \t\t};\n\n    \tfunction test(property, prefixed) {\n    \t\tvar result = false,\n    \t\t\tupper = property.charAt(0).toUpperCase() + property.slice(1);\n\n    \t\t$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {\n    \t\t\tif (style[property] !== undefined) {\n    \t\t\t\tresult = prefixed ? property : true;\n    \t\t\t\treturn false;\n    \t\t\t}\n    \t\t});\n\n    \t\treturn result;\n    \t}\n\n    \tfunction prefixed(property) {\n    \t\treturn test(property, true);\n    \t}\n\n    \tif (tests.csstransitions()) {\n    \t\t/* jshint -W053 */\n    \t\t$.support.transition = new String(prefixed('transition'));\n    \t\t$.support.transition.end = events.transition.end[ $.support.transition ];\n    \t}\n\n    \tif (tests.cssanimations()) {\n    \t\t/* jshint -W053 */\n    \t\t$.support.animation = new String(prefixed('animation'));\n    \t\t$.support.animation.end = events.animation.end[ $.support.animation ];\n    \t}\n\n    \tif (tests.csstransforms()) {\n    \t\t/* jshint -W053 */\n    \t\t$.support.transform = new String(prefixed('transform'));\n    \t\t$.support.transform3d = tests.csstransforms3d();\n    \t}\n\n    })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n    var $ = __webpack_provided_window_dot_jQuery;\r\n    var ReactOwlCarousel = /** @class */ (function (_super) {\r\n        __extends(ReactOwlCarousel, _super);\r\n        function ReactOwlCarousel(props) {\r\n            var _this = _super.call(this, props) || this;\r\n            _this.containerRef = function (inst) {\r\n                _this.container = inst;\r\n            };\r\n            var _a = filterOptions(_this.props), options = _a[0], propsWithoutOptions = _a[1];\r\n            _this.options = options;\r\n            _this.propsWithoutOptions = propsWithoutOptions;\r\n            return _this;\r\n        }\r\n        ReactOwlCarousel.prototype.componentDidMount = function () {\r\n            this.$ele = $(this.container);\r\n            this.create();\r\n        };\r\n        ReactOwlCarousel.prototype.UNSAFE_componentWillReceiveProps = function () {\r\n            this.destory();\r\n        };\r\n        ReactOwlCarousel.prototype.componentDidUpdate = function () {\r\n            var _a = filterOptions(this.props), options = _a[0], propsWithoutOptions = _a[1];\r\n            this.options = options;\r\n            this.propsWithoutOptions = propsWithoutOptions;\r\n            this.create();\r\n        };\r\n        ReactOwlCarousel.prototype.next = function (speed) {\r\n            if (!this.$ele)\r\n                throw new Error('OwlCarousel is not created');\r\n            if (typeof speed === 'number') {\r\n                this.$ele.trigger('next.owl.carousel', [speed]);\r\n            }\r\n            else {\r\n                this.$ele.trigger('next.owl.carousel', speed);\r\n            }\r\n        };\r\n        ReactOwlCarousel.prototype.prev = function (speed) {\r\n            if (!this.$ele)\r\n                throw new Error('OwlCarousel is not created');\r\n            if (typeof speed === 'number') {\r\n                this.$ele.trigger('prev.owl.carousel', [speed]);\r\n            }\r\n            else {\r\n                this.$ele.trigger('prev.owl.carousel', speed);\r\n            }\r\n        };\r\n        ReactOwlCarousel.prototype.to = function (position, speed) {\r\n            if (!this.$ele)\r\n                throw new Error('OwlCarousel is not created');\r\n            if (typeof position === 'number' && typeof speed === 'number') {\r\n                this.$ele.trigger('to.owl.carousel', [position, speed]);\r\n            }\r\n            else {\r\n                this.$ele.trigger('to.owl.carousel');\r\n            }\r\n        };\r\n        ReactOwlCarousel.prototype.create = function (options) {\r\n            if (!this.$ele)\r\n                throw new Error('OwlCarousel is not created');\r\n            this.$ele.owlCarousel(options || this.options);\r\n        };\r\n        ReactOwlCarousel.prototype.destory = function () {\r\n            if (!this.$ele)\r\n                throw new Error('OwlCarousel is not created');\r\n            this.$ele.trigger('destroy.owl.carousel');\r\n        };\r\n        ReactOwlCarousel.prototype.play = function (timeout, speed) {\r\n            if (!this.$ele)\r\n                throw new Error('OwlCarousel is not created');\r\n            if (typeof timeout === 'number' && typeof speed === 'number') {\r\n                this.$ele.trigger('play.owl.autoplay', [timeout, speed]);\r\n            }\r\n            else {\r\n                this.$ele.trigger('play.owl.autoplay');\r\n            }\r\n        };\r\n        ReactOwlCarousel.prototype.stop = function () {\r\n            if (!this.$ele)\r\n                throw new Error('OwlCarousel is not created');\r\n            this.$ele.trigger('stop.owl.autoplay');\r\n        };\r\n        ReactOwlCarousel.prototype.render = function () {\r\n            var _a = this.propsWithoutOptions, className = _a.className, props = __rest(_a, [\"className\"]);\r\n            return (React__default.createElement(\"div\", __assign({ className: \"owl-carousel \" + className, ref: this.containerRef }, props)));\r\n        };\r\n        return ReactOwlCarousel;\r\n    }(React.Component));\r\n    var OPTIONS = new Set([\r\n        'items',\r\n        'margin',\r\n        'loop',\r\n        'center',\r\n        'mouseDrag',\r\n        'touchDrag',\r\n        'pullDrag',\r\n        'freeDrag',\r\n        'stagePadding',\r\n        'merge',\r\n        'mergeFit',\r\n        'autoWidth',\r\n        'startPosition',\r\n        'URLhashListener',\r\n        'nav',\r\n        'rewind',\r\n        'navText',\r\n        'navElement',\r\n        'slideBy',\r\n        'dots',\r\n        'dotsEach',\r\n        'dotData',\r\n        'lazyLoad',\r\n        'lazyContent',\r\n        'autoplay',\r\n        'autoplayTimeout',\r\n        'autoplayHoverPause',\r\n        'smartSpeed',\r\n        'fluidSpeed',\r\n        'autoplaySpeed',\r\n        'navSpeed',\r\n        'dotsSpeed',\r\n        'dragEndSpeed',\r\n        'callbacks',\r\n        'responsive',\r\n        'responsiveRefreshRate',\r\n        'responsiveBaseElement',\r\n        'video',\r\n        'videoHeight',\r\n        'videoWidth',\r\n        'animateOut',\r\n        'animateIn',\r\n        'fallbackEasing',\r\n        'info',\r\n        'nestedItemSelector',\r\n        'itemElement',\r\n        'stageElement',\r\n        'navContainer',\r\n        'dotsContainer',\r\n        // 'CLASSES'\r\n        'refreshClass',\r\n        'loadingClass',\r\n        'loadedClass',\r\n        'rtlClass',\r\n        'dragClass',\r\n        'grabClass',\r\n        'stageClass',\r\n        'stageOuterClass',\r\n        'navContainerClass',\r\n        'navClass',\r\n        'controlsClass',\r\n        'dotClass',\r\n        'dotsClass',\r\n        'autoHeightClass',\r\n        'responsiveClass',\r\n        // 'EVENTS'\r\n        'onInitialize',\r\n        'onInitialized',\r\n        'onResize',\r\n        'onResized',\r\n        'onRefresh',\r\n        'onRefreshed',\r\n        'onDrag',\r\n        'onDragged',\r\n        'onTranslate',\r\n        'onTranslated',\r\n        'onChange',\r\n        'onChanged',\r\n        'onLoadLazy',\r\n        'onLoadedLazy',\r\n        'onStopVideo',\r\n        'onPlayVideo',\r\n    ]);\r\n    function filterOptions(item) {\r\n        var options = {};\r\n        var propsWithoutOptions = {};\r\n        Object.keys(item).forEach(function (key) {\r\n            if (OPTIONS.has(key)) {\r\n                options[key] = item[key];\r\n            }\r\n            else {\r\n                propsWithoutOptions[key] = item[key];\r\n            }\r\n        });\r\n        return [options, propsWithoutOptions];\r\n    }\n\n    return ReactOwlCarousel;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtb3dsLWNhcm91c2VsL3VtZC9Pd2xDYXJvdXNlbC5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0EsSUFBSSxLQUE0RCw0QkFBNEIsbUJBQU8sQ0FBQyw0Q0FBTztBQUMzRyxJQUFJLENBQ2lEO0FBQ3JELENBQUMsMkJBQTJCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGNBQWM7QUFDL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEMsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELE9BQU87QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7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LGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUssa0JBQWtCLG9DQUFhO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPLEVBQUU7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZ0VBQWdFO0FBQ25JO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1vd2wtY2Fyb3VzZWwvdW1kL093bENhcm91c2VsLmpzP2U3MmYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgncmVhY3QnKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ3JlYWN0J10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsLlJlYWN0T3dsQ2Fyb3VzZWwgPSBmYWN0b3J5KGdsb2JhbC5SZWFjdCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBSZWFjdF9fZGVmYXVsdCA9ICdkZWZhdWx0JyBpbiBSZWFjdCA/IFJlYWN0WydkZWZhdWx0J10gOiBSZWFjdDtcblxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxuICAgIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbiAgICBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuICAgIFRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICAgIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuICAgIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbiAgICBNRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuICAgIFNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG4gICAgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuICAgIC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG4gICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3dsIENhcm91c2VsIHYyLjMuNFxuICAgICAqIENvcHlyaWdodCAyMDEzLTIwMTggRGF2aWQgRGV1dHNjaFxuICAgICAqIExpY2Vuc2VkIHVuZGVyOiBTRUUgTElDRU5TRSBJTiBodHRwczovL2dpdGh1Yi5jb20vT3dsQ2Fyb3VzZWwyL093bENhcm91c2VsMi9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICAgICovXG4gICAgKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXG4gICAgXHQvKipcbiAgICBcdCAqIENyZWF0ZXMgYSBjYXJvdXNlbC5cbiAgICBcdCAqIEBjbGFzcyBUaGUgT3dsIENhcm91c2VsLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudHxqUXVlcnl9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBjcmVhdGUgdGhlIGNhcm91c2VsIGZvci5cbiAgICBcdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9uc1xuICAgIFx0ICovXG4gICAgXHRmdW5jdGlvbiBPd2woZWxlbWVudCwgb3B0aW9ucykge1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBDdXJyZW50IHNldHRpbmdzIGZvciB0aGUgY2Fyb3VzZWwuXG4gICAgXHRcdCAqIEBwdWJsaWNcbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuc2V0dGluZ3MgPSBudWxsO1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBDdXJyZW50IG9wdGlvbnMgc2V0IGJ5IHRoZSBjYWxsZXIgaW5jbHVkaW5nIGRlZmF1bHRzLlxuICAgIFx0XHQgKiBAcHVibGljXG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgT3dsLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogUGx1Z2luIGVsZW1lbnQuXG4gICAgXHRcdCAqIEBwdWJsaWNcbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBQcm94aWVkIGV2ZW50IGhhbmRsZXJzLlxuICAgIFx0XHQgKiBAcHJvdGVjdGVkXG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl9oYW5kbGVycyA9IHt9O1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBSZWZlcmVuY2VzIHRvIHRoZSBydW5uaW5nIHBsdWdpbnMgb2YgdGhpcyBjYXJvdXNlbC5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fcGx1Z2lucyA9IHt9O1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBDdXJyZW50bHkgc3VwcHJlc3NlZCBldmVudHMgdG8gcHJldmVudCB0aGVtIGZyb20gYmVpbmcgcmV0cmlnZ2VyZWQuXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX3N1cHJlc3MgPSB7fTtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogQWJzb2x1dGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fY3VycmVudCA9IG51bGw7XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIEFuaW1hdGlvbiBzcGVlZCBpbiBtaWxsaXNlY29uZHMuXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX3NwZWVkID0gbnVsbDtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogQ29vcmRpbmF0ZXMgb2YgYWxsIGl0ZW1zIGluIHBpeGVsLlxuICAgIFx0XHQgKiBAdG9kbyBUaGUgbmFtZSBvZiB0aGlzIG1lbWJlciBpcyBtaXNzbGVhZGluZy5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fY29vcmRpbmF0ZXMgPSBbXTtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogQ3VycmVudCBicmVha3BvaW50LlxuICAgIFx0XHQgKiBAdG9kbyBSZWFsIG1lZGlhIHF1ZXJpZXMgd291bGQgYmUgbmljZS5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fYnJlYWtwb2ludCA9IG51bGw7XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIEN1cnJlbnQgd2lkdGggb2YgdGhlIHBsdWdpbiBlbGVtZW50LlxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fd2lkdGggPSBudWxsO1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBBbGwgcmVhbCBpdGVtcy5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5faXRlbXMgPSBbXTtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogQWxsIGNsb25lZCBpdGVtcy5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fY2xvbmVzID0gW107XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIE1lcmdlIHZhbHVlcyBvZiBhbGwgaXRlbXMuXG4gICAgXHRcdCAqIEB0b2RvIE1heWJlIHRoaXMgY291bGQgYmUgcGFydCBvZiBhIHBsdWdpbi5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fbWVyZ2VycyA9IFtdO1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBXaWR0aHMgb2YgYWxsIGl0ZW1zLlxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fd2lkdGhzID0gW107XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIEludmFsaWRhdGVkIHBhcnRzIHdpdGhpbiB0aGUgdXBkYXRlIHByb2Nlc3MuXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX2ludmFsaWRhdGVkID0ge307XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIE9yZGVyZWQgbGlzdCBvZiB3b3JrZXJzIGZvciB0aGUgdXBkYXRlIHByb2Nlc3MuXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX3BpcGUgPSBbXTtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogQ3VycmVudCBzdGF0ZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGRyYWcgb3BlcmF0aW9uLlxuICAgIFx0XHQgKiBAdG9kbyAjMjYxXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX2RyYWcgPSB7XG4gICAgXHRcdFx0dGltZTogbnVsbCxcbiAgICBcdFx0XHR0YXJnZXQ6IG51bGwsXG4gICAgXHRcdFx0cG9pbnRlcjogbnVsbCxcbiAgICBcdFx0XHRzdGFnZToge1xuICAgIFx0XHRcdFx0c3RhcnQ6IG51bGwsXG4gICAgXHRcdFx0XHRjdXJyZW50OiBudWxsXG4gICAgXHRcdFx0fSxcbiAgICBcdFx0XHRkaXJlY3Rpb246IG51bGxcbiAgICBcdFx0fTtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogQ3VycmVudCBzdGF0ZSBpbmZvcm1hdGlvbiBhbmQgdGhlaXIgdGFncy5cbiAgICBcdFx0ICogQHR5cGUge09iamVjdH1cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fc3RhdGVzID0ge1xuICAgIFx0XHRcdGN1cnJlbnQ6IHt9LFxuICAgIFx0XHRcdHRhZ3M6IHtcbiAgICBcdFx0XHRcdCdpbml0aWFsaXppbmcnOiBbICdidXN5JyBdLFxuICAgIFx0XHRcdFx0J2FuaW1hdGluZyc6IFsgJ2J1c3knIF0sXG4gICAgXHRcdFx0XHQnZHJhZ2dpbmcnOiBbICdpbnRlcmFjdGluZycgXVxuICAgIFx0XHRcdH1cbiAgICBcdFx0fTtcblxuICAgIFx0XHQkLmVhY2goWyAnb25SZXNpemUnLCAnb25UaHJvdHRsZWRSZXNpemUnIF0sICQucHJveHkoZnVuY3Rpb24oaSwgaGFuZGxlcikge1xuICAgIFx0XHRcdHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdID0gJC5wcm94eSh0aGlzW2hhbmRsZXJdLCB0aGlzKTtcbiAgICBcdFx0fSwgdGhpcykpO1xuXG4gICAgXHRcdCQuZWFjaChPd2wuUGx1Z2lucywgJC5wcm94eShmdW5jdGlvbihrZXksIHBsdWdpbikge1xuICAgIFx0XHRcdHRoaXMuX3BsdWdpbnNba2V5LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpXVxuICAgIFx0XHRcdFx0PSBuZXcgcGx1Z2luKHRoaXMpO1xuICAgIFx0XHR9LCB0aGlzKSk7XG5cbiAgICBcdFx0JC5lYWNoKE93bC5Xb3JrZXJzLCAkLnByb3h5KGZ1bmN0aW9uKHByaW9yaXR5LCB3b3JrZXIpIHtcbiAgICBcdFx0XHR0aGlzLl9waXBlLnB1c2goe1xuICAgIFx0XHRcdFx0J2ZpbHRlcic6IHdvcmtlci5maWx0ZXIsXG4gICAgXHRcdFx0XHQncnVuJzogJC5wcm94eSh3b3JrZXIucnVuLCB0aGlzKVxuICAgIFx0XHRcdH0pO1xuICAgIFx0XHR9LCB0aGlzKSk7XG5cbiAgICBcdFx0dGhpcy5zZXR1cCgpO1xuICAgIFx0XHR0aGlzLmluaXRpYWxpemUoKTtcbiAgICBcdH1cblxuICAgIFx0LyoqXG4gICAgXHQgKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBjYXJvdXNlbC5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqL1xuICAgIFx0T3dsLkRlZmF1bHRzID0ge1xuICAgIFx0XHRpdGVtczogMyxcbiAgICBcdFx0bG9vcDogZmFsc2UsXG4gICAgXHRcdGNlbnRlcjogZmFsc2UsXG4gICAgXHRcdHJld2luZDogZmFsc2UsXG4gICAgXHRcdGNoZWNrVmlzaWJpbGl0eTogdHJ1ZSxcblxuICAgIFx0XHRtb3VzZURyYWc6IHRydWUsXG4gICAgXHRcdHRvdWNoRHJhZzogdHJ1ZSxcbiAgICBcdFx0cHVsbERyYWc6IHRydWUsXG4gICAgXHRcdGZyZWVEcmFnOiBmYWxzZSxcblxuICAgIFx0XHRtYXJnaW46IDAsXG4gICAgXHRcdHN0YWdlUGFkZGluZzogMCxcblxuICAgIFx0XHRtZXJnZTogZmFsc2UsXG4gICAgXHRcdG1lcmdlRml0OiB0cnVlLFxuICAgIFx0XHRhdXRvV2lkdGg6IGZhbHNlLFxuXG4gICAgXHRcdHN0YXJ0UG9zaXRpb246IDAsXG4gICAgXHRcdHJ0bDogZmFsc2UsXG5cbiAgICBcdFx0c21hcnRTcGVlZDogMjUwLFxuICAgIFx0XHRmbHVpZFNwZWVkOiBmYWxzZSxcbiAgICBcdFx0ZHJhZ0VuZFNwZWVkOiBmYWxzZSxcblxuICAgIFx0XHRyZXNwb25zaXZlOiB7fSxcbiAgICBcdFx0cmVzcG9uc2l2ZVJlZnJlc2hSYXRlOiAyMDAsXG4gICAgXHRcdHJlc3BvbnNpdmVCYXNlRWxlbWVudDogd2luZG93LFxuXG4gICAgXHRcdGZhbGxiYWNrRWFzaW5nOiAnc3dpbmcnLFxuICAgIFx0XHRzbGlkZVRyYW5zaXRpb246ICcnLFxuXG4gICAgXHRcdGluZm86IGZhbHNlLFxuXG4gICAgXHRcdG5lc3RlZEl0ZW1TZWxlY3RvcjogZmFsc2UsXG4gICAgXHRcdGl0ZW1FbGVtZW50OiAnZGl2JyxcbiAgICBcdFx0c3RhZ2VFbGVtZW50OiAnZGl2JyxcblxuICAgIFx0XHRyZWZyZXNoQ2xhc3M6ICdvd2wtcmVmcmVzaCcsXG4gICAgXHRcdGxvYWRlZENsYXNzOiAnb3dsLWxvYWRlZCcsXG4gICAgXHRcdGxvYWRpbmdDbGFzczogJ293bC1sb2FkaW5nJyxcbiAgICBcdFx0cnRsQ2xhc3M6ICdvd2wtcnRsJyxcbiAgICBcdFx0cmVzcG9uc2l2ZUNsYXNzOiAnb3dsLXJlc3BvbnNpdmUnLFxuICAgIFx0XHRkcmFnQ2xhc3M6ICdvd2wtZHJhZycsXG4gICAgXHRcdGl0ZW1DbGFzczogJ293bC1pdGVtJyxcbiAgICBcdFx0c3RhZ2VDbGFzczogJ293bC1zdGFnZScsXG4gICAgXHRcdHN0YWdlT3V0ZXJDbGFzczogJ293bC1zdGFnZS1vdXRlcicsXG4gICAgXHRcdGdyYWJDbGFzczogJ293bC1ncmFiJ1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBFbnVtZXJhdGlvbiBmb3Igd2lkdGguXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKiBAcmVhZG9ubHlcbiAgICBcdCAqIEBlbnVtIHtTdHJpbmd9XG4gICAgXHQgKi9cbiAgICBcdE93bC5XaWR0aCA9IHtcbiAgICBcdFx0RGVmYXVsdDogJ2RlZmF1bHQnLFxuICAgIFx0XHRJbm5lcjogJ2lubmVyJyxcbiAgICBcdFx0T3V0ZXI6ICdvdXRlcidcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogRW51bWVyYXRpb24gZm9yIHR5cGVzLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICogQHJlYWRvbmx5XG4gICAgXHQgKiBAZW51bSB7U3RyaW5nfVxuICAgIFx0ICovXG4gICAgXHRPd2wuVHlwZSA9IHtcbiAgICBcdFx0RXZlbnQ6ICdldmVudCcsXG4gICAgXHRcdFN0YXRlOiAnc3RhdGUnXG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIENvbnRhaW5zIGFsbCByZWdpc3RlcmVkIHBsdWdpbnMuXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKi9cbiAgICBcdE93bC5QbHVnaW5zID0ge307XG5cbiAgICBcdC8qKlxuICAgIFx0ICogTGlzdCBvZiB3b3JrZXJzIGludm9sdmVkIGluIHRoZSB1cGRhdGUgcHJvY2Vzcy5cbiAgICBcdCAqL1xuICAgIFx0T3dsLldvcmtlcnMgPSBbIHtcbiAgICBcdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdzZXR0aW5ncycgXSxcbiAgICBcdFx0cnVuOiBmdW5jdGlvbigpIHtcbiAgICBcdFx0XHR0aGlzLl93aWR0aCA9IHRoaXMuJGVsZW1lbnQud2lkdGgoKTtcbiAgICBcdFx0fVxuICAgIFx0fSwge1xuICAgIFx0XHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxuICAgIFx0XHRydW46IGZ1bmN0aW9uKGNhY2hlKSB7XG4gICAgXHRcdFx0Y2FjaGUuY3VycmVudCA9IHRoaXMuX2l0ZW1zICYmIHRoaXMuX2l0ZW1zW3RoaXMucmVsYXRpdmUodGhpcy5fY3VycmVudCldO1xuICAgIFx0XHR9XG4gICAgXHR9LCB7XG4gICAgXHRcdGZpbHRlcjogWyAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXG4gICAgXHRcdHJ1bjogZnVuY3Rpb24oKSB7XG4gICAgXHRcdFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oJy5jbG9uZWQnKS5yZW1vdmUoKTtcbiAgICBcdFx0fVxuICAgIFx0fSwge1xuICAgIFx0XHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxuICAgIFx0XHRydW46IGZ1bmN0aW9uKGNhY2hlKSB7XG4gICAgXHRcdFx0dmFyIG1hcmdpbiA9IHRoaXMuc2V0dGluZ3MubWFyZ2luIHx8ICcnLFxuICAgIFx0XHRcdFx0Z3JpZCA9ICF0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCxcbiAgICBcdFx0XHRcdHJ0bCA9IHRoaXMuc2V0dGluZ3MucnRsLFxuICAgIFx0XHRcdFx0Y3NzID0ge1xuICAgIFx0XHRcdFx0XHQnd2lkdGgnOiAnYXV0bycsXG4gICAgXHRcdFx0XHRcdCdtYXJnaW4tbGVmdCc6IHJ0bCA/IG1hcmdpbiA6ICcnLFxuICAgIFx0XHRcdFx0XHQnbWFyZ2luLXJpZ2h0JzogcnRsID8gJycgOiBtYXJnaW5cbiAgICBcdFx0XHRcdH07XG5cbiAgICBcdFx0XHQhZ3JpZCAmJiB0aGlzLiRzdGFnZS5jaGlsZHJlbigpLmNzcyhjc3MpO1xuXG4gICAgXHRcdFx0Y2FjaGUuY3NzID0gY3NzO1xuICAgIFx0XHR9XG4gICAgXHR9LCB7XG4gICAgXHRcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXG4gICAgXHRcdHJ1bjogZnVuY3Rpb24oY2FjaGUpIHtcbiAgICBcdFx0XHR2YXIgd2lkdGggPSAodGhpcy53aWR0aCgpIC8gdGhpcy5zZXR0aW5ncy5pdGVtcykudG9GaXhlZCgzKSAtIHRoaXMuc2V0dGluZ3MubWFyZ2luLFxuICAgIFx0XHRcdFx0bWVyZ2UgPSBudWxsLFxuICAgIFx0XHRcdFx0aXRlcmF0b3IgPSB0aGlzLl9pdGVtcy5sZW5ndGgsXG4gICAgXHRcdFx0XHRncmlkID0gIXRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoLFxuICAgIFx0XHRcdFx0d2lkdGhzID0gW107XG5cbiAgICBcdFx0XHRjYWNoZS5pdGVtcyA9IHtcbiAgICBcdFx0XHRcdG1lcmdlOiBmYWxzZSxcbiAgICBcdFx0XHRcdHdpZHRoOiB3aWR0aFxuICAgIFx0XHRcdH07XG5cbiAgICBcdFx0XHR3aGlsZSAoaXRlcmF0b3ItLSkge1xuICAgIFx0XHRcdFx0bWVyZ2UgPSB0aGlzLl9tZXJnZXJzW2l0ZXJhdG9yXTtcbiAgICBcdFx0XHRcdG1lcmdlID0gdGhpcy5zZXR0aW5ncy5tZXJnZUZpdCAmJiBNYXRoLm1pbihtZXJnZSwgdGhpcy5zZXR0aW5ncy5pdGVtcykgfHwgbWVyZ2U7XG5cbiAgICBcdFx0XHRcdGNhY2hlLml0ZW1zLm1lcmdlID0gbWVyZ2UgPiAxIHx8IGNhY2hlLml0ZW1zLm1lcmdlO1xuXG4gICAgXHRcdFx0XHR3aWR0aHNbaXRlcmF0b3JdID0gIWdyaWQgPyB0aGlzLl9pdGVtc1tpdGVyYXRvcl0ud2lkdGgoKSA6IHdpZHRoICogbWVyZ2U7XG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5fd2lkdGhzID0gd2lkdGhzO1xuICAgIFx0XHR9XG4gICAgXHR9LCB7XG4gICAgXHRcdGZpbHRlcjogWyAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXG4gICAgXHRcdHJ1bjogZnVuY3Rpb24oKSB7XG4gICAgXHRcdFx0dmFyIGNsb25lcyA9IFtdLFxuICAgIFx0XHRcdFx0aXRlbXMgPSB0aGlzLl9pdGVtcyxcbiAgICBcdFx0XHRcdHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcbiAgICBcdFx0XHRcdC8vIFRPRE86IFNob3VsZCBiZSBjb21wdXRlZCBmcm9tIG51bWJlciBvZiBtaW4gd2lkdGggaXRlbXMgaW4gc3RhZ2VcbiAgICBcdFx0XHRcdHZpZXcgPSBNYXRoLm1heChzZXR0aW5ncy5pdGVtcyAqIDIsIDQpLFxuICAgIFx0XHRcdFx0c2l6ZSA9IE1hdGguY2VpbChpdGVtcy5sZW5ndGggLyAyKSAqIDIsXG4gICAgXHRcdFx0XHRyZXBlYXQgPSBzZXR0aW5ncy5sb29wICYmIGl0ZW1zLmxlbmd0aCA/IHNldHRpbmdzLnJld2luZCA/IHZpZXcgOiBNYXRoLm1heCh2aWV3LCBzaXplKSA6IDAsXG4gICAgXHRcdFx0XHRhcHBlbmQgPSAnJyxcbiAgICBcdFx0XHRcdHByZXBlbmQgPSAnJztcblxuICAgIFx0XHRcdHJlcGVhdCAvPSAyO1xuXG4gICAgXHRcdFx0d2hpbGUgKHJlcGVhdCA+IDApIHtcbiAgICBcdFx0XHRcdC8vIFN3aXRjaCB0byBvbmx5IHVzaW5nIGFwcGVuZGVkIGNsb25lc1xuICAgIFx0XHRcdFx0Y2xvbmVzLnB1c2godGhpcy5ub3JtYWxpemUoY2xvbmVzLmxlbmd0aCAvIDIsIHRydWUpKTtcbiAgICBcdFx0XHRcdGFwcGVuZCA9IGFwcGVuZCArIGl0ZW1zW2Nsb25lc1tjbG9uZXMubGVuZ3RoIC0gMV1dWzBdLm91dGVySFRNTDtcbiAgICBcdFx0XHRcdGNsb25lcy5wdXNoKHRoaXMubm9ybWFsaXplKGl0ZW1zLmxlbmd0aCAtIDEgLSAoY2xvbmVzLmxlbmd0aCAtIDEpIC8gMiwgdHJ1ZSkpO1xuICAgIFx0XHRcdFx0cHJlcGVuZCA9IGl0ZW1zW2Nsb25lc1tjbG9uZXMubGVuZ3RoIC0gMV1dWzBdLm91dGVySFRNTCArIHByZXBlbmQ7XG4gICAgXHRcdFx0XHRyZXBlYXQgLT0gMTtcbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLl9jbG9uZXMgPSBjbG9uZXM7XG5cbiAgICBcdFx0XHQkKGFwcGVuZCkuYWRkQ2xhc3MoJ2Nsb25lZCcpLmFwcGVuZFRvKHRoaXMuJHN0YWdlKTtcbiAgICBcdFx0XHQkKHByZXBlbmQpLmFkZENsYXNzKCdjbG9uZWQnKS5wcmVwZW5kVG8odGhpcy4kc3RhZ2UpO1xuICAgIFx0XHR9XG4gICAgXHR9LCB7XG4gICAgXHRcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXG4gICAgXHRcdHJ1bjogZnVuY3Rpb24oKSB7XG4gICAgXHRcdFx0dmFyIHJ0bCA9IHRoaXMuc2V0dGluZ3MucnRsID8gMSA6IC0xLFxuICAgIFx0XHRcdFx0c2l6ZSA9IHRoaXMuX2Nsb25lcy5sZW5ndGggKyB0aGlzLl9pdGVtcy5sZW5ndGgsXG4gICAgXHRcdFx0XHRpdGVyYXRvciA9IC0xLFxuICAgIFx0XHRcdFx0cHJldmlvdXMgPSAwLFxuICAgIFx0XHRcdFx0Y3VycmVudCA9IDAsXG4gICAgXHRcdFx0XHRjb29yZGluYXRlcyA9IFtdO1xuXG4gICAgXHRcdFx0d2hpbGUgKCsraXRlcmF0b3IgPCBzaXplKSB7XG4gICAgXHRcdFx0XHRwcmV2aW91cyA9IGNvb3JkaW5hdGVzW2l0ZXJhdG9yIC0gMV0gfHwgMDtcbiAgICBcdFx0XHRcdGN1cnJlbnQgPSB0aGlzLl93aWR0aHNbdGhpcy5yZWxhdGl2ZShpdGVyYXRvcildICsgdGhpcy5zZXR0aW5ncy5tYXJnaW47XG4gICAgXHRcdFx0XHRjb29yZGluYXRlcy5wdXNoKHByZXZpb3VzICsgY3VycmVudCAqIHJ0bCk7XG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5fY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcbiAgICBcdFx0fVxuICAgIFx0fSwge1xuICAgIFx0XHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxuICAgIFx0XHRydW46IGZ1bmN0aW9uKCkge1xuICAgIFx0XHRcdHZhciBwYWRkaW5nID0gdGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcsXG4gICAgXHRcdFx0XHRjb29yZGluYXRlcyA9IHRoaXMuX2Nvb3JkaW5hdGVzLFxuICAgIFx0XHRcdFx0Y3NzID0ge1xuICAgIFx0XHRcdFx0XHQnd2lkdGgnOiBNYXRoLmNlaWwoTWF0aC5hYnMoY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV0pKSArIHBhZGRpbmcgKiAyLFxuICAgIFx0XHRcdFx0XHQncGFkZGluZy1sZWZ0JzogcGFkZGluZyB8fCAnJyxcbiAgICBcdFx0XHRcdFx0J3BhZGRpbmctcmlnaHQnOiBwYWRkaW5nIHx8ICcnXG4gICAgXHRcdFx0XHR9O1xuXG4gICAgXHRcdFx0dGhpcy4kc3RhZ2UuY3NzKGNzcyk7XG4gICAgXHRcdH1cbiAgICBcdH0sIHtcbiAgICBcdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcbiAgICBcdFx0cnVuOiBmdW5jdGlvbihjYWNoZSkge1xuICAgIFx0XHRcdHZhciBpdGVyYXRvciA9IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICBcdFx0XHRcdGdyaWQgPSAhdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsXG4gICAgXHRcdFx0XHRpdGVtcyA9IHRoaXMuJHN0YWdlLmNoaWxkcmVuKCk7XG5cbiAgICBcdFx0XHRpZiAoZ3JpZCAmJiBjYWNoZS5pdGVtcy5tZXJnZSkge1xuICAgIFx0XHRcdFx0d2hpbGUgKGl0ZXJhdG9yLS0pIHtcbiAgICBcdFx0XHRcdFx0Y2FjaGUuY3NzLndpZHRoID0gdGhpcy5fd2lkdGhzW3RoaXMucmVsYXRpdmUoaXRlcmF0b3IpXTtcbiAgICBcdFx0XHRcdFx0aXRlbXMuZXEoaXRlcmF0b3IpLmNzcyhjYWNoZS5jc3MpO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0gZWxzZSBpZiAoZ3JpZCkge1xuICAgIFx0XHRcdFx0Y2FjaGUuY3NzLndpZHRoID0gY2FjaGUuaXRlbXMud2lkdGg7XG4gICAgXHRcdFx0XHRpdGVtcy5jc3MoY2FjaGUuY3NzKTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cbiAgICBcdH0sIHtcbiAgICBcdFx0ZmlsdGVyOiBbICdpdGVtcycgXSxcbiAgICBcdFx0cnVuOiBmdW5jdGlvbigpIHtcbiAgICBcdFx0XHR0aGlzLl9jb29yZGluYXRlcy5sZW5ndGggPCAxICYmIHRoaXMuJHN0YWdlLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG4gICAgXHRcdH1cbiAgICBcdH0sIHtcbiAgICBcdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcbiAgICBcdFx0cnVuOiBmdW5jdGlvbihjYWNoZSkge1xuICAgIFx0XHRcdGNhY2hlLmN1cnJlbnQgPSBjYWNoZS5jdXJyZW50ID8gdGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS5pbmRleChjYWNoZS5jdXJyZW50KSA6IDA7XG4gICAgXHRcdFx0Y2FjaGUuY3VycmVudCA9IE1hdGgubWF4KHRoaXMubWluaW11bSgpLCBNYXRoLm1pbih0aGlzLm1heGltdW0oKSwgY2FjaGUuY3VycmVudCkpO1xuICAgIFx0XHRcdHRoaXMucmVzZXQoY2FjaGUuY3VycmVudCk7XG4gICAgXHRcdH1cbiAgICBcdH0sIHtcbiAgICBcdFx0ZmlsdGVyOiBbICdwb3NpdGlvbicgXSxcbiAgICBcdFx0cnVuOiBmdW5jdGlvbigpIHtcbiAgICBcdFx0XHR0aGlzLmFuaW1hdGUodGhpcy5jb29yZGluYXRlcyh0aGlzLl9jdXJyZW50KSk7XG4gICAgXHRcdH1cbiAgICBcdH0sIHtcbiAgICBcdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdwb3NpdGlvbicsICdpdGVtcycsICdzZXR0aW5ncycgXSxcbiAgICBcdFx0cnVuOiBmdW5jdGlvbigpIHtcbiAgICBcdFx0XHR2YXIgcnRsID0gdGhpcy5zZXR0aW5ncy5ydGwgPyAxIDogLTEsXG4gICAgXHRcdFx0XHRwYWRkaW5nID0gdGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcgKiAyLFxuICAgIFx0XHRcdFx0YmVnaW4gPSB0aGlzLmNvb3JkaW5hdGVzKHRoaXMuY3VycmVudCgpKSArIHBhZGRpbmcsXG4gICAgXHRcdFx0XHRlbmQgPSBiZWdpbiArIHRoaXMud2lkdGgoKSAqIHJ0bCxcbiAgICBcdFx0XHRcdGlubmVyLCBvdXRlciwgbWF0Y2hlcyA9IFtdLCBpLCBuO1xuXG4gICAgXHRcdFx0Zm9yIChpID0gMCwgbiA9IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgIFx0XHRcdFx0aW5uZXIgPSB0aGlzLl9jb29yZGluYXRlc1tpIC0gMV0gfHwgMDtcbiAgICBcdFx0XHRcdG91dGVyID0gTWF0aC5hYnModGhpcy5fY29vcmRpbmF0ZXNbaV0pICsgcGFkZGluZyAqIHJ0bDtcblxuICAgIFx0XHRcdFx0aWYgKCh0aGlzLm9wKGlubmVyLCAnPD0nLCBiZWdpbikgJiYgKHRoaXMub3AoaW5uZXIsICc+JywgZW5kKSkpXG4gICAgXHRcdFx0XHRcdHx8ICh0aGlzLm9wKG91dGVyLCAnPCcsIGJlZ2luKSAmJiB0aGlzLm9wKG91dGVyLCAnPicsIGVuZCkpKSB7XG4gICAgXHRcdFx0XHRcdG1hdGNoZXMucHVzaChpKTtcbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLiRzdGFnZS5jaGlsZHJlbignLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICBcdFx0XHR0aGlzLiRzdGFnZS5jaGlsZHJlbignOmVxKCcgKyBtYXRjaGVzLmpvaW4oJyksIDplcSgnKSArICcpJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXG4gICAgXHRcdFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oJy5jZW50ZXInKS5yZW1vdmVDbGFzcygnY2VudGVyJyk7XG4gICAgXHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuY2VudGVyKSB7XG4gICAgXHRcdFx0XHR0aGlzLiRzdGFnZS5jaGlsZHJlbigpLmVxKHRoaXMuY3VycmVudCgpKS5hZGRDbGFzcygnY2VudGVyJyk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG4gICAgXHR9IF07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQ3JlYXRlIHRoZSBzdGFnZSBET00gZWxlbWVudFxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLmluaXRpYWxpemVTdGFnZSA9IGZ1bmN0aW9uKCkge1xuICAgIFx0XHR0aGlzLiRzdGFnZSA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLnNldHRpbmdzLnN0YWdlQ2xhc3MpO1xuXG4gICAgXHRcdC8vIGlmIHRoZSBzdGFnZSBpcyBhbHJlYWR5IGluIHRoZSBET00sIGdyYWIgaXQgYW5kIHNraXAgc3RhZ2UgaW5pdGlhbGl6YXRpb25cbiAgICBcdFx0aWYgKHRoaXMuJHN0YWdlLmxlbmd0aCkge1xuICAgIFx0XHRcdHJldHVybjtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcyk7XG5cbiAgICBcdFx0Ly8gY3JlYXRlIHN0YWdlXG4gICAgXHRcdHRoaXMuJHN0YWdlID0gJCgnPCcgKyB0aGlzLnNldHRpbmdzLnN0YWdlRWxlbWVudCArICc+Jywge1xuICAgIFx0XHRcdFwiY2xhc3NcIjogdGhpcy5zZXR0aW5ncy5zdGFnZUNsYXNzXG4gICAgXHRcdH0pLndyYXAoICQoICc8ZGl2Lz4nLCB7XG4gICAgXHRcdFx0XCJjbGFzc1wiOiB0aGlzLnNldHRpbmdzLnN0YWdlT3V0ZXJDbGFzc1xuICAgIFx0XHR9KSk7XG5cbiAgICBcdFx0Ly8gYXBwZW5kIHN0YWdlXG4gICAgXHRcdHRoaXMuJGVsZW1lbnQuYXBwZW5kKHRoaXMuJHN0YWdlLnBhcmVudCgpKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQ3JlYXRlIGl0ZW0gRE9NIGVsZW1lbnRzXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUuaW5pdGlhbGl6ZUl0ZW1zID0gZnVuY3Rpb24oKSB7XG4gICAgXHRcdHZhciAkaXRlbXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5vd2wtaXRlbScpO1xuXG4gICAgXHRcdC8vIGlmIHRoZSBpdGVtcyBhcmUgYWxyZWFkeSBpbiB0aGUgRE9NLCBncmFiIHRoZW0gYW5kIHNraXAgaXRlbSBpbml0aWFsaXphdGlvblxuICAgIFx0XHRpZiAoJGl0ZW1zLmxlbmd0aCkge1xuICAgIFx0XHRcdHRoaXMuX2l0ZW1zID0gJGl0ZW1zLmdldCgpLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgXHRcdFx0XHRyZXR1cm4gJChpdGVtKTtcbiAgICBcdFx0XHR9KTtcblxuICAgIFx0XHRcdHRoaXMuX21lcmdlcnMgPSB0aGlzLl9pdGVtcy5tYXAoZnVuY3Rpb24oKSB7XG4gICAgXHRcdFx0XHRyZXR1cm4gMTtcbiAgICBcdFx0XHR9KTtcblxuICAgIFx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXG4gICAgXHRcdFx0cmV0dXJuO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gYXBwZW5kIGNvbnRlbnRcbiAgICBcdFx0dGhpcy5yZXBsYWNlKHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oKS5ub3QodGhpcy4kc3RhZ2UucGFyZW50KCkpKTtcblxuICAgIFx0XHQvLyBjaGVjayB2aXNpYmlsaXR5XG4gICAgXHRcdGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgXHRcdFx0Ly8gdXBkYXRlIHZpZXdcbiAgICBcdFx0XHR0aGlzLnJlZnJlc2goKTtcbiAgICBcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHQvLyBpbnZhbGlkYXRlIHdpZHRoXG4gICAgXHRcdFx0dGhpcy5pbnZhbGlkYXRlKCd3aWR0aCcpO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy4kZWxlbWVudFxuICAgIFx0XHRcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKVxuICAgIFx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGVkQ2xhc3MpO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBJbml0aWFsaXplcyB0aGUgY2Fyb3VzZWwuXG4gICAgXHQgKiBAcHJvdGVjdGVkXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIFx0XHR0aGlzLmVudGVyKCdpbml0aWFsaXppbmcnKTtcbiAgICBcdFx0dGhpcy50cmlnZ2VyKCdpbml0aWFsaXplJyk7XG5cbiAgICBcdFx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLnNldHRpbmdzLnJ0bENsYXNzLCB0aGlzLnNldHRpbmdzLnJ0bCk7XG5cbiAgICBcdFx0aWYgKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoICYmICF0aGlzLmlzKCdwcmUtbG9hZGluZycpKSB7XG4gICAgXHRcdFx0dmFyIGltZ3MsIG5lc3RlZFNlbGVjdG9yLCB3aWR0aDtcbiAgICBcdFx0XHRpbWdzID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbWcnKTtcbiAgICBcdFx0XHRuZXN0ZWRTZWxlY3RvciA9IHRoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yID8gJy4nICsgdGhpcy5zZXR0aW5ncy5uZXN0ZWRJdGVtU2VsZWN0b3IgOiB1bmRlZmluZWQ7XG4gICAgXHRcdFx0d2lkdGggPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKG5lc3RlZFNlbGVjdG9yKS53aWR0aCgpO1xuXG4gICAgXHRcdFx0aWYgKGltZ3MubGVuZ3RoICYmIHdpZHRoIDw9IDApIHtcbiAgICBcdFx0XHRcdHRoaXMucHJlbG9hZEF1dG9XaWR0aEltYWdlcyhpbWdzKTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmluaXRpYWxpemVTdGFnZSgpO1xuICAgIFx0XHR0aGlzLmluaXRpYWxpemVJdGVtcygpO1xuXG4gICAgXHRcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gICAgXHRcdHRoaXMucmVnaXN0ZXJFdmVudEhhbmRsZXJzKCk7XG5cbiAgICBcdFx0dGhpcy5sZWF2ZSgnaW5pdGlhbGl6aW5nJyk7XG4gICAgXHRcdHRoaXMudHJpZ2dlcignaW5pdGlhbGl6ZWQnKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQHJldHVybnMge0Jvb2xlYW59IHZpc2liaWxpdHkgb2YgJGVsZW1lbnRcbiAgICBcdCAqICAgICAgICAgICAgICAgICAgICBpZiB5b3Uga25vdyB0aGUgY2Fyb3VzZWwgd2lsbCBhbHdheXMgYmUgdmlzaWJsZSB5b3UgY2FuIHNldCBgY2hlY2tWaXNpYmlsaXR5YCB0byBgZmFsc2VgIHRvXG4gICAgXHQgKiAgICAgICAgICAgICAgICAgICAgcHJldmVudCB0aGUgZXhwZW5zaXZlIGJyb3dzZXIgbGF5b3V0IGZvcmNlZCByZWZsb3cgdGhlICRlbGVtZW50LmlzKCc6dmlzaWJsZScpIGRvZXNcbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcbiAgICBcdFx0cmV0dXJuIHRoaXMuc2V0dGluZ3MuY2hlY2tWaXNpYmlsaXR5XG4gICAgXHRcdFx0PyB0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpXG4gICAgXHRcdFx0OiB0cnVlO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBTZXR1cHMgdGhlIGN1cnJlbnQgc2V0dGluZ3MuXG4gICAgXHQgKiBAdG9kbyBSZW1vdmUgcmVzcG9uc2l2ZSBjbGFzc2VzLiBXaHkgc2hvdWxkIGFkYXB0aXZlIGRlc2lnbnMgYmUgYnJvdWdodCBpbnRvIElFOD9cbiAgICBcdCAqIEB0b2RvIFN1cHBvcnQgZm9yIG1lZGlhIHF1ZXJpZXMgYnkgdXNpbmcgYG1hdGNoTWVkaWFgIHdvdWxkIGJlIG5pY2UuXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICBcdFx0dmFyIHZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydCgpLFxuICAgIFx0XHRcdG92ZXJ3cml0ZXMgPSB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSxcbiAgICBcdFx0XHRtYXRjaCA9IC0xLFxuICAgIFx0XHRcdHNldHRpbmdzID0gbnVsbDtcblxuICAgIFx0XHRpZiAoIW92ZXJ3cml0ZXMpIHtcbiAgICBcdFx0XHRzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgIFx0XHR9IGVsc2Uge1xuICAgIFx0XHRcdCQuZWFjaChvdmVyd3JpdGVzLCBmdW5jdGlvbihicmVha3BvaW50KSB7XG4gICAgXHRcdFx0XHRpZiAoYnJlYWtwb2ludCA8PSB2aWV3cG9ydCAmJiBicmVha3BvaW50ID4gbWF0Y2gpIHtcbiAgICBcdFx0XHRcdFx0bWF0Y2ggPSBOdW1iZXIoYnJlYWtwb2ludCk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSk7XG5cbiAgICBcdFx0XHRzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG92ZXJ3cml0ZXNbbWF0Y2hdKTtcbiAgICBcdFx0XHRpZiAodHlwZW9mIHNldHRpbmdzLnN0YWdlUGFkZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFx0XHRcdFx0c2V0dGluZ3Muc3RhZ2VQYWRkaW5nID0gc2V0dGluZ3Muc3RhZ2VQYWRkaW5nKCk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHRcdGRlbGV0ZSBzZXR0aW5ncy5yZXNwb25zaXZlO1xuXG4gICAgXHRcdFx0Ly8gcmVzcG9uc2l2ZSBjbGFzc1xuICAgIFx0XHRcdGlmIChzZXR0aW5ncy5yZXNwb25zaXZlQ2xhc3MpIHtcbiAgICBcdFx0XHRcdHRoaXMuJGVsZW1lbnQuYXR0cignY2xhc3MnLFxuICAgIFx0XHRcdFx0XHR0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykucmVwbGFjZShuZXcgUmVnRXhwKCcoJyArIHRoaXMub3B0aW9ucy5yZXNwb25zaXZlQ2xhc3MgKyAnLSlcXFxcUytcXFxccycsICdnJyksICckMScgKyBtYXRjaClcbiAgICBcdFx0XHRcdCk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdzZXR0aW5ncycsIHZhbHVlOiBzZXR0aW5ncyB9IH0pO1xuICAgIFx0XHR0aGlzLl9icmVha3BvaW50ID0gbWF0Y2g7XG4gICAgXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICBcdFx0dGhpcy5pbnZhbGlkYXRlKCdzZXR0aW5ncycpO1xuICAgIFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdzZXR0aW5ncycsIHZhbHVlOiB0aGlzLnNldHRpbmdzIH0gfSk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFVwZGF0ZXMgb3B0aW9uIGxvZ2ljIGlmIG5lY2Vzc2VyeS5cbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5vcHRpb25zTG9naWMgPSBmdW5jdGlvbigpIHtcbiAgICBcdFx0aWYgKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoKSB7XG4gICAgXHRcdFx0dGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcgPSBmYWxzZTtcbiAgICBcdFx0XHR0aGlzLnNldHRpbmdzLm1lcmdlID0gZmFsc2U7XG4gICAgXHRcdH1cbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogUHJlcGFyZXMgYW4gaXRlbSBiZWZvcmUgYWRkLlxuICAgIFx0ICogQHRvZG8gUmVuYW1lIGV2ZW50IHBhcmFtZXRlciBgY29udGVudGAgdG8gYGl0ZW1gLlxuICAgIFx0ICogQHByb3RlY3RlZFxuICAgIFx0ICogQHJldHVybnMge2pRdWVyeXxIVE1MRWxlbWVudH0gLSBUaGUgaXRlbSBjb250YWluZXIuXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICBcdFx0dmFyIGV2ZW50ID0gdGhpcy50cmlnZ2VyKCdwcmVwYXJlJywgeyBjb250ZW50OiBpdGVtIH0pO1xuXG4gICAgXHRcdGlmICghZXZlbnQuZGF0YSkge1xuICAgIFx0XHRcdGV2ZW50LmRhdGEgPSAkKCc8JyArIHRoaXMuc2V0dGluZ3MuaXRlbUVsZW1lbnQgKyAnLz4nKVxuICAgIFx0XHRcdFx0LmFkZENsYXNzKHRoaXMub3B0aW9ucy5pdGVtQ2xhc3MpLmFwcGVuZChpdGVtKTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMudHJpZ2dlcigncHJlcGFyZWQnLCB7IGNvbnRlbnQ6IGV2ZW50LmRhdGEgfSk7XG5cbiAgICBcdFx0cmV0dXJuIGV2ZW50LmRhdGE7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFVwZGF0ZXMgdGhlIHZpZXcuXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgXHRcdHZhciBpID0gMCxcbiAgICBcdFx0XHRuID0gdGhpcy5fcGlwZS5sZW5ndGgsXG4gICAgXHRcdFx0ZmlsdGVyID0gJC5wcm94eShmdW5jdGlvbihwKSB7IHJldHVybiB0aGlzW3BdIH0sIHRoaXMuX2ludmFsaWRhdGVkKSxcbiAgICBcdFx0XHRjYWNoZSA9IHt9O1xuXG4gICAgXHRcdHdoaWxlIChpIDwgbikge1xuICAgIFx0XHRcdGlmICh0aGlzLl9pbnZhbGlkYXRlZC5hbGwgfHwgJC5ncmVwKHRoaXMuX3BpcGVbaV0uZmlsdGVyLCBmaWx0ZXIpLmxlbmd0aCA+IDApIHtcbiAgICBcdFx0XHRcdHRoaXMuX3BpcGVbaV0ucnVuKGNhY2hlKTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdFx0aSsrO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5faW52YWxpZGF0ZWQgPSB7fTtcblxuICAgIFx0XHQhdGhpcy5pcygndmFsaWQnKSAmJiB0aGlzLmVudGVyKCd2YWxpZCcpO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgdmlldy5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqIEBwYXJhbSB7T3dsLldpZHRofSBbZGltZW5zaW9uPU93bC5XaWR0aC5EZWZhdWx0XSAtIFRoZSBkaW1lbnNpb24gdG8gcmV0dXJuLlxuICAgIFx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgd2lkdGggb2YgdGhlIHZpZXcgaW4gcGl4ZWwuXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbihkaW1lbnNpb24pIHtcbiAgICBcdFx0ZGltZW5zaW9uID0gZGltZW5zaW9uIHx8IE93bC5XaWR0aC5EZWZhdWx0O1xuICAgIFx0XHRzd2l0Y2ggKGRpbWVuc2lvbikge1xuICAgIFx0XHRcdGNhc2UgT3dsLldpZHRoLklubmVyOlxuICAgIFx0XHRcdGNhc2UgT3dsLldpZHRoLk91dGVyOlxuICAgIFx0XHRcdFx0cmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgIFx0XHRcdGRlZmF1bHQ6XG4gICAgXHRcdFx0XHRyZXR1cm4gdGhpcy5fd2lkdGggLSB0aGlzLnNldHRpbmdzLnN0YWdlUGFkZGluZyAqIDIgKyB0aGlzLnNldHRpbmdzLm1hcmdpbjtcbiAgICBcdFx0fVxuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBSZWZyZXNoZXMgdGhlIGNhcm91c2VsIHByaW1hcmlseSBmb3IgYWRhcHRpdmUgcHVycG9zZXMuXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIFx0XHR0aGlzLmVudGVyKCdyZWZyZXNoaW5nJyk7XG4gICAgXHRcdHRoaXMudHJpZ2dlcigncmVmcmVzaCcpO1xuXG4gICAgXHRcdHRoaXMuc2V0dXAoKTtcblxuICAgIFx0XHR0aGlzLm9wdGlvbnNMb2dpYygpO1xuXG4gICAgXHRcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnJlZnJlc2hDbGFzcyk7XG5cbiAgICBcdFx0dGhpcy51cGRhdGUoKTtcblxuICAgIFx0XHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5yZWZyZXNoQ2xhc3MpO1xuXG4gICAgXHRcdHRoaXMubGVhdmUoJ3JlZnJlc2hpbmcnKTtcbiAgICBcdFx0dGhpcy50cmlnZ2VyKCdyZWZyZXNoZWQnKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQ2hlY2tzIHdpbmRvdyBgcmVzaXplYCBldmVudC5cbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5vblRocm90dGxlZFJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZXIpO1xuICAgIFx0XHR0aGlzLnJlc2l6ZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5faGFuZGxlcnMub25SZXNpemUsIHRoaXMuc2V0dGluZ3MucmVzcG9uc2l2ZVJlZnJlc2hSYXRlKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQ2hlY2tzIHdpbmRvdyBgcmVzaXplYCBldmVudC5cbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5vblJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIFx0XHRpZiAoIXRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICh0aGlzLl93aWR0aCA9PT0gdGhpcy4kZWxlbWVudC53aWR0aCgpKSB7XG4gICAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCF0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5lbnRlcigncmVzaXppbmcnKTtcblxuICAgIFx0XHRpZiAodGhpcy50cmlnZ2VyKCdyZXNpemUnKS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgIFx0XHRcdHRoaXMubGVhdmUoJ3Jlc2l6aW5nJyk7XG4gICAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5pbnZhbGlkYXRlKCd3aWR0aCcpO1xuXG4gICAgXHRcdHRoaXMucmVmcmVzaCgpO1xuXG4gICAgXHRcdHRoaXMubGVhdmUoJ3Jlc2l6aW5nJyk7XG4gICAgXHRcdHRoaXMudHJpZ2dlcigncmVzaXplZCcpO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBSZWdpc3RlcnMgZXZlbnQgaGFuZGxlcnMuXG4gICAgXHQgKiBAdG9kbyBDaGVjayBgbXNQb2ludGVyRW5hYmxlZGBcbiAgICBcdCAqIEB0b2RvICMyNjFcbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5yZWdpc3RlckV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgICBcdFx0aWYgKCQuc3VwcG9ydC50cmFuc2l0aW9uKSB7XG4gICAgXHRcdFx0dGhpcy4kc3RhZ2Uub24oJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kICsgJy5vd2wuY29yZScsICQucHJveHkodGhpcy5vblRyYW5zaXRpb25FbmQsIHRoaXMpKTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICh0aGlzLnNldHRpbmdzLnJlc3BvbnNpdmUgIT09IGZhbHNlKSB7XG4gICAgXHRcdFx0dGhpcy5vbih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9oYW5kbGVycy5vblRocm90dGxlZFJlc2l6ZSk7XG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAodGhpcy5zZXR0aW5ncy5tb3VzZURyYWcpIHtcbiAgICBcdFx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5kcmFnQ2xhc3MpO1xuICAgIFx0XHRcdHRoaXMuJHN0YWdlLm9uKCdtb3VzZWRvd24ub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnU3RhcnQsIHRoaXMpKTtcbiAgICBcdFx0XHR0aGlzLiRzdGFnZS5vbignZHJhZ3N0YXJ0Lm93bC5jb3JlIHNlbGVjdHN0YXJ0Lm93bC5jb3JlJywgZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZSB9KTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICh0aGlzLnNldHRpbmdzLnRvdWNoRHJhZyl7XG4gICAgXHRcdFx0dGhpcy4kc3RhZ2Uub24oJ3RvdWNoc3RhcnQub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnU3RhcnQsIHRoaXMpKTtcbiAgICBcdFx0XHR0aGlzLiRzdGFnZS5vbigndG91Y2hjYW5jZWwub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnRW5kLCB0aGlzKSk7XG4gICAgXHRcdH1cbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogSGFuZGxlcyBgdG91Y2hzdGFydGAgYW5kIGBtb3VzZWRvd25gIGV2ZW50cy5cbiAgICBcdCAqIEB0b2RvIEhvcml6b250YWwgc3dpcGUgdGhyZXNob2xkIGFzIG9wdGlvblxuICAgIFx0ICogQHRvZG8gIzI2MVxuICAgIFx0ICogQHByb3RlY3RlZFxuICAgIFx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBcdFx0dmFyIHN0YWdlID0gbnVsbDtcblxuICAgIFx0XHRpZiAoZXZlbnQud2hpY2ggPT09IDMpIHtcbiAgICBcdFx0XHRyZXR1cm47XG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoJC5zdXBwb3J0LnRyYW5zZm9ybSkge1xuICAgIFx0XHRcdHN0YWdlID0gdGhpcy4kc3RhZ2UuY3NzKCd0cmFuc2Zvcm0nKS5yZXBsYWNlKC8uKlxcKHxcXCl8IC9nLCAnJykuc3BsaXQoJywnKTtcbiAgICBcdFx0XHRzdGFnZSA9IHtcbiAgICBcdFx0XHRcdHg6IHN0YWdlW3N0YWdlLmxlbmd0aCA9PT0gMTYgPyAxMiA6IDRdLFxuICAgIFx0XHRcdFx0eTogc3RhZ2Vbc3RhZ2UubGVuZ3RoID09PSAxNiA/IDEzIDogNV1cbiAgICBcdFx0XHR9O1xuICAgIFx0XHR9IGVsc2Uge1xuICAgIFx0XHRcdHN0YWdlID0gdGhpcy4kc3RhZ2UucG9zaXRpb24oKTtcbiAgICBcdFx0XHRzdGFnZSA9IHtcbiAgICBcdFx0XHRcdHg6IHRoaXMuc2V0dGluZ3MucnRsID9cbiAgICBcdFx0XHRcdFx0c3RhZ2UubGVmdCArIHRoaXMuJHN0YWdlLndpZHRoKCkgLSB0aGlzLndpZHRoKCkgKyB0aGlzLnNldHRpbmdzLm1hcmdpbiA6XG4gICAgXHRcdFx0XHRcdHN0YWdlLmxlZnQsXG4gICAgXHRcdFx0XHR5OiBzdGFnZS50b3BcbiAgICBcdFx0XHR9O1xuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKHRoaXMuaXMoJ2FuaW1hdGluZycpKSB7XG4gICAgXHRcdFx0JC5zdXBwb3J0LnRyYW5zZm9ybSA/IHRoaXMuYW5pbWF0ZShzdGFnZS54KSA6IHRoaXMuJHN0YWdlLnN0b3AoKTtcbiAgICBcdFx0XHR0aGlzLmludmFsaWRhdGUoJ3Bvc2l0aW9uJyk7XG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKHRoaXMub3B0aW9ucy5ncmFiQ2xhc3MsIGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nKTtcblxuICAgIFx0XHR0aGlzLnNwZWVkKDApO1xuXG4gICAgXHRcdHRoaXMuX2RyYWcudGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIFx0XHR0aGlzLl9kcmFnLnRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KTtcbiAgICBcdFx0dGhpcy5fZHJhZy5zdGFnZS5zdGFydCA9IHN0YWdlO1xuICAgIFx0XHR0aGlzLl9kcmFnLnN0YWdlLmN1cnJlbnQgPSBzdGFnZTtcbiAgICBcdFx0dGhpcy5fZHJhZy5wb2ludGVyID0gdGhpcy5wb2ludGVyKGV2ZW50KTtcblxuICAgIFx0XHQkKGRvY3VtZW50KS5vbignbW91c2V1cC5vd2wuY29yZSB0b3VjaGVuZC5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdFbmQsIHRoaXMpKTtcblxuICAgIFx0XHQkKGRvY3VtZW50KS5vbmUoJ21vdXNlbW92ZS5vd2wuY29yZSB0b3VjaG1vdmUub3dsLmNvcmUnLCAkLnByb3h5KGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgXHRcdFx0dmFyIGRlbHRhID0gdGhpcy5kaWZmZXJlbmNlKHRoaXMuX2RyYWcucG9pbnRlciwgdGhpcy5wb2ludGVyKGV2ZW50KSk7XG5cbiAgICBcdFx0XHQkKGRvY3VtZW50KS5vbignbW91c2Vtb3ZlLm93bC5jb3JlIHRvdWNobW92ZS5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdNb3ZlLCB0aGlzKSk7XG5cbiAgICBcdFx0XHRpZiAoTWF0aC5hYnMoZGVsdGEueCkgPCBNYXRoLmFicyhkZWx0YS55KSAmJiB0aGlzLmlzKCd2YWxpZCcpKSB7XG4gICAgXHRcdFx0XHRyZXR1cm47XG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIFx0XHRcdHRoaXMuZW50ZXIoJ2RyYWdnaW5nJyk7XG4gICAgXHRcdFx0dGhpcy50cmlnZ2VyKCdkcmFnJyk7XG4gICAgXHRcdH0sIHRoaXMpKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogSGFuZGxlcyB0aGUgYHRvdWNobW92ZWAgYW5kIGBtb3VzZW1vdmVgIGV2ZW50cy5cbiAgICBcdCAqIEB0b2RvICMyNjFcbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGFyZ3VtZW50cy5cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5vbkRyYWdNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBcdFx0dmFyIG1pbmltdW0gPSBudWxsLFxuICAgIFx0XHRcdG1heGltdW0gPSBudWxsLFxuICAgIFx0XHRcdHB1bGwgPSBudWxsLFxuICAgIFx0XHRcdGRlbHRhID0gdGhpcy5kaWZmZXJlbmNlKHRoaXMuX2RyYWcucG9pbnRlciwgdGhpcy5wb2ludGVyKGV2ZW50KSksXG4gICAgXHRcdFx0c3RhZ2UgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5zdGFnZS5zdGFydCwgZGVsdGEpO1xuXG4gICAgXHRcdGlmICghdGhpcy5pcygnZHJhZ2dpbmcnKSkge1xuICAgIFx0XHRcdHJldHVybjtcbiAgICBcdFx0fVxuXG4gICAgXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBcdFx0aWYgKHRoaXMuc2V0dGluZ3MubG9vcCkge1xuICAgIFx0XHRcdG1pbmltdW0gPSB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWluaW11bSgpKTtcbiAgICBcdFx0XHRtYXhpbXVtID0gdGhpcy5jb29yZGluYXRlcyh0aGlzLm1heGltdW0oKSArIDEpIC0gbWluaW11bTtcbiAgICBcdFx0XHRzdGFnZS54ID0gKCgoc3RhZ2UueCAtIG1pbmltdW0pICUgbWF4aW11bSArIG1heGltdW0pICUgbWF4aW11bSkgKyBtaW5pbXVtO1xuICAgIFx0XHR9IGVsc2Uge1xuICAgIFx0XHRcdG1pbmltdW0gPSB0aGlzLnNldHRpbmdzLnJ0bCA/IHRoaXMuY29vcmRpbmF0ZXModGhpcy5tYXhpbXVtKCkpIDogdGhpcy5jb29yZGluYXRlcyh0aGlzLm1pbmltdW0oKSk7XG4gICAgXHRcdFx0bWF4aW11bSA9IHRoaXMuc2V0dGluZ3MucnRsID8gdGhpcy5jb29yZGluYXRlcyh0aGlzLm1pbmltdW0oKSkgOiB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpKTtcbiAgICBcdFx0XHRwdWxsID0gdGhpcy5zZXR0aW5ncy5wdWxsRHJhZyA/IC0xICogZGVsdGEueCAvIDUgOiAwO1xuICAgIFx0XHRcdHN0YWdlLnggPSBNYXRoLm1heChNYXRoLm1pbihzdGFnZS54LCBtaW5pbXVtICsgcHVsbCksIG1heGltdW0gKyBwdWxsKTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuX2RyYWcuc3RhZ2UuY3VycmVudCA9IHN0YWdlO1xuXG4gICAgXHRcdHRoaXMuYW5pbWF0ZShzdGFnZS54KTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogSGFuZGxlcyB0aGUgYHRvdWNoZW5kYCBhbmQgYG1vdXNldXBgIGV2ZW50cy5cbiAgICBcdCAqIEB0b2RvICMyNjFcbiAgICBcdCAqIEB0b2RvIFRocmVzaG9sZCBmb3IgY2xpY2sgZXZlbnRcbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGFyZ3VtZW50cy5cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5vbkRyYWdFbmQgPSBmdW5jdGlvbihldmVudCkge1xuICAgIFx0XHR2YXIgZGVsdGEgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5wb2ludGVyLCB0aGlzLnBvaW50ZXIoZXZlbnQpKSxcbiAgICBcdFx0XHRzdGFnZSA9IHRoaXMuX2RyYWcuc3RhZ2UuY3VycmVudCxcbiAgICBcdFx0XHRkaXJlY3Rpb24gPSBkZWx0YS54ID4gMCBeIHRoaXMuc2V0dGluZ3MucnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAgIFx0XHQkKGRvY3VtZW50KS5vZmYoJy5vd2wuY29yZScpO1xuXG4gICAgXHRcdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmdyYWJDbGFzcyk7XG5cbiAgICBcdFx0aWYgKGRlbHRhLnggIT09IDAgJiYgdGhpcy5pcygnZHJhZ2dpbmcnKSB8fCAhdGhpcy5pcygndmFsaWQnKSkge1xuICAgIFx0XHRcdHRoaXMuc3BlZWQodGhpcy5zZXR0aW5ncy5kcmFnRW5kU3BlZWQgfHwgdGhpcy5zZXR0aW5ncy5zbWFydFNwZWVkKTtcbiAgICBcdFx0XHR0aGlzLmN1cnJlbnQodGhpcy5jbG9zZXN0KHN0YWdlLngsIGRlbHRhLnggIT09IDAgPyBkaXJlY3Rpb24gOiB0aGlzLl9kcmFnLmRpcmVjdGlvbikpO1xuICAgIFx0XHRcdHRoaXMuaW52YWxpZGF0ZSgncG9zaXRpb24nKTtcbiAgICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG4gICAgXHRcdFx0dGhpcy5fZHJhZy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG5cbiAgICBcdFx0XHRpZiAoTWF0aC5hYnMoZGVsdGEueCkgPiAzIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fZHJhZy50aW1lID4gMzAwKSB7XG4gICAgXHRcdFx0XHR0aGlzLl9kcmFnLnRhcmdldC5vbmUoJ2NsaWNrLm93bC5jb3JlJywgZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCF0aGlzLmlzKCdkcmFnZ2luZycpKSB7XG4gICAgXHRcdFx0cmV0dXJuO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5sZWF2ZSgnZHJhZ2dpbmcnKTtcbiAgICBcdFx0dGhpcy50cmlnZ2VyKCdkcmFnZ2VkJyk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIEdldHMgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGNsb3Nlc3QgaXRlbSBmb3IgYSBjb29yZGluYXRlLlxuICAgIFx0ICogQHRvZG8gU2V0dGluZyBgZnJlZURyYWdgIG1ha2VzIGBjbG9zZXN0YCBub3QgcmV1c2FibGUuIFNlZSAjMTY1LlxuICAgIFx0ICogQHByb3RlY3RlZFxuICAgIFx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvb3JkaW5hdGUgLSBUaGUgY29vcmRpbmF0ZSBpbiBwaXhlbC5cbiAgICBcdCAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIHRvIGNoZWNrIGZvciB0aGUgY2xvc2VzdCBpdGVtLiBFdGhlciBgbGVmdGAgb3IgYHJpZ2h0YC5cbiAgICBcdCAqIEByZXR1cm4ge051bWJlcn0gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGNsb3Nlc3QgaXRlbS5cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZSwgZGlyZWN0aW9uKSB7XG4gICAgXHRcdHZhciBwb3NpdGlvbiA9IC0xLFxuICAgIFx0XHRcdHB1bGwgPSAzMCxcbiAgICBcdFx0XHR3aWR0aCA9IHRoaXMud2lkdGgoKSxcbiAgICBcdFx0XHRjb29yZGluYXRlcyA9IHRoaXMuY29vcmRpbmF0ZXMoKTtcblxuICAgIFx0XHRpZiAoIXRoaXMuc2V0dGluZ3MuZnJlZURyYWcpIHtcbiAgICBcdFx0XHQvLyBjaGVjayBjbG9zZXN0IGl0ZW1cbiAgICBcdFx0XHQkLmVhY2goY29vcmRpbmF0ZXMsICQucHJveHkoZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG4gICAgXHRcdFx0XHQvLyBvbiBhIGxlZnQgcHVsbCwgY2hlY2sgb24gY3VycmVudCBpbmRleFxuICAgIFx0XHRcdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmIGNvb3JkaW5hdGUgPiB2YWx1ZSAtIHB1bGwgJiYgY29vcmRpbmF0ZSA8IHZhbHVlICsgcHVsbCkge1xuICAgIFx0XHRcdFx0XHRwb3NpdGlvbiA9IGluZGV4O1xuICAgIFx0XHRcdFx0Ly8gb24gYSByaWdodCBwdWxsLCBjaGVjayBvbiBwcmV2aW91cyBpbmRleFxuICAgIFx0XHRcdFx0Ly8gdG8gZG8gc28sIHN1YnRyYWN0IHdpZHRoIGZyb20gdmFsdWUgYW5kIHNldCBwb3NpdGlvbiA9IGluZGV4ICsgMVxuICAgIFx0XHRcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcgJiYgY29vcmRpbmF0ZSA+IHZhbHVlIC0gd2lkdGggLSBwdWxsICYmIGNvb3JkaW5hdGUgPCB2YWx1ZSAtIHdpZHRoICsgcHVsbCkge1xuICAgIFx0XHRcdFx0XHRwb3NpdGlvbiA9IGluZGV4ICsgMTtcbiAgICBcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5vcChjb29yZGluYXRlLCAnPCcsIHZhbHVlKVxuICAgIFx0XHRcdFx0XHQmJiB0aGlzLm9wKGNvb3JkaW5hdGUsICc+JywgY29vcmRpbmF0ZXNbaW5kZXggKyAxXSAhPT0gdW5kZWZpbmVkID8gY29vcmRpbmF0ZXNbaW5kZXggKyAxXSA6IHZhbHVlIC0gd2lkdGgpKSB7XG4gICAgXHRcdFx0XHRcdHBvc2l0aW9uID0gZGlyZWN0aW9uID09PSAnbGVmdCcgPyBpbmRleCArIDEgOiBpbmRleDtcbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHRcdHJldHVybiBwb3NpdGlvbiA9PT0gLTE7XG4gICAgXHRcdFx0fSwgdGhpcykpO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCF0aGlzLnNldHRpbmdzLmxvb3ApIHtcbiAgICBcdFx0XHQvLyBub24gbG9vcCBib3VuZHJpZXNcbiAgICBcdFx0XHRpZiAodGhpcy5vcChjb29yZGluYXRlLCAnPicsIGNvb3JkaW5hdGVzW3RoaXMubWluaW11bSgpXSkpIHtcbiAgICBcdFx0XHRcdHBvc2l0aW9uID0gY29vcmRpbmF0ZSA9IHRoaXMubWluaW11bSgpO1xuICAgIFx0XHRcdH0gZWxzZSBpZiAodGhpcy5vcChjb29yZGluYXRlLCAnPCcsIGNvb3JkaW5hdGVzW3RoaXMubWF4aW11bSgpXSkpIHtcbiAgICBcdFx0XHRcdHBvc2l0aW9uID0gY29vcmRpbmF0ZSA9IHRoaXMubWF4aW11bSgpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBwb3NpdGlvbjtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQW5pbWF0ZXMgdGhlIHN0YWdlLlxuICAgIFx0ICogQHRvZG8gIzI3MFxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvb3JkaW5hdGUgLSBUaGUgY29vcmRpbmF0ZSBpbiBwaXhlbHMuXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uKGNvb3JkaW5hdGUpIHtcbiAgICBcdFx0dmFyIGFuaW1hdGUgPSB0aGlzLnNwZWVkKCkgPiAwO1xuXG4gICAgXHRcdHRoaXMuaXMoJ2FuaW1hdGluZycpICYmIHRoaXMub25UcmFuc2l0aW9uRW5kKCk7XG5cbiAgICBcdFx0aWYgKGFuaW1hdGUpIHtcbiAgICBcdFx0XHR0aGlzLmVudGVyKCdhbmltYXRpbmcnKTtcbiAgICBcdFx0XHR0aGlzLnRyaWdnZXIoJ3RyYW5zbGF0ZScpO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCQuc3VwcG9ydC50cmFuc2Zvcm0zZCAmJiAkLnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgIFx0XHRcdHRoaXMuJHN0YWdlLmNzcyh7XG4gICAgXHRcdFx0XHR0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnICsgY29vcmRpbmF0ZSArICdweCwwcHgsMHB4KScsXG4gICAgXHRcdFx0XHR0cmFuc2l0aW9uOiAodGhpcy5zcGVlZCgpIC8gMTAwMCkgKyAncycgKyAoXG4gICAgXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc2xpZGVUcmFuc2l0aW9uID8gJyAnICsgdGhpcy5zZXR0aW5ncy5zbGlkZVRyYW5zaXRpb24gOiAnJ1xuICAgIFx0XHRcdFx0KVxuICAgIFx0XHRcdH0pO1xuICAgIFx0XHR9IGVsc2UgaWYgKGFuaW1hdGUpIHtcbiAgICBcdFx0XHR0aGlzLiRzdGFnZS5hbmltYXRlKHtcbiAgICBcdFx0XHRcdGxlZnQ6IGNvb3JkaW5hdGUgKyAncHgnXG4gICAgXHRcdFx0fSwgdGhpcy5zcGVlZCgpLCB0aGlzLnNldHRpbmdzLmZhbGxiYWNrRWFzaW5nLCAkLnByb3h5KHRoaXMub25UcmFuc2l0aW9uRW5kLCB0aGlzKSk7XG4gICAgXHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0dGhpcy4kc3RhZ2UuY3NzKHtcbiAgICBcdFx0XHRcdGxlZnQ6IGNvb3JkaW5hdGUgKyAncHgnXG4gICAgXHRcdFx0fSk7XG4gICAgXHRcdH1cbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQ2hlY2tzIHdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGluIGEgc3BlY2lmaWMgc3RhdGUgb3Igbm90LlxuICAgIFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlIC0gVGhlIHN0YXRlIHRvIGNoZWNrLlxuICAgIFx0ICogQHJldHVybnMge0Jvb2xlYW59IC0gVGhlIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIHRoZSBjYXJvdXNlbCBpcyBidXN5LlxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLmlzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBcdFx0cmV0dXJuIHRoaXMuX3N0YXRlcy5jdXJyZW50W3N0YXRlXSAmJiB0aGlzLl9zdGF0ZXMuY3VycmVudFtzdGF0ZV0gPiAwO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBTZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBpdGVtLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgbmV3IGFic29sdXRlIHBvc2l0aW9uIG9yIG5vdGhpbmcgdG8gbGVhdmUgaXQgdW5jaGFuZ2VkLlxuICAgIFx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgaXRlbS5cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICBcdFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICBcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbik7XG5cbiAgICBcdFx0aWYgKHRoaXMuX2N1cnJlbnQgIT09IHBvc2l0aW9uKSB7XG4gICAgXHRcdFx0dmFyIGV2ZW50ID0gdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdwb3NpdGlvbicsIHZhbHVlOiBwb3NpdGlvbiB9IH0pO1xuXG4gICAgXHRcdFx0aWYgKGV2ZW50LmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgIFx0XHRcdFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShldmVudC5kYXRhKTtcbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLl9jdXJyZW50ID0gcG9zaXRpb247XG5cbiAgICBcdFx0XHR0aGlzLmludmFsaWRhdGUoJ3Bvc2l0aW9uJyk7XG5cbiAgICBcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdwb3NpdGlvbicsIHZhbHVlOiB0aGlzLl9jdXJyZW50IH0gfSk7XG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogSW52YWxpZGF0ZXMgdGhlIGdpdmVuIHBhcnQgb2YgdGhlIHVwZGF0ZSByb3V0aW5lLlxuICAgIFx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJ0XSAtIFRoZSBwYXJ0IHRvIGludmFsaWRhdGUuXG4gICAgXHQgKiBAcmV0dXJucyB7QXJyYXkuPFN0cmluZz59IC0gVGhlIGludmFsaWRhdGVkIHBhcnRzLlxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbihwYXJ0KSB7XG4gICAgXHRcdGlmICgkLnR5cGUocGFydCkgPT09ICdzdHJpbmcnKSB7XG4gICAgXHRcdFx0dGhpcy5faW52YWxpZGF0ZWRbcGFydF0gPSB0cnVlO1xuICAgIFx0XHRcdHRoaXMuaXMoJ3ZhbGlkJykgJiYgdGhpcy5sZWF2ZSgndmFsaWQnKTtcbiAgICBcdFx0fVxuICAgIFx0XHRyZXR1cm4gJC5tYXAodGhpcy5faW52YWxpZGF0ZWQsIGZ1bmN0aW9uKHYsIGkpIHsgcmV0dXJuIGkgfSk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFJlc2V0cyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgaXRlbS5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbmV3IGl0ZW0uXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgIFx0XHRwb3NpdGlvbiA9IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uKTtcblxuICAgIFx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgIFx0XHRcdHJldHVybjtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuX3NwZWVkID0gMDtcbiAgICBcdFx0dGhpcy5fY3VycmVudCA9IHBvc2l0aW9uO1xuXG4gICAgXHRcdHRoaXMuc3VwcHJlc3MoWyAndHJhbnNsYXRlJywgJ3RyYW5zbGF0ZWQnIF0pO1xuXG4gICAgXHRcdHRoaXMuYW5pbWF0ZSh0aGlzLmNvb3JkaW5hdGVzKHBvc2l0aW9uKSk7XG5cbiAgICBcdFx0dGhpcy5yZWxlYXNlKFsgJ3RyYW5zbGF0ZScsICd0cmFuc2xhdGVkJyBdKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogTm9ybWFsaXplcyBhbiBhYnNvbHV0ZSBvciBhIHJlbGF0aXZlIHBvc2l0aW9uIG9mIGFuIGl0ZW0uXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgb3IgcmVsYXRpdmUgcG9zaXRpb24gdG8gbm9ybWFsaXplLlxuICAgIFx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVsYXRpdmU9ZmFsc2VdIC0gV2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgcmVsYXRpdmUgb3Igbm90LlxuICAgIFx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgbm9ybWFsaXplZCBwb3NpdGlvbi5cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbihwb3NpdGlvbiwgcmVsYXRpdmUpIHtcbiAgICBcdFx0dmFyIG4gPSB0aGlzLl9pdGVtcy5sZW5ndGgsXG4gICAgXHRcdFx0bSA9IHJlbGF0aXZlID8gMCA6IHRoaXMuX2Nsb25lcy5sZW5ndGg7XG5cbiAgICBcdFx0aWYgKCF0aGlzLmlzTnVtZXJpYyhwb3NpdGlvbikgfHwgbiA8IDEpIHtcbiAgICBcdFx0XHRwb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICBcdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gbiArIG0pIHtcbiAgICBcdFx0XHRwb3NpdGlvbiA9ICgocG9zaXRpb24gLSBtIC8gMikgJSBuICsgbikgJSBuICsgbSAvIDI7XG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gcG9zaXRpb247XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIENvbnZlcnRzIGFuIGFic29sdXRlIHBvc2l0aW9uIG9mIGFuIGl0ZW0gaW50byBhIHJlbGF0aXZlIG9uZS5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiB0byBjb252ZXJ0LlxuICAgIFx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgY29udmVydGVkIHBvc2l0aW9uLlxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLnJlbGF0aXZlID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICBcdFx0cG9zaXRpb24gLT0gdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDI7XG4gICAgXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIEdldHMgdGhlIG1heGltdW0gcG9zaXRpb24gZm9yIHRoZSBjdXJyZW50IGl0ZW0uXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWxhdGl2ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHJldHVybiBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvciBhIHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgIFx0ICogQHJldHVybnMge051bWJlcn1cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5tYXhpbXVtID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgICBcdFx0dmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcbiAgICBcdFx0XHRtYXhpbXVtID0gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgIFx0XHRcdGl0ZXJhdG9yLFxuICAgIFx0XHRcdHJlY2lwcm9jYWxJdGVtc1dpZHRoLFxuICAgIFx0XHRcdGVsZW1lbnRXaWR0aDtcblxuICAgIFx0XHRpZiAoc2V0dGluZ3MubG9vcCkge1xuICAgIFx0XHRcdG1heGltdW0gPSB0aGlzLl9jbG9uZXMubGVuZ3RoIC8gMiArIHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XG4gICAgXHRcdH0gZWxzZSBpZiAoc2V0dGluZ3MuYXV0b1dpZHRoIHx8IHNldHRpbmdzLm1lcmdlKSB7XG4gICAgXHRcdFx0aXRlcmF0b3IgPSB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gICAgXHRcdFx0aWYgKGl0ZXJhdG9yKSB7XG4gICAgXHRcdFx0XHRyZWNpcHJvY2FsSXRlbXNXaWR0aCA9IHRoaXMuX2l0ZW1zWy0taXRlcmF0b3JdLndpZHRoKCk7XG4gICAgXHRcdFx0XHRlbGVtZW50V2lkdGggPSB0aGlzLiRlbGVtZW50LndpZHRoKCk7XG4gICAgXHRcdFx0XHR3aGlsZSAoaXRlcmF0b3ItLSkge1xuICAgIFx0XHRcdFx0XHRyZWNpcHJvY2FsSXRlbXNXaWR0aCArPSB0aGlzLl9pdGVtc1tpdGVyYXRvcl0ud2lkdGgoKSArIHRoaXMuc2V0dGluZ3MubWFyZ2luO1xuICAgIFx0XHRcdFx0XHRpZiAocmVjaXByb2NhbEl0ZW1zV2lkdGggPiBlbGVtZW50V2lkdGgpIHtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH1cbiAgICBcdFx0XHRtYXhpbXVtID0gaXRlcmF0b3IgKyAxO1xuICAgIFx0XHR9IGVsc2UgaWYgKHNldHRpbmdzLmNlbnRlcikge1xuICAgIFx0XHRcdG1heGltdW0gPSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xuICAgIFx0XHR9IGVsc2Uge1xuICAgIFx0XHRcdG1heGltdW0gPSB0aGlzLl9pdGVtcy5sZW5ndGggLSBzZXR0aW5ncy5pdGVtcztcbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmIChyZWxhdGl2ZSkge1xuICAgIFx0XHRcdG1heGltdW0gLT0gdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDI7XG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gTWF0aC5tYXgobWF4aW11bSwgMCk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIEdldHMgdGhlIG1pbmltdW0gcG9zaXRpb24gZm9yIHRoZSBjdXJyZW50IGl0ZW0uXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWxhdGl2ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHJldHVybiBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvciBhIHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgIFx0ICogQHJldHVybnMge051bWJlcn1cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5taW5pbXVtID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgICBcdFx0cmV0dXJuIHJlbGF0aXZlID8gMCA6IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBHZXRzIGFuIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwb3NpdGlvbi5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxuICAgIFx0ICogQHJldHVybiB7alF1ZXJ5fEFycmF5LjxqUXVlcnk+fSAtIFRoZSBpdGVtIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBvciBhbGwgaXRlbXMgaWYgbm8gcG9zaXRpb24gd2FzIGdpdmVuLlxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLml0ZW1zID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICBcdFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5faXRlbXMuc2xpY2UoKTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5faXRlbXNbcG9zaXRpb25dO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBHZXRzIGFuIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwb3NpdGlvbi5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxuICAgIFx0ICogQHJldHVybiB7alF1ZXJ5fEFycmF5LjxqUXVlcnk+fSAtIFRoZSBpdGVtIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBvciBhbGwgaXRlbXMgaWYgbm8gcG9zaXRpb24gd2FzIGdpdmVuLlxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLm1lcmdlcnMgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgIFx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgIFx0XHRcdHJldHVybiB0aGlzLl9tZXJnZXJzLnNsaWNlKCk7XG4gICAgXHRcdH1cblxuICAgIFx0XHRwb3NpdGlvbiA9IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uLCB0cnVlKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuX21lcmdlcnNbcG9zaXRpb25dO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBHZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbnMgb2YgY2xvbmVzIGZvciBhbiBpdGVtLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXG4gICAgXHQgKiBAcmV0dXJucyB7QXJyYXkuPE51bWJlcj59IC0gVGhlIGFic29sdXRlIHBvc2l0aW9ucyBvZiBjbG9uZXMgZm9yIHRoZSBpdGVtIG9yIGFsbCBpZiBubyBwb3NpdGlvbiB3YXMgZ2l2ZW4uXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUuY2xvbmVzID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICBcdFx0dmFyIG9kZCA9IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyLFxuICAgIFx0XHRcdGV2ZW4gPSBvZGQgKyB0aGlzLl9pdGVtcy5sZW5ndGgsXG4gICAgXHRcdFx0bWFwID0gZnVuY3Rpb24oaW5kZXgpIHsgcmV0dXJuIGluZGV4ICUgMiA9PT0gMCA/IGV2ZW4gKyBpbmRleCAvIDIgOiBvZGQgLSAoaW5kZXggKyAxKSAvIDIgfTtcblxuICAgIFx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgIFx0XHRcdHJldHVybiAkLm1hcCh0aGlzLl9jbG9uZXMsIGZ1bmN0aW9uKHYsIGkpIHsgcmV0dXJuIG1hcChpKSB9KTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiAkLm1hcCh0aGlzLl9jbG9uZXMsIGZ1bmN0aW9uKHYsIGkpIHsgcmV0dXJuIHYgPT09IHBvc2l0aW9uID8gbWFwKGkpIDogbnVsbCB9KTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogU2V0cyB0aGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQuXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSBhbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzIG9yIG5vdGhpbmcgdG8gbGVhdmUgaXQgdW5jaGFuZ2VkLlxuICAgIFx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzLlxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLnNwZWVkID0gZnVuY3Rpb24oc3BlZWQpIHtcbiAgICBcdFx0aWYgKHNwZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBcdFx0XHR0aGlzLl9zcGVlZCA9IHNwZWVkO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX3NwZWVkO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBHZXRzIHRoZSBjb29yZGluYXRlIG9mIGFuIGl0ZW0uXG4gICAgXHQgKiBAdG9kbyBUaGUgbmFtZSBvZiB0aGlzIG1ldGhvZCBpcyBtaXNzbGVhbmRpbmcuXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gd2l0aGluIGBtaW5pbXVtKClgIGFuZCBgbWF4aW11bSgpYC5cbiAgICBcdCAqIEByZXR1cm5zIHtOdW1iZXJ8QXJyYXkuPE51bWJlcj59IC0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGl0ZW0gaW4gcGl4ZWwgb3IgYWxsIGNvb3JkaW5hdGVzLlxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLmNvb3JkaW5hdGVzID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICBcdFx0dmFyIG11bHRpcGxpZXIgPSAxLFxuICAgIFx0XHRcdG5ld1Bvc2l0aW9uID0gcG9zaXRpb24gLSAxLFxuICAgIFx0XHRcdGNvb3JkaW5hdGU7XG5cbiAgICBcdFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBcdFx0XHRyZXR1cm4gJC5tYXAodGhpcy5fY29vcmRpbmF0ZXMsICQucHJveHkoZnVuY3Rpb24oY29vcmRpbmF0ZSwgaW5kZXgpIHtcbiAgICBcdFx0XHRcdHJldHVybiB0aGlzLmNvb3JkaW5hdGVzKGluZGV4KTtcbiAgICBcdFx0XHR9LCB0aGlzKSk7XG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAodGhpcy5zZXR0aW5ncy5jZW50ZXIpIHtcbiAgICBcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5ydGwpIHtcbiAgICBcdFx0XHRcdG11bHRpcGxpZXIgPSAtMTtcbiAgICBcdFx0XHRcdG5ld1Bvc2l0aW9uID0gcG9zaXRpb24gKyAxO1xuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGNvb3JkaW5hdGUgPSB0aGlzLl9jb29yZGluYXRlc1twb3NpdGlvbl07XG4gICAgXHRcdFx0Y29vcmRpbmF0ZSArPSAodGhpcy53aWR0aCgpIC0gY29vcmRpbmF0ZSArICh0aGlzLl9jb29yZGluYXRlc1tuZXdQb3NpdGlvbl0gfHwgMCkpIC8gMiAqIG11bHRpcGxpZXI7XG4gICAgXHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0Y29vcmRpbmF0ZSA9IHRoaXMuX2Nvb3JkaW5hdGVzW25ld1Bvc2l0aW9uXSB8fCAwO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0Y29vcmRpbmF0ZSA9IE1hdGguY2VpbChjb29yZGluYXRlKTtcblxuICAgIFx0XHRyZXR1cm4gY29vcmRpbmF0ZTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQ2FsY3VsYXRlcyB0aGUgc3BlZWQgZm9yIGEgdHJhbnNsYXRpb24uXG4gICAgXHQgKiBAcHJvdGVjdGVkXG4gICAgXHQgKiBAcGFyYW0ge051bWJlcn0gZnJvbSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnQgaXRlbS5cbiAgICBcdCAqIEBwYXJhbSB7TnVtYmVyfSB0byAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IGl0ZW0uXG4gICAgXHQgKiBAcGFyYW0ge051bWJlcn0gW2ZhY3Rvcj11bmRlZmluZWRdIC0gVGhlIHRpbWUgZmFjdG9yIGluIG1pbGxpc2Vjb25kcy5cbiAgICBcdCAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNsYXRpb24uXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgXHRcdGlmIChmYWN0b3IgPT09IDApIHtcbiAgICBcdFx0XHRyZXR1cm4gMDtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBNYXRoLm1pbihNYXRoLm1heChNYXRoLmFicyh0byAtIGZyb20pLCAxKSwgNikgKiBNYXRoLmFicygoZmFjdG9yIHx8IHRoaXMuc2V0dGluZ3Muc21hcnRTcGVlZCkpO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBTbGlkZXMgdG8gdGhlIHNwZWNpZmllZCBpdGVtLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxuICAgIFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLnRvID0gZnVuY3Rpb24ocG9zaXRpb24sIHNwZWVkKSB7XG4gICAgXHRcdHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50KCksXG4gICAgXHRcdFx0cmV2ZXJ0ID0gbnVsbCxcbiAgICBcdFx0XHRkaXN0YW5jZSA9IHBvc2l0aW9uIC0gdGhpcy5yZWxhdGl2ZShjdXJyZW50KSxcbiAgICBcdFx0XHRkaXJlY3Rpb24gPSAoZGlzdGFuY2UgPiAwKSAtIChkaXN0YW5jZSA8IDApLFxuICAgIFx0XHRcdGl0ZW1zID0gdGhpcy5faXRlbXMubGVuZ3RoLFxuICAgIFx0XHRcdG1pbmltdW0gPSB0aGlzLm1pbmltdW0oKSxcbiAgICBcdFx0XHRtYXhpbXVtID0gdGhpcy5tYXhpbXVtKCk7XG5cbiAgICBcdFx0aWYgKHRoaXMuc2V0dGluZ3MubG9vcCkge1xuICAgIFx0XHRcdGlmICghdGhpcy5zZXR0aW5ncy5yZXdpbmQgJiYgTWF0aC5hYnMoZGlzdGFuY2UpID4gaXRlbXMgLyAyKSB7XG4gICAgXHRcdFx0XHRkaXN0YW5jZSArPSBkaXJlY3Rpb24gKiAtMSAqIGl0ZW1zO1xuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHBvc2l0aW9uID0gY3VycmVudCArIGRpc3RhbmNlO1xuICAgIFx0XHRcdHJldmVydCA9ICgocG9zaXRpb24gLSBtaW5pbXVtKSAlIGl0ZW1zICsgaXRlbXMpICUgaXRlbXMgKyBtaW5pbXVtO1xuXG4gICAgXHRcdFx0aWYgKHJldmVydCAhPT0gcG9zaXRpb24gJiYgcmV2ZXJ0IC0gZGlzdGFuY2UgPD0gbWF4aW11bSAmJiByZXZlcnQgLSBkaXN0YW5jZSA+IDApIHtcbiAgICBcdFx0XHRcdGN1cnJlbnQgPSByZXZlcnQgLSBkaXN0YW5jZTtcbiAgICBcdFx0XHRcdHBvc2l0aW9uID0gcmV2ZXJ0O1xuICAgIFx0XHRcdFx0dGhpcy5yZXNldChjdXJyZW50KTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5yZXdpbmQpIHtcbiAgICBcdFx0XHRtYXhpbXVtICs9IDE7XG4gICAgXHRcdFx0cG9zaXRpb24gPSAocG9zaXRpb24gJSBtYXhpbXVtICsgbWF4aW11bSkgJSBtYXhpbXVtO1xuICAgIFx0XHR9IGVsc2Uge1xuICAgIFx0XHRcdHBvc2l0aW9uID0gTWF0aC5tYXgobWluaW11bSwgTWF0aC5taW4obWF4aW11bSwgcG9zaXRpb24pKTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuc3BlZWQodGhpcy5kdXJhdGlvbihjdXJyZW50LCBwb3NpdGlvbiwgc3BlZWQpKTtcbiAgICBcdFx0dGhpcy5jdXJyZW50KHBvc2l0aW9uKTtcblxuICAgIFx0XHRpZiAodGhpcy5pc1Zpc2libGUoKSkge1xuICAgIFx0XHRcdHRoaXMudXBkYXRlKCk7XG4gICAgXHRcdH1cbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogU2xpZGVzIHRvIHRoZSBuZXh0IGl0ZW0uXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHNwZWVkKSB7XG4gICAgXHRcdHNwZWVkID0gc3BlZWQgfHwgZmFsc2U7XG4gICAgXHRcdHRoaXMudG8odGhpcy5yZWxhdGl2ZSh0aGlzLmN1cnJlbnQoKSkgKyAxLCBzcGVlZCk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFNsaWRlcyB0byB0aGUgcHJldmlvdXMgaXRlbS5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oc3BlZWQpIHtcbiAgICBcdFx0c3BlZWQgPSBzcGVlZCB8fCBmYWxzZTtcbiAgICBcdFx0dGhpcy50byh0aGlzLnJlbGF0aXZlKHRoaXMuY3VycmVudCgpKSAtIDEsIHNwZWVkKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogSGFuZGxlcyB0aGUgZW5kIG9mIGFuIGFuaW1hdGlvbi5cbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGFyZ3VtZW50cy5cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgXHRcdC8vIGlmIGNzczIgYW5pbWF0aW9uIHRoZW4gZXZlbnQgb2JqZWN0IGlzIHVuZGVmaW5lZFxuICAgIFx0XHRpZiAoZXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgXHRcdFx0Ly8gQ2F0Y2ggb25seSBvd2wtc3RhZ2UgdHJhbnNpdGlvbkVuZCBldmVudFxuICAgIFx0XHRcdGlmICgoZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQgfHwgZXZlbnQub3JpZ2luYWxUYXJnZXQpICE9PSB0aGlzLiRzdGFnZS5nZXQoMCkpIHtcbiAgICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmxlYXZlKCdhbmltYXRpbmcnKTtcbiAgICBcdFx0dGhpcy50cmlnZ2VyKCd0cmFuc2xhdGVkJyk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIEdldHMgdmlld3BvcnQgd2lkdGguXG4gICAgXHQgKiBAcHJvdGVjdGVkXG4gICAgXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gVGhlIHdpZHRoIGluIHBpeGVsLlxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLnZpZXdwb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgXHRcdHZhciB3aWR0aDtcbiAgICBcdFx0aWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlQmFzZUVsZW1lbnQgIT09IHdpbmRvdykge1xuICAgIFx0XHRcdHdpZHRoID0gJCh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUJhc2VFbGVtZW50KS53aWR0aCgpO1xuICAgIFx0XHR9IGVsc2UgaWYgKHdpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgXHRcdFx0d2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBcdFx0fSBlbHNlIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSB7XG4gICAgXHRcdFx0d2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgXHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCdDYW4gbm90IGRldGVjdCB2aWV3cG9ydCB3aWR0aC4nKTtcbiAgICBcdFx0fVxuICAgIFx0XHRyZXR1cm4gd2lkdGg7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGpRdWVyeXxTdHJpbmd9IGNvbnRlbnQgLSBUaGUgbmV3IGNvbnRlbnQuXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICBcdFx0dGhpcy4kc3RhZ2UuZW1wdHkoKTtcbiAgICBcdFx0dGhpcy5faXRlbXMgPSBbXTtcblxuICAgIFx0XHRpZiAoY29udGVudCkge1xuICAgIFx0XHRcdGNvbnRlbnQgPSAoY29udGVudCBpbnN0YW5jZW9mIGpRdWVyeSkgPyBjb250ZW50IDogJChjb250ZW50KTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICh0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3Rvcikge1xuICAgIFx0XHRcdGNvbnRlbnQgPSBjb250ZW50LmZpbmQoJy4nICsgdGhpcy5zZXR0aW5ncy5uZXN0ZWRJdGVtU2VsZWN0b3IpO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0Y29udGVudC5maWx0ZXIoZnVuY3Rpb24oKSB7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMubm9kZVR5cGUgPT09IDE7XG4gICAgXHRcdH0pLmVhY2goJC5wcm94eShmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICAgIFx0XHRcdGl0ZW0gPSB0aGlzLnByZXBhcmUoaXRlbSk7XG4gICAgXHRcdFx0dGhpcy4kc3RhZ2UuYXBwZW5kKGl0ZW0pO1xuICAgIFx0XHRcdHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgXHRcdFx0dGhpcy5fbWVyZ2Vycy5wdXNoKGl0ZW0uZmluZCgnW2RhdGEtbWVyZ2VdJykuYWRkQmFjaygnW2RhdGEtbWVyZ2VdJykuYXR0cignZGF0YS1tZXJnZScpICogMSB8fCAxKTtcbiAgICBcdFx0fSwgdGhpcykpO1xuXG4gICAgXHRcdHRoaXMucmVzZXQodGhpcy5pc051bWVyaWModGhpcy5zZXR0aW5ncy5zdGFydFBvc2l0aW9uKSA/IHRoaXMuc2V0dGluZ3Muc3RhcnRQb3NpdGlvbiA6IDApO1xuXG4gICAgXHRcdHRoaXMuaW52YWxpZGF0ZSgnaXRlbXMnKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQWRkcyBhbiBpdGVtLlxuICAgIFx0ICogQHRvZG8gVXNlIGBpdGVtYCBpbnN0ZWFkIG9mIGBjb250ZW50YCBmb3IgdGhlIGV2ZW50IGFyZ3VtZW50cy5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8alF1ZXJ5fFN0cmluZ30gY29udGVudCAtIFRoZSBpdGVtIGNvbnRlbnQgdG8gYWRkLlxuICAgIFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgcmVsYXRpdmUgcG9zaXRpb24gYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBpdGVtIG90aGVyd2lzZSB0aGUgaXRlbSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbmQuXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY29udGVudCwgcG9zaXRpb24pIHtcbiAgICBcdFx0dmFyIGN1cnJlbnQgPSB0aGlzLnJlbGF0aXZlKHRoaXMuX2N1cnJlbnQpO1xuXG4gICAgXHRcdHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2l0ZW1zLmxlbmd0aCA6IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uLCB0cnVlKTtcbiAgICBcdFx0Y29udGVudCA9IGNvbnRlbnQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZW50IDogJChjb250ZW50KTtcblxuICAgIFx0XHR0aGlzLnRyaWdnZXIoJ2FkZCcsIHsgY29udGVudDogY29udGVudCwgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xuXG4gICAgXHRcdGNvbnRlbnQgPSB0aGlzLnByZXBhcmUoY29udGVudCk7XG5cbiAgICBcdFx0aWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMCB8fCBwb3NpdGlvbiA9PT0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgXHRcdFx0dGhpcy5faXRlbXMubGVuZ3RoID09PSAwICYmIHRoaXMuJHN0YWdlLmFwcGVuZChjb250ZW50KTtcbiAgICBcdFx0XHR0aGlzLl9pdGVtcy5sZW5ndGggIT09IDAgJiYgdGhpcy5faXRlbXNbcG9zaXRpb24gLSAxXS5hZnRlcihjb250ZW50KTtcbiAgICBcdFx0XHR0aGlzLl9pdGVtcy5wdXNoKGNvbnRlbnQpO1xuICAgIFx0XHRcdHRoaXMuX21lcmdlcnMucHVzaChjb250ZW50LmZpbmQoJ1tkYXRhLW1lcmdlXScpLmFkZEJhY2soJ1tkYXRhLW1lcmdlXScpLmF0dHIoJ2RhdGEtbWVyZ2UnKSAqIDEgfHwgMSk7XG4gICAgXHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0dGhpcy5faXRlbXNbcG9zaXRpb25dLmJlZm9yZShjb250ZW50KTtcbiAgICBcdFx0XHR0aGlzLl9pdGVtcy5zcGxpY2UocG9zaXRpb24sIDAsIGNvbnRlbnQpO1xuICAgIFx0XHRcdHRoaXMuX21lcmdlcnMuc3BsaWNlKHBvc2l0aW9uLCAwLCBjb250ZW50LmZpbmQoJ1tkYXRhLW1lcmdlXScpLmFkZEJhY2soJ1tkYXRhLW1lcmdlXScpLmF0dHIoJ2RhdGEtbWVyZ2UnKSAqIDEgfHwgMSk7XG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLl9pdGVtc1tjdXJyZW50XSAmJiB0aGlzLnJlc2V0KHRoaXMuX2l0ZW1zW2N1cnJlbnRdLmluZGV4KCkpO1xuXG4gICAgXHRcdHRoaXMuaW52YWxpZGF0ZSgnaXRlbXMnKTtcblxuICAgIFx0XHR0aGlzLnRyaWdnZXIoJ2FkZGVkJywgeyBjb250ZW50OiBjb250ZW50LCBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFJlbW92ZXMgYW4gaXRlbSBieSBpdHMgcG9zaXRpb24uXG4gICAgXHQgKiBAdG9kbyBVc2UgYGl0ZW1gIGluc3RlYWQgb2YgYGNvbnRlbnRgIGZvciB0aGUgZXZlbnQgYXJndW1lbnRzLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIHRvIHJlbW92ZS5cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgIFx0XHRwb3NpdGlvbiA9IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uLCB0cnVlKTtcblxuICAgIFx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgIFx0XHRcdHJldHVybjtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMudHJpZ2dlcigncmVtb3ZlJywgeyBjb250ZW50OiB0aGlzLl9pdGVtc1twb3NpdGlvbl0sIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcblxuICAgIFx0XHR0aGlzLl9pdGVtc1twb3NpdGlvbl0ucmVtb3ZlKCk7XG4gICAgXHRcdHRoaXMuX2l0ZW1zLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgXHRcdHRoaXMuX21lcmdlcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcblxuICAgIFx0XHR0aGlzLmludmFsaWRhdGUoJ2l0ZW1zJyk7XG5cbiAgICBcdFx0dGhpcy50cmlnZ2VyKCdyZW1vdmVkJywgeyBjb250ZW50OiBudWxsLCBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFByZWxvYWRzIGltYWdlcyB3aXRoIGF1dG8gd2lkdGguXG4gICAgXHQgKiBAdG9kbyBSZXBsYWNlIGJ5IGEgbW9yZSBnZW5lcmljIGFwcHJvYWNoXG4gICAgXHQgKiBAcHJvdGVjdGVkXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUucHJlbG9hZEF1dG9XaWR0aEltYWdlcyA9IGZ1bmN0aW9uKGltYWdlcykge1xuICAgIFx0XHRpbWFnZXMuZWFjaCgkLnByb3h5KGZ1bmN0aW9uKGksIGVsZW1lbnQpIHtcbiAgICBcdFx0XHR0aGlzLmVudGVyKCdwcmUtbG9hZGluZycpO1xuICAgIFx0XHRcdGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgIFx0XHRcdCQobmV3IEltYWdlKCkpLm9uZSgnbG9hZCcsICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0ZWxlbWVudC5hdHRyKCdzcmMnLCBlLnRhcmdldC5zcmMpO1xuICAgIFx0XHRcdFx0ZWxlbWVudC5jc3MoJ29wYWNpdHknLCAxKTtcbiAgICBcdFx0XHRcdHRoaXMubGVhdmUoJ3ByZS1sb2FkaW5nJyk7XG4gICAgXHRcdFx0XHQhdGhpcy5pcygncHJlLWxvYWRpbmcnKSAmJiAhdGhpcy5pcygnaW5pdGlhbGl6aW5nJykgJiYgdGhpcy5yZWZyZXNoKCk7XG4gICAgXHRcdFx0fSwgdGhpcykpLmF0dHIoJ3NyYycsIGVsZW1lbnQuYXR0cignc3JjJykgfHwgZWxlbWVudC5hdHRyKCdkYXRhLXNyYycpIHx8IGVsZW1lbnQuYXR0cignZGF0YS1zcmMtcmV0aW5hJykpO1xuICAgIFx0XHR9LCB0aGlzKSk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIERlc3Ryb3lzIHRoZSBjYXJvdXNlbC5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dGhpcy4kZWxlbWVudC5vZmYoJy5vd2wuY29yZScpO1xuICAgIFx0XHR0aGlzLiRzdGFnZS5vZmYoJy5vd2wuY29yZScpO1xuICAgIFx0XHQkKGRvY3VtZW50KS5vZmYoJy5vd2wuY29yZScpO1xuXG4gICAgXHRcdGlmICh0aGlzLnNldHRpbmdzLnJlc3BvbnNpdmUgIT09IGZhbHNlKSB7XG4gICAgXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVyKTtcbiAgICBcdFx0XHR0aGlzLm9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9oYW5kbGVycy5vblRocm90dGxlZFJlc2l6ZSk7XG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3BsdWdpbnMpIHtcbiAgICBcdFx0XHR0aGlzLl9wbHVnaW5zW2ldLmRlc3Ryb3koKTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuY2xvbmVkJykucmVtb3ZlKCk7XG5cbiAgICBcdFx0dGhpcy4kc3RhZ2UudW53cmFwKCk7XG4gICAgXHRcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuY29udGVudHMoKS51bndyYXAoKTtcbiAgICBcdFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS51bndyYXAoKTtcbiAgICBcdFx0dGhpcy4kc3RhZ2UucmVtb3ZlKCk7XG4gICAgXHRcdHRoaXMuJGVsZW1lbnRcbiAgICBcdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnJlZnJlc2hDbGFzcylcbiAgICBcdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcylcbiAgICBcdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRlZENsYXNzKVxuICAgIFx0XHRcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucnRsQ2xhc3MpXG4gICAgXHRcdFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5kcmFnQ2xhc3MpXG4gICAgXHRcdFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ncmFiQ2xhc3MpXG4gICAgXHRcdFx0LmF0dHIoJ2NsYXNzJywgdGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycpLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUNsYXNzICsgJy1cXFxcUytcXFxccycsICdnJyksICcnKSlcbiAgICBcdFx0XHQucmVtb3ZlRGF0YSgnb3dsLmNhcm91c2VsJyk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIE9wZXJhdG9ycyB0byBjYWxjdWxhdGUgcmlnaHQtdG8tbGVmdCBhbmQgbGVmdC10by1yaWdodC5cbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqIEBwYXJhbSB7TnVtYmVyfSBbYV0gLSBUaGUgbGVmdCBzaWRlIG9wZXJhbmQuXG4gICAgXHQgKiBAcGFyYW0ge1N0cmluZ30gW29dIC0gVGhlIG9wZXJhdG9yLlxuICAgIFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtiXSAtIFRoZSByaWdodCBzaWRlIG9wZXJhbmQuXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUub3AgPSBmdW5jdGlvbihhLCBvLCBiKSB7XG4gICAgXHRcdHZhciBydGwgPSB0aGlzLnNldHRpbmdzLnJ0bDtcbiAgICBcdFx0c3dpdGNoIChvKSB7XG4gICAgXHRcdFx0Y2FzZSAnPCc6XG4gICAgXHRcdFx0XHRyZXR1cm4gcnRsID8gYSA+IGIgOiBhIDwgYjtcbiAgICBcdFx0XHRjYXNlICc+JzpcbiAgICBcdFx0XHRcdHJldHVybiBydGwgPyBhIDwgYiA6IGEgPiBiO1xuICAgIFx0XHRcdGNhc2UgJz49JzpcbiAgICBcdFx0XHRcdHJldHVybiBydGwgPyBhIDw9IGIgOiBhID49IGI7XG4gICAgXHRcdFx0Y2FzZSAnPD0nOlxuICAgIFx0XHRcdFx0cmV0dXJuIHJ0bCA/IGEgPj0gYiA6IGEgPD0gYjtcbiAgICBcdFx0XHRkZWZhdWx0OlxuICAgIFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdH1cbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQXR0YWNoZXMgdG8gYW4gaW50ZXJuYWwgZXZlbnQuXG4gICAgXHQgKiBAcHJvdGVjdGVkXG4gICAgXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHNvdXJjZS5cbiAgICBcdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIFRoZSBldmVudCBuYW1lLlxuICAgIFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgaGFuZGxlciB0byBhdHRhY2guXG4gICAgXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmUgLSBXZXRoZXIgdGhlIGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkIGF0IHRoZSBjYXB0dXJpbmcgcGhhc2Ugb3Igbm90LlxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgXHRcdGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBcdFx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICBcdFx0fSBlbHNlIGlmIChlbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgXHRcdFx0ZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICBcdFx0fVxuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBEZXRhY2hlcyBmcm9tIGFuIGludGVybmFsIGV2ZW50LlxuICAgIFx0ICogQHByb3RlY3RlZFxuICAgIFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCBzb3VyY2UuXG4gICAgXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS5cbiAgICBcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGF0dGFjaGVkIGV2ZW50IGhhbmRsZXIgdG8gZGV0YWNoLlxuICAgIFx0ICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIC0gV2V0aGVyIHRoZSBhdHRhY2hlZCBldmVudCBoYW5kbGVyIHdhcyByZWdpc3RlcmVkIGFzIGEgY2FwdHVyaW5nIGxpc3RlbmVyIG9yIG5vdC5cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudCwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgICBcdFx0aWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIFx0XHRcdGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgIFx0XHR9IGVsc2UgaWYgKGVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcbiAgICBcdFx0XHRlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIFx0XHR9XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFRyaWdnZXJzIGEgcHVibGljIGV2ZW50LlxuICAgIFx0ICogQHRvZG8gUmVtb3ZlIGBzdGF0dXNgLCBgcmVsYXRlZFRhcmdldGAgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIGV2ZW50IG5hbWUuXG4gICAgXHQgKiBAcGFyYW0geyp9IFtkYXRhPW51bGxdIC0gVGhlIGV2ZW50IGRhdGEuXG4gICAgXHQgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVzcGFjZT1jYXJvdXNlbF0gLSBUaGUgZXZlbnQgbmFtZXNwYWNlLlxuICAgIFx0ICogQHBhcmFtIHtTdHJpbmd9IFtzdGF0ZV0gLSBUaGUgc3RhdGUgd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cbiAgICBcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VudGVyPWZhbHNlXSAtIEluZGljYXRlcyBpZiB0aGUgY2FsbCBlbnRlcnMgdGhlIHNwZWNpZmllZCBzdGF0ZSBvciBub3QuXG4gICAgXHQgKiBAcmV0dXJucyB7RXZlbnR9IC0gVGhlIGV2ZW50IGFyZ3VtZW50cy5cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgbmFtZXNwYWNlLCBzdGF0ZSwgZW50ZXIpIHtcbiAgICBcdFx0dmFyIHN0YXR1cyA9IHtcbiAgICBcdFx0XHRpdGVtOiB7IGNvdW50OiB0aGlzLl9pdGVtcy5sZW5ndGgsIGluZGV4OiB0aGlzLmN1cnJlbnQoKSB9XG4gICAgXHRcdH0sIGhhbmRsZXIgPSAkLmNhbWVsQ2FzZShcbiAgICBcdFx0XHQkLmdyZXAoWyAnb24nLCBuYW1lLCBuYW1lc3BhY2UgXSwgZnVuY3Rpb24odikgeyByZXR1cm4gdiB9KVxuICAgIFx0XHRcdFx0LmpvaW4oJy0nKS50b0xvd2VyQ2FzZSgpXG4gICAgXHRcdCksIGV2ZW50ID0gJC5FdmVudChcbiAgICBcdFx0XHRbIG5hbWUsICdvd2wnLCBuYW1lc3BhY2UgfHwgJ2Nhcm91c2VsJyBdLmpvaW4oJy4nKS50b0xvd2VyQ2FzZSgpLFxuICAgIFx0XHRcdCQuZXh0ZW5kKHsgcmVsYXRlZFRhcmdldDogdGhpcyB9LCBzdGF0dXMsIGRhdGEpXG4gICAgXHRcdCk7XG5cbiAgICBcdFx0aWYgKCF0aGlzLl9zdXByZXNzW25hbWVdKSB7XG4gICAgXHRcdFx0JC5lYWNoKHRoaXMuX3BsdWdpbnMsIGZ1bmN0aW9uKG5hbWUsIHBsdWdpbikge1xuICAgIFx0XHRcdFx0aWYgKHBsdWdpbi5vblRyaWdnZXIpIHtcbiAgICBcdFx0XHRcdFx0cGx1Z2luLm9uVHJpZ2dlcihldmVudCk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSk7XG5cbiAgICBcdFx0XHR0aGlzLnJlZ2lzdGVyKHsgdHlwZTogT3dsLlR5cGUuRXZlbnQsIG5hbWU6IG5hbWUgfSk7XG4gICAgXHRcdFx0dGhpcy4kZWxlbWVudC50cmlnZ2VyKGV2ZW50KTtcblxuICAgIFx0XHRcdGlmICh0aGlzLnNldHRpbmdzICYmIHR5cGVvZiB0aGlzLnNldHRpbmdzW2hhbmRsZXJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgXHRcdFx0XHR0aGlzLnNldHRpbmdzW2hhbmRsZXJdLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBldmVudDtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogRW50ZXJzIGEgc3RhdGUuXG4gICAgXHQgKiBAcGFyYW0gbmFtZSAtIFRoZSBzdGF0ZSBuYW1lLlxuICAgIFx0ICovXG4gICAgXHRPd2wucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIFx0XHQkLmVhY2goWyBuYW1lIF0uY29uY2F0KHRoaXMuX3N0YXRlcy50YWdzW25hbWVdIHx8IFtdKSwgJC5wcm94eShmdW5jdGlvbihpLCBuYW1lKSB7XG4gICAgXHRcdFx0aWYgKHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICBcdFx0XHRcdHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdID0gMDtcbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXSsrO1xuICAgIFx0XHR9LCB0aGlzKSk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIExlYXZlcyBhIHN0YXRlLlxuICAgIFx0ICogQHBhcmFtIG5hbWUgLSBUaGUgc3RhdGUgbmFtZS5cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBcdFx0JC5lYWNoKFsgbmFtZSBdLmNvbmNhdCh0aGlzLl9zdGF0ZXMudGFnc1tuYW1lXSB8fCBbXSksICQucHJveHkoZnVuY3Rpb24oaSwgbmFtZSkge1xuICAgIFx0XHRcdHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdLS07XG4gICAgXHRcdH0sIHRoaXMpKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogUmVnaXN0ZXJzIGFuIGV2ZW50IG9yIHN0YXRlLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBldmVudCBvciBzdGF0ZSB0byByZWdpc3Rlci5cbiAgICBcdCAqL1xuICAgIFx0T3dsLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIFx0XHRpZiAob2JqZWN0LnR5cGUgPT09IE93bC5UeXBlLkV2ZW50KSB7XG4gICAgXHRcdFx0aWYgKCEkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdKSB7XG4gICAgXHRcdFx0XHQkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdID0ge307XG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCEkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdLm93bCkge1xuICAgIFx0XHRcdFx0dmFyIF9kZWZhdWx0ID0gJC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXS5fZGVmYXVsdDtcbiAgICBcdFx0XHRcdCQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0uX2RlZmF1bHQgPSBmdW5jdGlvbihlKSB7XG4gICAgXHRcdFx0XHRcdGlmIChfZGVmYXVsdCAmJiBfZGVmYXVsdC5hcHBseSAmJiAoIWUubmFtZXNwYWNlIHx8IGUubmFtZXNwYWNlLmluZGV4T2YoJ293bCcpID09PSAtMSkpIHtcbiAgICBcdFx0XHRcdFx0XHRyZXR1cm4gX2RlZmF1bHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBcdFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0XHRyZXR1cm4gZS5uYW1lc3BhY2UgJiYgZS5uYW1lc3BhY2UuaW5kZXhPZignb3dsJykgPiAtMTtcbiAgICBcdFx0XHRcdH07XG4gICAgXHRcdFx0XHQkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdLm93bCA9IHRydWU7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9IGVsc2UgaWYgKG9iamVjdC50eXBlID09PSBPd2wuVHlwZS5TdGF0ZSkge1xuICAgIFx0XHRcdGlmICghdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdKSB7XG4gICAgXHRcdFx0XHR0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0gPSBvYmplY3QudGFncztcbiAgICBcdFx0XHR9IGVsc2Uge1xuICAgIFx0XHRcdFx0dGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdID0gdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdLmNvbmNhdChvYmplY3QudGFncyk7XG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdID0gJC5ncmVwKHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSwgJC5wcm94eShmdW5jdGlvbih0YWcsIGkpIHtcbiAgICBcdFx0XHRcdHJldHVybiAkLmluQXJyYXkodGFnLCB0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0pID09PSBpO1xuICAgIFx0XHRcdH0sIHRoaXMpKTtcbiAgICBcdFx0fVxuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBTdXBwcmVzc2VzIGV2ZW50cy5cbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IGV2ZW50cyAtIFRoZSBldmVudHMgdG8gc3VwcHJlc3MuXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUuc3VwcHJlc3MgPSBmdW5jdGlvbihldmVudHMpIHtcbiAgICBcdFx0JC5lYWNoKGV2ZW50cywgJC5wcm94eShmdW5jdGlvbihpbmRleCwgZXZlbnQpIHtcbiAgICBcdFx0XHR0aGlzLl9zdXByZXNzW2V2ZW50XSA9IHRydWU7XG4gICAgXHRcdH0sIHRoaXMpKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogUmVsZWFzZXMgc3VwcHJlc3NlZCBldmVudHMuXG4gICAgXHQgKiBAcHJvdGVjdGVkXG4gICAgXHQgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBldmVudHMgLSBUaGUgZXZlbnRzIHRvIHJlbGVhc2UuXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgIFx0XHQkLmVhY2goZXZlbnRzLCAkLnByb3h5KGZ1bmN0aW9uKGluZGV4LCBldmVudCkge1xuICAgIFx0XHRcdGRlbGV0ZSB0aGlzLl9zdXByZXNzW2V2ZW50XTtcbiAgICBcdFx0fSwgdGhpcykpO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBHZXRzIHVuaWZpZWQgcG9pbnRlciBjb29yZGluYXRlcyBmcm9tIGV2ZW50LlxuICAgIFx0ICogQHRvZG8gIzI2MVxuICAgIFx0ICogQHByb3RlY3RlZFxuICAgIFx0ICogQHBhcmFtIHtFdmVudH0gLSBUaGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50LlxuICAgIFx0ICogQHJldHVybnMge09iamVjdH0gLSBDb250YWlucyBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24uXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUucG9pbnRlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgXHRcdHZhciByZXN1bHQgPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcblxuICAgIFx0XHRldmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgXHRcdGV2ZW50ID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA/XG4gICAgXHRcdFx0ZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA/XG4gICAgXHRcdFx0XHRldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50O1xuXG4gICAgXHRcdGlmIChldmVudC5wYWdlWCkge1xuICAgIFx0XHRcdHJlc3VsdC54ID0gZXZlbnQucGFnZVg7XG4gICAgXHRcdFx0cmVzdWx0LnkgPSBldmVudC5wYWdlWTtcbiAgICBcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHRyZXN1bHQueCA9IGV2ZW50LmNsaWVudFg7XG4gICAgXHRcdFx0cmVzdWx0LnkgPSBldmVudC5jbGllbnRZO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBOdW1iZXIgb3Igc29tZXRoaW5nIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gYSBOdW1iZXJcbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xPYmplY3R8QXJyYXl8Qm9vbGVhbnxSZWdFeHB8RnVuY3Rpb258U3ltYm9sfSAtIFRoZSBpbnB1dCB0byBiZSB0ZXN0ZWRcbiAgICBcdCAqIEByZXR1cm5zIHtCb29sZWFufSAtIEFuIGluZGljYXRpb24gaWYgdGhlIGlucHV0IGlzIGEgTnVtYmVyIG9yIGNhbiBiZSBjb2VyY2VkIHRvIGEgTnVtYmVyXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUuaXNOdW1lcmljID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgXHRcdHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChudW1iZXIpKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogR2V0cyB0aGUgZGlmZmVyZW5jZSBvZiB0d28gdmVjdG9ycy5cbiAgICBcdCAqIEB0b2RvICMyNjFcbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqIEBwYXJhbSB7T2JqZWN0fSAtIFRoZSBmaXJzdCB2ZWN0b3IuXG4gICAgXHQgKiBAcGFyYW0ge09iamVjdH0gLSBUaGUgc2Vjb25kIHZlY3Rvci5cbiAgICBcdCAqIEByZXR1cm5zIHtPYmplY3R9IC0gVGhlIGRpZmZlcmVuY2UuXG4gICAgXHQgKi9cbiAgICBcdE93bC5wcm90b3R5cGUuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBcdFx0cmV0dXJuIHtcbiAgICBcdFx0XHR4OiBmaXJzdC54IC0gc2Vjb25kLngsXG4gICAgXHRcdFx0eTogZmlyc3QueSAtIHNlY29uZC55XG4gICAgXHRcdH07XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFRoZSBqUXVlcnkgUGx1Z2luIGZvciB0aGUgT3dsIENhcm91c2VsXG4gICAgXHQgKiBAdG9kbyBOYXZpZ2F0aW9uIHBsdWdpbiBgbmV4dGAgYW5kIGBwcmV2YFxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICovXG4gICAgXHQkLmZuLm93bENhcm91c2VsID0gZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIFx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgXHRcdFx0XHRkYXRhID0gJHRoaXMuZGF0YSgnb3dsLmNhcm91c2VsJyk7XG5cbiAgICBcdFx0XHRpZiAoIWRhdGEpIHtcbiAgICBcdFx0XHRcdGRhdGEgPSBuZXcgT3dsKHRoaXMsIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKTtcbiAgICBcdFx0XHRcdCR0aGlzLmRhdGEoJ293bC5jYXJvdXNlbCcsIGRhdGEpO1xuXG4gICAgXHRcdFx0XHQkLmVhY2goW1xuICAgIFx0XHRcdFx0XHQnbmV4dCcsICdwcmV2JywgJ3RvJywgJ2Rlc3Ryb3knLCAncmVmcmVzaCcsICdyZXBsYWNlJywgJ2FkZCcsICdyZW1vdmUnXG4gICAgXHRcdFx0XHRdLCBmdW5jdGlvbihpLCBldmVudCkge1xuICAgIFx0XHRcdFx0XHRkYXRhLnJlZ2lzdGVyKHsgdHlwZTogT3dsLlR5cGUuRXZlbnQsIG5hbWU6IGV2ZW50IH0pO1xuICAgIFx0XHRcdFx0XHRkYXRhLiRlbGVtZW50Lm9uKGV2ZW50ICsgJy5vd2wuY2Fyb3VzZWwuY29yZScsICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnJlbGF0ZWRUYXJnZXQgIT09IHRoaXMpIHtcbiAgICBcdFx0XHRcdFx0XHRcdHRoaXMuc3VwcHJlc3MoWyBldmVudCBdKTtcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGFbZXZlbnRdLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgXHRcdFx0XHRcdFx0XHR0aGlzLnJlbGVhc2UoWyBldmVudCBdKTtcbiAgICBcdFx0XHRcdFx0XHR9XG4gICAgXHRcdFx0XHRcdH0sIGRhdGEpKTtcbiAgICBcdFx0XHRcdH0pO1xuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnICYmIG9wdGlvbi5jaGFyQXQoMCkgIT09ICdfJykge1xuICAgIFx0XHRcdFx0ZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fSk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIGpRdWVyeSBQbHVnaW5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqL1xuICAgIFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3RvciA9IE93bDtcblxuICAgIH0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcbiAgICAoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQ3JlYXRlcyB0aGUgYXV0byByZWZyZXNoIHBsdWdpbi5cbiAgICBcdCAqIEBjbGFzcyBUaGUgQXV0byBSZWZyZXNoIFBsdWdpblxuICAgIFx0ICogQHBhcmFtIHtPd2x9IGNhcm91c2VsIC0gVGhlIE93bCBDYXJvdXNlbFxuICAgIFx0ICovXG4gICAgXHR2YXIgQXV0b1JlZnJlc2ggPSBmdW5jdGlvbihjYXJvdXNlbCkge1xuICAgIFx0XHQvKipcbiAgICBcdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxuICAgIFx0XHQgKiBAcHJvdGVjdGVkXG4gICAgXHRcdCAqIEB0eXBlIHtPd2x9XG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIFJlZnJlc2ggaW50ZXJ2YWwuXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICogQHR5cGUge251bWJlcn1cbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX2ludGVydmFsID0gbnVsbDtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogV2hldGhlciB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgdmlzaWJsZSBvciBub3QuXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICogQHR5cGUge0Jvb2xlYW59XG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl92aXNpYmxlID0gbnVsbDtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogQWxsIGV2ZW50IGhhbmRsZXJzLlxuICAgIFx0XHQgKiBAcHJvdGVjdGVkXG4gICAgXHRcdCAqIEB0eXBlIHtPYmplY3R9XG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl9oYW5kbGVycyA9IHtcbiAgICBcdFx0XHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvUmVmcmVzaCkge1xuICAgIFx0XHRcdFx0XHR0aGlzLndhdGNoKCk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcylcbiAgICBcdFx0fTtcblxuICAgIFx0XHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgXHRcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBdXRvUmVmcmVzaC5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcblxuICAgIFx0XHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICAgIFx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogRGVmYXVsdCBvcHRpb25zLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICovXG4gICAgXHRBdXRvUmVmcmVzaC5EZWZhdWx0cyA9IHtcbiAgICBcdFx0YXV0b1JlZnJlc2g6IHRydWUsXG4gICAgXHRcdGF1dG9SZWZyZXNoSW50ZXJ2YWw6IDUwMFxuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBXYXRjaGVzIHRoZSBlbGVtZW50LlxuICAgIFx0ICovXG4gICAgXHRBdXRvUmVmcmVzaC5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICBcdFx0aWYgKHRoaXMuX2ludGVydmFsKSB7XG4gICAgXHRcdFx0cmV0dXJuO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5fdmlzaWJsZSA9IHRoaXMuX2NvcmUuaXNWaXNpYmxlKCk7XG4gICAgXHRcdHRoaXMuX2ludGVydmFsID0gd2luZG93LnNldEludGVydmFsKCQucHJveHkodGhpcy5yZWZyZXNoLCB0aGlzKSwgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvUmVmcmVzaEludGVydmFsKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogUmVmcmVzaGVzIHRoZSBlbGVtZW50LlxuICAgIFx0ICovXG4gICAgXHRBdXRvUmVmcmVzaC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIFx0XHRpZiAodGhpcy5fY29yZS5pc1Zpc2libGUoKSA9PT0gdGhpcy5fdmlzaWJsZSkge1xuICAgIFx0XHRcdHJldHVybjtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuX3Zpc2libGUgPSAhdGhpcy5fdmlzaWJsZTtcblxuICAgIFx0XHR0aGlzLl9jb3JlLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCdvd2wtaGlkZGVuJywgIXRoaXMuX3Zpc2libGUpO1xuXG4gICAgXHRcdHRoaXMuX3Zpc2libGUgJiYgKHRoaXMuX2NvcmUuaW52YWxpZGF0ZSgnd2lkdGgnKSAmJiB0aGlzLl9jb3JlLnJlZnJlc2goKSk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXG4gICAgXHQgKi9cbiAgICBcdEF1dG9SZWZyZXNoLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgXHRcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcblxuICAgIFx0XHR3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG5cbiAgICBcdFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XG4gICAgXHRcdFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xuICAgIFx0XHR9XG4gICAgXHRcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcbiAgICBcdFx0XHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcbiAgICBcdFx0fVxuICAgIFx0fTtcblxuICAgIFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkF1dG9SZWZyZXNoID0gQXV0b1JlZnJlc2g7XG5cbiAgICB9KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG4gICAgKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXG4gICAgXHQvKipcbiAgICBcdCAqIENyZWF0ZXMgdGhlIGxhenkgcGx1Z2luLlxuICAgIFx0ICogQGNsYXNzIFRoZSBMYXp5IFBsdWdpblxuICAgIFx0ICogQHBhcmFtIHtPd2x9IGNhcm91c2VsIC0gVGhlIE93bCBDYXJvdXNlbFxuICAgIFx0ICovXG4gICAgXHR2YXIgTGF6eSA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKiBAdHlwZSB7T3dsfVxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBBbHJlYWR5IGxvYWRlZCBpdGVtcy5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKiBAdHlwZSB7QXJyYXkuPGpRdWVyeT59XG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl9sb2FkZWQgPSBbXTtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogRXZlbnQgaGFuZGxlcnMuXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICogQHR5cGUge09iamVjdH1cbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX2hhbmRsZXJzID0ge1xuICAgIFx0XHRcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwgY2hhbmdlLm93bC5jYXJvdXNlbCByZXNpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0aWYgKCFlLm5hbWVzcGFjZSkge1xuICAgIFx0XHRcdFx0XHRyZXR1cm47XG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGlmICghdGhpcy5fY29yZS5zZXR0aW5ncyB8fCAhdGhpcy5fY29yZS5zZXR0aW5ncy5sYXp5TG9hZCkge1xuICAgIFx0XHRcdFx0XHRyZXR1cm47XG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGlmICgoZS5wcm9wZXJ0eSAmJiBlLnByb3BlcnR5Lm5hbWUgPT0gJ3Bvc2l0aW9uJykgfHwgZS50eXBlID09ICdpbml0aWFsaXplZCcpIHtcbiAgICBcdFx0XHRcdFx0dmFyIHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcbiAgICBcdFx0XHRcdFx0XHRuID0gKHNldHRpbmdzLmNlbnRlciAmJiBNYXRoLmNlaWwoc2V0dGluZ3MuaXRlbXMgLyAyKSB8fCBzZXR0aW5ncy5pdGVtcyksXG4gICAgXHRcdFx0XHRcdFx0aSA9ICgoc2V0dGluZ3MuY2VudGVyICYmIG4gKiAtMSkgfHwgMCksXG4gICAgXHRcdFx0XHRcdFx0cG9zaXRpb24gPSAoZS5wcm9wZXJ0eSAmJiBlLnByb3BlcnR5LnZhbHVlICE9PSB1bmRlZmluZWQgPyBlLnByb3BlcnR5LnZhbHVlIDogdGhpcy5fY29yZS5jdXJyZW50KCkpICsgaSxcbiAgICBcdFx0XHRcdFx0XHRjbG9uZXMgPSB0aGlzLl9jb3JlLmNsb25lcygpLmxlbmd0aCxcbiAgICBcdFx0XHRcdFx0XHRsb2FkID0gJC5wcm94eShmdW5jdGlvbihpLCB2KSB7IHRoaXMubG9hZCh2KTsgfSwgdGhpcyk7XG4gICAgXHRcdFx0XHRcdC8vVE9ETzogTmVlZCBkb2N1bWVudGF0aW9uIGZvciB0aGlzIG5ldyBvcHRpb25cbiAgICBcdFx0XHRcdFx0aWYgKHNldHRpbmdzLmxhenlMb2FkRWFnZXIgPiAwKSB7XG4gICAgXHRcdFx0XHRcdFx0biArPSBzZXR0aW5ncy5sYXp5TG9hZEVhZ2VyO1xuICAgIFx0XHRcdFx0XHRcdC8vIElmIHRoZSBjYXJvdXNlbCBpcyBsb29waW5nIGFsc28gcHJlbG9hZCBpbWFnZXMgdGhhdCBhcmUgdG8gdGhlIFwibGVmdFwiXG4gICAgXHRcdFx0XHRcdFx0aWYgKHNldHRpbmdzLmxvb3ApIHtcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzLmxhenlMb2FkRWFnZXI7XG4gICAgICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICAgICAgfVxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0d2hpbGUgKGkrKyA8IG4pIHtcbiAgICBcdFx0XHRcdFx0XHR0aGlzLmxvYWQoY2xvbmVzIC8gMiArIHRoaXMuX2NvcmUucmVsYXRpdmUocG9zaXRpb24pKTtcbiAgICBcdFx0XHRcdFx0XHRjbG9uZXMgJiYgJC5lYWNoKHRoaXMuX2NvcmUuY2xvbmVzKHRoaXMuX2NvcmUucmVsYXRpdmUocG9zaXRpb24pKSwgbG9hZCk7XG4gICAgXHRcdFx0XHRcdFx0cG9zaXRpb24rKztcbiAgICBcdFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpXG4gICAgXHRcdH07XG5cbiAgICBcdFx0Ly8gc2V0IHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICBcdFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIExhenkuRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XG5cbiAgICBcdFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlclxuICAgIFx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogRGVmYXVsdCBvcHRpb25zLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICovXG4gICAgXHRMYXp5LkRlZmF1bHRzID0ge1xuICAgIFx0XHRsYXp5TG9hZDogZmFsc2UsXG4gICAgXHRcdGxhenlMb2FkRWFnZXI6IDBcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogTG9hZHMgYWxsIHJlc291cmNlcyBvZiBhbiBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAgXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXG4gICAgXHQgKiBAcHJvdGVjdGVkXG4gICAgXHQgKi9cbiAgICBcdExhenkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgIFx0XHR2YXIgJGl0ZW0gPSB0aGlzLl9jb3JlLiRzdGFnZS5jaGlsZHJlbigpLmVxKHBvc2l0aW9uKSxcbiAgICBcdFx0XHQkZWxlbWVudHMgPSAkaXRlbSAmJiAkaXRlbS5maW5kKCcub3dsLWxhenknKTtcblxuICAgIFx0XHRpZiAoISRlbGVtZW50cyB8fCAkLmluQXJyYXkoJGl0ZW0uZ2V0KDApLCB0aGlzLl9sb2FkZWQpID4gLTEpIHtcbiAgICBcdFx0XHRyZXR1cm47XG4gICAgXHRcdH1cblxuICAgIFx0XHQkZWxlbWVudHMuZWFjaCgkLnByb3h5KGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgXHRcdFx0dmFyICRlbGVtZW50ID0gJChlbGVtZW50KSwgaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDEgJiYgJGVsZW1lbnQuYXR0cignZGF0YS1zcmMtcmV0aW5hJykpIHx8ICRlbGVtZW50LmF0dHIoJ2RhdGEtc3JjJykgfHwgJGVsZW1lbnQuYXR0cignZGF0YS1zcmNzZXQnKTtcblxuICAgIFx0XHRcdHRoaXMuX2NvcmUudHJpZ2dlcignbG9hZCcsIHsgZWxlbWVudDogJGVsZW1lbnQsIHVybDogdXJsIH0sICdsYXp5Jyk7XG5cbiAgICBcdFx0XHRpZiAoJGVsZW1lbnQuaXMoJ2ltZycpKSB7XG4gICAgXHRcdFx0XHQkZWxlbWVudC5vbmUoJ2xvYWQub3dsLmxhenknLCAkLnByb3h5KGZ1bmN0aW9uKCkge1xuICAgIFx0XHRcdFx0XHQkZWxlbWVudC5jc3MoJ29wYWNpdHknLCAxKTtcbiAgICBcdFx0XHRcdFx0dGhpcy5fY29yZS50cmlnZ2VyKCdsb2FkZWQnLCB7IGVsZW1lbnQ6ICRlbGVtZW50LCB1cmw6IHVybCB9LCAnbGF6eScpO1xuICAgIFx0XHRcdFx0fSwgdGhpcykpLmF0dHIoJ3NyYycsIHVybCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkZWxlbWVudC5pcygnc291cmNlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQub25lKCdsb2FkLm93bC5sYXp5JywgJC5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcmUudHJpZ2dlcignbG9hZGVkJywgeyBlbGVtZW50OiAkZWxlbWVudCwgdXJsOiB1cmwgfSwgJ2xhenknKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpLmF0dHIoJ3NyY3NldCcsIHVybCk7XG4gICAgXHRcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHRcdGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgXHRcdFx0XHRpbWFnZS5vbmxvYWQgPSAkLnByb3h5KGZ1bmN0aW9uKCkge1xuICAgIFx0XHRcdFx0XHQkZWxlbWVudC5jc3Moe1xuICAgIFx0XHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybChcIicgKyB1cmwgKyAnXCIpJyxcbiAgICBcdFx0XHRcdFx0XHQnb3BhY2l0eSc6ICcxJ1xuICAgIFx0XHRcdFx0XHR9KTtcbiAgICBcdFx0XHRcdFx0dGhpcy5fY29yZS50cmlnZ2VyKCdsb2FkZWQnLCB7IGVsZW1lbnQ6ICRlbGVtZW50LCB1cmw6IHVybCB9LCAnbGF6eScpO1xuICAgIFx0XHRcdFx0fSwgdGhpcyk7XG4gICAgXHRcdFx0XHRpbWFnZS5zcmMgPSB1cmw7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9LCB0aGlzKSk7XG5cbiAgICBcdFx0dGhpcy5fbG9hZGVkLnB1c2goJGl0ZW0uZ2V0KDApKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogRGVzdHJveXMgdGhlIHBsdWdpbi5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqL1xuICAgIFx0TGF6eS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIFx0XHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XG5cbiAgICBcdFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuaGFuZGxlcnMpIHtcbiAgICBcdFx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLmhhbmRsZXJzW2hhbmRsZXJdKTtcbiAgICBcdFx0fVxuICAgIFx0XHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG4gICAgXHRcdFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XG4gICAgXHRcdH1cbiAgICBcdH07XG5cbiAgICBcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5MYXp5ID0gTGF6eTtcblxuICAgIH0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcbiAgICAoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQ3JlYXRlcyB0aGUgYXV0byBoZWlnaHQgcGx1Z2luLlxuICAgIFx0ICogQGNsYXNzIFRoZSBBdXRvIEhlaWdodCBQbHVnaW5cbiAgICBcdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcbiAgICBcdCAqL1xuICAgIFx0dmFyIEF1dG9IZWlnaHQgPSBmdW5jdGlvbihjYXJvdXNlbCkge1xuICAgIFx0XHQvKipcbiAgICBcdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxuICAgIFx0XHQgKiBAcHJvdGVjdGVkXG4gICAgXHRcdCAqIEB0eXBlIHtPd2x9XG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XG5cbiAgICBcdFx0dGhpcy5fcHJldmlvdXNIZWlnaHQgPSBudWxsO1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICogQHR5cGUge09iamVjdH1cbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX2hhbmRsZXJzID0ge1xuICAgIFx0XHRcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwgcmVmcmVzaGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodCkge1xuICAgIFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpLFxuICAgIFx0XHRcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodCAmJiBlLnByb3BlcnR5Lm5hbWUgPT09ICdwb3NpdGlvbicpe1xuICAgIFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpLFxuICAgIFx0XHRcdCdsb2FkZWQub3dsLmxhenknOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICBcdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHRcbiAgICBcdFx0XHRcdFx0JiYgZS5lbGVtZW50LmNsb3Nlc3QoJy4nICsgdGhpcy5fY29yZS5zZXR0aW5ncy5pdGVtQ2xhc3MpLmluZGV4KCkgPT09IHRoaXMuX2NvcmUuY3VycmVudCgpKSB7XG4gICAgXHRcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcylcbiAgICBcdFx0fTtcblxuICAgIFx0XHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgXHRcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBdXRvSGVpZ2h0LkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xuXG4gICAgXHRcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gICAgXHRcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xuICAgIFx0XHR0aGlzLl9pbnRlcnZhbElkID0gbnVsbDtcbiAgICBcdFx0dmFyIHJlZlRoaXMgPSB0aGlzO1xuXG4gICAgXHRcdC8vIFRoZXNlIGNoYW5nZXMgaGF2ZSBiZWVuIHRha2VuIGZyb20gYSBQUiBieSBnYXZyb2NoZWxlZ25vdSBwcm9wb3NlZCBpbiAjMTU3NVxuICAgIFx0XHQvLyBhbmQgaGF2ZSBiZWVuIG1hZGUgY29tcGF0aWJsZSB3aXRoIHRoZSBsYXRlc3QgalF1ZXJ5IHZlcnNpb25cbiAgICBcdFx0JCh3aW5kb3cpLm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgXHRcdFx0aWYgKHJlZlRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodCkge1xuICAgIFx0XHRcdFx0cmVmVGhpcy51cGRhdGUoKTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdH0pO1xuXG4gICAgXHRcdC8vIEF1dG9yZXNpemUgdGhlIGhlaWdodCBvZiB0aGUgY2Fyb3VzZWwgd2hlbiB3aW5kb3cgaXMgcmVzaXplZFxuICAgIFx0XHQvLyBXaGVuIGNhcm91c2VsIGhhcyBpbWFnZXMsIHRoZSBoZWlnaHQgaXMgZGVwZW5kZW50IG9uIHRoZSB3aWR0aFxuICAgIFx0XHQvLyBhbmQgc2hvdWxkIGFsc28gY2hhbmdlIG9uIHJlc2l6ZVxuICAgIFx0XHQkKHdpbmRvdykucmVzaXplKGZ1bmN0aW9uKCkge1xuICAgIFx0XHRcdGlmIChyZWZUaGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHQpIHtcbiAgICBcdFx0XHRcdGlmIChyZWZUaGlzLl9pbnRlcnZhbElkICE9IG51bGwpIHtcbiAgICBcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHJlZlRoaXMuX2ludGVydmFsSWQpO1xuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRyZWZUaGlzLl9pbnRlcnZhbElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBcdFx0XHRcdFx0cmVmVGhpcy51cGRhdGUoKTtcbiAgICBcdFx0XHRcdH0sIDI1MCk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9KTtcblxuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBEZWZhdWx0IG9wdGlvbnMuXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKi9cbiAgICBcdEF1dG9IZWlnaHQuRGVmYXVsdHMgPSB7XG4gICAgXHRcdGF1dG9IZWlnaHQ6IGZhbHNlLFxuICAgIFx0XHRhdXRvSGVpZ2h0Q2xhc3M6ICdvd2wtaGVpZ2h0J1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBVcGRhdGVzIHRoZSB2aWV3LlxuICAgIFx0ICovXG4gICAgXHRBdXRvSGVpZ2h0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBcdFx0dmFyIHN0YXJ0ID0gdGhpcy5fY29yZS5fY3VycmVudCxcbiAgICBcdFx0XHRlbmQgPSBzdGFydCArIHRoaXMuX2NvcmUuc2V0dGluZ3MuaXRlbXMsXG4gICAgXHRcdFx0bGF6eUxvYWRFbmFibGVkID0gdGhpcy5fY29yZS5zZXR0aW5ncy5sYXp5TG9hZCxcbiAgICBcdFx0XHR2aXNpYmxlID0gdGhpcy5fY29yZS4kc3RhZ2UuY2hpbGRyZW4oKS50b0FycmF5KCkuc2xpY2Uoc3RhcnQsIGVuZCksXG4gICAgXHRcdFx0aGVpZ2h0cyA9IFtdLFxuICAgIFx0XHRcdG1heGhlaWdodCA9IDA7XG5cbiAgICBcdFx0JC5lYWNoKHZpc2libGUsIGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG4gICAgXHRcdFx0aGVpZ2h0cy5wdXNoKCQoaXRlbSkuaGVpZ2h0KCkpO1xuICAgIFx0XHR9KTtcblxuICAgIFx0XHRtYXhoZWlnaHQgPSBNYXRoLm1heC5hcHBseShudWxsLCBoZWlnaHRzKTtcblxuICAgIFx0XHRpZiAobWF4aGVpZ2h0IDw9IDEgJiYgbGF6eUxvYWRFbmFibGVkICYmIHRoaXMuX3ByZXZpb3VzSGVpZ2h0KSB7XG4gICAgXHRcdFx0bWF4aGVpZ2h0ID0gdGhpcy5fcHJldmlvdXNIZWlnaHQ7XG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLl9wcmV2aW91c0hlaWdodCA9IG1heGhlaWdodDtcblxuICAgIFx0XHR0aGlzLl9jb3JlLiRzdGFnZS5wYXJlbnQoKVxuICAgIFx0XHRcdC5oZWlnaHQobWF4aGVpZ2h0KVxuICAgIFx0XHRcdC5hZGRDbGFzcyh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHRDbGFzcyk7XG4gICAgXHR9O1xuXG4gICAgXHRBdXRvSGVpZ2h0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgXHRcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcblxuICAgIFx0XHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcbiAgICBcdFx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XG4gICAgXHRcdH1cbiAgICBcdFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xuICAgIFx0XHRcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcbiAgICBcdFx0fVxuICAgIFx0fTtcblxuICAgIFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkF1dG9IZWlnaHQgPSBBdXRvSGVpZ2h0O1xuXG4gICAgfSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xuICAgIChmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBDcmVhdGVzIHRoZSB2aWRlbyBwbHVnaW4uXG4gICAgXHQgKiBAY2xhc3MgVGhlIFZpZGVvIFBsdWdpblxuICAgIFx0ICogQHBhcmFtIHtPd2x9IGNhcm91c2VsIC0gVGhlIE93bCBDYXJvdXNlbFxuICAgIFx0ICovXG4gICAgXHR2YXIgVmlkZW8gPSBmdW5jdGlvbihjYXJvdXNlbCkge1xuICAgIFx0XHQvKipcbiAgICBcdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxuICAgIFx0XHQgKiBAcHJvdGVjdGVkXG4gICAgXHRcdCAqIEB0eXBlIHtPd2x9XG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIENhY2hlIGFsbCB2aWRlbyBVUkxzLlxuICAgIFx0XHQgKiBAcHJvdGVjdGVkXG4gICAgXHRcdCAqIEB0eXBlIHtPYmplY3R9XG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl92aWRlb3MgPSB7fTtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogQ3VycmVudCBwbGF5aW5nIGl0ZW0uXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICogQHR5cGUge2pRdWVyeX1cbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX3BsYXlpbmcgPSBudWxsO1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXG4gICAgXHRcdCAqIEB0b2RvIFRoZSBjbG9uZWQgY29udGVudCByZW1vdmFsZSBpcyB0b28gbGF0ZVxuICAgIFx0XHQgKiBAcHJvdGVjdGVkXG4gICAgXHRcdCAqIEB0eXBlIHtPYmplY3R9XG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl9oYW5kbGVycyA9IHtcbiAgICBcdFx0XHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UpIHtcbiAgICBcdFx0XHRcdFx0dGhpcy5fY29yZS5yZWdpc3Rlcih7IHR5cGU6ICdzdGF0ZScsIG5hbWU6ICdwbGF5aW5nJywgdGFnczogWyAnaW50ZXJhY3RpbmcnIF0gfSk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcyksXG4gICAgXHRcdFx0J3Jlc2l6ZS5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICBcdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLnZpZGVvICYmIHRoaXMuaXNJbkZ1bGxTY3JlZW4oKSkge1xuICAgIFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcyksXG4gICAgXHRcdFx0J3JlZnJlc2hlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICBcdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLmlzKCdyZXNpemluZycpKSB7XG4gICAgXHRcdFx0XHRcdHRoaXMuX2NvcmUuJHN0YWdlLmZpbmQoJy5jbG9uZWQgLm93bC12aWRlby1mcmFtZScpLnJlbW92ZSgpO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpLFxuICAgIFx0XHRcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PT0gJ3Bvc2l0aW9uJyAmJiB0aGlzLl9wbGF5aW5nKSB7XG4gICAgXHRcdFx0XHRcdHRoaXMuc3RvcCgpO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpLFxuICAgIFx0XHRcdCdwcmVwYXJlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICBcdFx0XHRcdGlmICghZS5uYW1lc3BhY2UpIHtcbiAgICBcdFx0XHRcdFx0cmV0dXJuO1xuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR2YXIgJGVsZW1lbnQgPSAkKGUuY29udGVudCkuZmluZCgnLm93bC12aWRlbycpO1xuXG4gICAgXHRcdFx0XHRpZiAoJGVsZW1lbnQubGVuZ3RoKSB7XG4gICAgXHRcdFx0XHRcdCRlbGVtZW50LmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgXHRcdFx0XHRcdHRoaXMuZmV0Y2goJGVsZW1lbnQsICQoZS5jb250ZW50KSk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcylcbiAgICBcdFx0fTtcblxuICAgIFx0XHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgXHRcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBWaWRlby5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcblxuICAgIFx0XHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICAgIFx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcblxuICAgIFx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKCdjbGljay5vd2wudmlkZW8nLCAnLm93bC12aWRlby1wbGF5LWljb24nLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICBcdFx0XHR0aGlzLnBsYXkoZSk7XG4gICAgXHRcdH0sIHRoaXMpKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogRGVmYXVsdCBvcHRpb25zLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICovXG4gICAgXHRWaWRlby5EZWZhdWx0cyA9IHtcbiAgICBcdFx0dmlkZW86IGZhbHNlLFxuICAgIFx0XHR2aWRlb0hlaWdodDogZmFsc2UsXG4gICAgXHRcdHZpZGVvV2lkdGg6IGZhbHNlXG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIEdldHMgdGhlIHZpZGVvIElEIGFuZCB0aGUgdHlwZSAoWW91VHViZS9WaW1lby92emFhciBvbmx5KS5cbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqIEBwYXJhbSB7alF1ZXJ5fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IGNvbnRhaW5pbmcgdGhlIHZpZGVvIGRhdGEuXG4gICAgXHQgKiBAcGFyYW0ge2pRdWVyeX0gaXRlbSAtIFRoZSBpdGVtIGNvbnRhaW5pbmcgdGhlIHZpZGVvLlxuICAgIFx0ICovXG4gICAgXHRWaWRlby5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbih0YXJnZXQsIGl0ZW0pIHtcbiAgICBcdFx0XHR2YXIgdHlwZSA9IChmdW5jdGlvbigpIHtcbiAgICBcdFx0XHRcdFx0aWYgKHRhcmdldC5hdHRyKCdkYXRhLXZpbWVvLWlkJykpIHtcbiAgICBcdFx0XHRcdFx0XHRyZXR1cm4gJ3ZpbWVvJztcbiAgICBcdFx0XHRcdFx0fSBlbHNlIGlmICh0YXJnZXQuYXR0cignZGF0YS12emFhci1pZCcpKSB7XG4gICAgXHRcdFx0XHRcdFx0cmV0dXJuICd2emFhcidcbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHRcdFx0XHRyZXR1cm4gJ3lvdXR1YmUnO1xuICAgIFx0XHRcdFx0XHR9XG4gICAgXHRcdFx0XHR9KSgpLFxuICAgIFx0XHRcdFx0aWQgPSB0YXJnZXQuYXR0cignZGF0YS12aW1lby1pZCcpIHx8IHRhcmdldC5hdHRyKCdkYXRhLXlvdXR1YmUtaWQnKSB8fCB0YXJnZXQuYXR0cignZGF0YS12emFhci1pZCcpLFxuICAgIFx0XHRcdFx0d2lkdGggPSB0YXJnZXQuYXR0cignZGF0YS13aWR0aCcpIHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MudmlkZW9XaWR0aCxcbiAgICBcdFx0XHRcdGhlaWdodCA9IHRhcmdldC5hdHRyKCdkYXRhLWhlaWdodCcpIHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MudmlkZW9IZWlnaHQsXG4gICAgXHRcdFx0XHR1cmwgPSB0YXJnZXQuYXR0cignaHJlZicpO1xuXG4gICAgXHRcdGlmICh1cmwpIHtcblxuICAgIFx0XHRcdC8qXG4gICAgXHRcdFx0XHRcdFBhcnNlcyB0aGUgaWQncyBvdXQgb2YgdGhlIGZvbGxvd2luZyB1cmxzIChhbmQgcHJvYmFibHkgbW9yZSk6XG4gICAgXHRcdFx0XHRcdGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9OmlkXG4gICAgXHRcdFx0XHRcdGh0dHBzOi8veW91dHUuYmUvOmlkXG4gICAgXHRcdFx0XHRcdGh0dHBzOi8vdmltZW8uY29tLzppZFxuICAgIFx0XHRcdFx0XHRodHRwczovL3ZpbWVvLmNvbS9jaGFubmVscy86Y2hhbm5lbC86aWRcbiAgICBcdFx0XHRcdFx0aHR0cHM6Ly92aW1lby5jb20vZ3JvdXBzLzpncm91cC92aWRlb3MvOmlkXG4gICAgXHRcdFx0XHRcdGh0dHBzOi8vYXBwLnZ6YWFyLmNvbS92aWRlb3MvOmlkXG5cbiAgICBcdFx0XHRcdFx0VmlzdWFsIGV4YW1wbGU6IGh0dHBzOi8vcmVnZXhwZXIuY29tLyMoaHR0cCUzQSU3Q2h0dHBzJTNBJTdDKSU1QyUyRiU1QyUyRihwbGF5ZXIuJTdDd3d3LiU3Q2FwcC4pJTNGKHZpbWVvJTVDLmNvbSU3Q3lvdXR1KGJlJTVDLmNvbSU3QyU1Qy5iZSU3Q2JlJTVDLmdvb2dsZWFwaXMlNUMuY29tKSU3Q3Z6YWFyJTVDLmNvbSklNUMlMkYodmlkZW8lNUMlMkYlN0N2aWRlb3MlNUMlMkYlN0NlbWJlZCU1QyUyRiU3Q2NoYW5uZWxzJTVDJTJGLiUyQiU1QyUyRiU3Q2dyb3VwcyU1QyUyRi4lMkIlNUMlMkYlN0N3YXRjaCU1QyUzRnYlM0QlN0N2JTVDJTJGKSUzRiglNUJBLVphLXowLTkuXyUyNS0lNUQqKSglNUMlMjYlNUNTJTJCKSUzRlxuICAgIFx0XHRcdCovXG5cbiAgICBcdFx0XHRpZCA9IHVybC5tYXRjaCgvKGh0dHA6fGh0dHBzOnwpXFwvXFwvKHBsYXllci58d3d3LnxhcHAuKT8odmltZW9cXC5jb218eW91dHUoYmVcXC5jb218XFwuYmV8YmVcXC5nb29nbGVhcGlzXFwuY29tfGJlXFwtbm9jb29raWVcXC5jb20pfHZ6YWFyXFwuY29tKVxcLyh2aWRlb1xcL3x2aWRlb3NcXC98ZW1iZWRcXC98Y2hhbm5lbHNcXC8uK1xcL3xncm91cHNcXC8uK1xcL3x3YXRjaFxcP3Y9fHZcXC8pPyhbQS1aYS16MC05Ll8lLV0qKShcXCZcXFMrKT8vKTtcblxuICAgIFx0XHRcdGlmIChpZFszXS5pbmRleE9mKCd5b3V0dScpID4gLTEpIHtcbiAgICBcdFx0XHRcdHR5cGUgPSAneW91dHViZSc7XG4gICAgXHRcdFx0fSBlbHNlIGlmIChpZFszXS5pbmRleE9mKCd2aW1lbycpID4gLTEpIHtcbiAgICBcdFx0XHRcdHR5cGUgPSAndmltZW8nO1xuICAgIFx0XHRcdH0gZWxzZSBpZiAoaWRbM10uaW5kZXhPZigndnphYXInKSA+IC0xKSB7XG4gICAgXHRcdFx0XHR0eXBlID0gJ3Z6YWFyJztcbiAgICBcdFx0XHR9IGVsc2Uge1xuICAgIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdWaWRlbyBVUkwgbm90IHN1cHBvcnRlZC4nKTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdFx0aWQgPSBpZFs2XTtcbiAgICBcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmlkZW8gVVJMLicpO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5fdmlkZW9zW3VybF0gPSB7XG4gICAgXHRcdFx0dHlwZTogdHlwZSxcbiAgICBcdFx0XHRpZDogaWQsXG4gICAgXHRcdFx0d2lkdGg6IHdpZHRoLFxuICAgIFx0XHRcdGhlaWdodDogaGVpZ2h0XG4gICAgXHRcdH07XG5cbiAgICBcdFx0aXRlbS5hdHRyKCdkYXRhLXZpZGVvJywgdXJsKTtcblxuICAgIFx0XHR0aGlzLnRodW1ibmFpbCh0YXJnZXQsIHRoaXMuX3ZpZGVvc1t1cmxdKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQ3JlYXRlcyB2aWRlbyB0aHVtYm5haWwuXG4gICAgXHQgKiBAcHJvdGVjdGVkXG4gICAgXHQgKiBAcGFyYW0ge2pRdWVyeX0gdGFyZ2V0IC0gVGhlIHRhcmdldCBjb250YWluaW5nIHRoZSB2aWRlbyBkYXRhLlxuICAgIFx0ICogQHBhcmFtIHtPYmplY3R9IGluZm8gLSBUaGUgdmlkZW8gaW5mbyBvYmplY3QuXG4gICAgXHQgKiBAc2VlIGBmZXRjaGBcbiAgICBcdCAqL1xuICAgIFx0VmlkZW8ucHJvdG90eXBlLnRodW1ibmFpbCA9IGZ1bmN0aW9uKHRhcmdldCwgdmlkZW8pIHtcbiAgICBcdFx0dmFyIHRuTGluayxcbiAgICBcdFx0XHRpY29uLFxuICAgIFx0XHRcdHBhdGgsXG4gICAgXHRcdFx0ZGltZW5zaW9ucyA9IHZpZGVvLndpZHRoICYmIHZpZGVvLmhlaWdodCA/ICd3aWR0aDonICsgdmlkZW8ud2lkdGggKyAncHg7aGVpZ2h0OicgKyB2aWRlby5oZWlnaHQgKyAncHg7JyA6ICcnLFxuICAgIFx0XHRcdGN1c3RvbVRuID0gdGFyZ2V0LmZpbmQoJ2ltZycpLFxuICAgIFx0XHRcdHNyY1R5cGUgPSAnc3JjJyxcbiAgICBcdFx0XHRsYXp5Q2xhc3MgPSAnJyxcbiAgICBcdFx0XHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXG4gICAgXHRcdFx0Y3JlYXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIFx0XHRcdFx0aWNvbiA9ICc8ZGl2IGNsYXNzPVwib3dsLXZpZGVvLXBsYXktaWNvblwiPjwvZGl2Pic7XG5cbiAgICBcdFx0XHRcdGlmIChzZXR0aW5ncy5sYXp5TG9hZCkge1xuICAgIFx0XHRcdFx0XHR0bkxpbmsgPSAkKCc8ZGl2Lz4nLHtcbiAgICBcdFx0XHRcdFx0XHRcImNsYXNzXCI6ICdvd2wtdmlkZW8tdG4gJyArIGxhenlDbGFzcyxcbiAgICBcdFx0XHRcdFx0XHRcInNyY1R5cGVcIjogcGF0aFxuICAgIFx0XHRcdFx0XHR9KTtcbiAgICBcdFx0XHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0XHRcdHRuTGluayA9ICQoICc8ZGl2Lz4nLCB7XG4gICAgXHRcdFx0XHRcdFx0XCJjbGFzc1wiOiBcIm93bC12aWRlby10blwiLFxuICAgIFx0XHRcdFx0XHRcdFwic3R5bGVcIjogJ29wYWNpdHk6MTtiYWNrZ3JvdW5kLWltYWdlOnVybCgnICsgcGF0aCArICcpJ1xuICAgIFx0XHRcdFx0XHR9KTtcbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHRcdHRhcmdldC5hZnRlcih0bkxpbmspO1xuICAgIFx0XHRcdFx0dGFyZ2V0LmFmdGVyKGljb24pO1xuICAgIFx0XHRcdH07XG5cbiAgICBcdFx0Ly8gd3JhcCB2aWRlbyBjb250ZW50IGludG8gb3dsLXZpZGVvLXdyYXBwZXIgZGl2XG4gICAgXHRcdHRhcmdldC53cmFwKCAkKCAnPGRpdi8+Jywge1xuICAgIFx0XHRcdFwiY2xhc3NcIjogXCJvd2wtdmlkZW8td3JhcHBlclwiLFxuICAgIFx0XHRcdFwic3R5bGVcIjogZGltZW5zaW9uc1xuICAgIFx0XHR9KSk7XG5cbiAgICBcdFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MubGF6eUxvYWQpIHtcbiAgICBcdFx0XHRzcmNUeXBlID0gJ2RhdGEtc3JjJztcbiAgICBcdFx0XHRsYXp5Q2xhc3MgPSAnb3dsLWxhenknO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gY3VzdG9tIHRodW1ibmFpbFxuICAgIFx0XHRpZiAoY3VzdG9tVG4ubGVuZ3RoKSB7XG4gICAgXHRcdFx0Y3JlYXRlKGN1c3RvbVRuLmF0dHIoc3JjVHlwZSkpO1xuICAgIFx0XHRcdGN1c3RvbVRuLnJlbW92ZSgpO1xuICAgIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICh2aWRlby50eXBlID09PSAneW91dHViZScpIHtcbiAgICBcdFx0XHRwYXRoID0gXCIvL2ltZy55b3V0dWJlLmNvbS92aS9cIiArIHZpZGVvLmlkICsgXCIvaHFkZWZhdWx0LmpwZ1wiO1xuICAgIFx0XHRcdGNyZWF0ZShwYXRoKTtcbiAgICBcdFx0fSBlbHNlIGlmICh2aWRlby50eXBlID09PSAndmltZW8nKSB7XG4gICAgXHRcdFx0JC5hamF4KHtcbiAgICBcdFx0XHRcdHR5cGU6ICdHRVQnLFxuICAgIFx0XHRcdFx0dXJsOiAnLy92aW1lby5jb20vYXBpL3YyL3ZpZGVvLycgKyB2aWRlby5pZCArICcuanNvbicsXG4gICAgXHRcdFx0XHRqc29ucDogJ2NhbGxiYWNrJyxcbiAgICBcdFx0XHRcdGRhdGFUeXBlOiAnanNvbnAnLFxuICAgIFx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgIFx0XHRcdFx0XHRwYXRoID0gZGF0YVswXS50aHVtYm5haWxfbGFyZ2U7XG4gICAgXHRcdFx0XHRcdGNyZWF0ZShwYXRoKTtcbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHR9KTtcbiAgICBcdFx0fSBlbHNlIGlmICh2aWRlby50eXBlID09PSAndnphYXInKSB7XG4gICAgXHRcdFx0JC5hamF4KHtcbiAgICBcdFx0XHRcdHR5cGU6ICdHRVQnLFxuICAgIFx0XHRcdFx0dXJsOiAnLy92emFhci5jb20vYXBpL3ZpZGVvcy8nICsgdmlkZW8uaWQgKyAnLmpzb24nLFxuICAgIFx0XHRcdFx0anNvbnA6ICdjYWxsYmFjaycsXG4gICAgXHRcdFx0XHRkYXRhVHlwZTogJ2pzb25wJyxcbiAgICBcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBcdFx0XHRcdFx0cGF0aCA9IGRhdGEuZnJhbWVncmFiX3VybDtcbiAgICBcdFx0XHRcdFx0Y3JlYXRlKHBhdGgpO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0pO1xuICAgIFx0XHR9XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFN0b3BzIHRoZSBjdXJyZW50IHZpZGVvLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICovXG4gICAgXHRWaWRlby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIFx0XHR0aGlzLl9jb3JlLnRyaWdnZXIoJ3N0b3AnLCBudWxsLCAndmlkZW8nKTtcbiAgICBcdFx0dGhpcy5fcGxheWluZy5maW5kKCcub3dsLXZpZGVvLWZyYW1lJykucmVtb3ZlKCk7XG4gICAgXHRcdHRoaXMuX3BsYXlpbmcucmVtb3ZlQ2xhc3MoJ293bC12aWRlby1wbGF5aW5nJyk7XG4gICAgXHRcdHRoaXMuX3BsYXlpbmcgPSBudWxsO1xuICAgIFx0XHR0aGlzLl9jb3JlLmxlYXZlKCdwbGF5aW5nJyk7XG4gICAgXHRcdHRoaXMuX2NvcmUudHJpZ2dlcignc3RvcHBlZCcsIG51bGwsICd2aWRlbycpO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBTdGFydHMgdGhlIGN1cnJlbnQgdmlkZW8uXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXG4gICAgXHQgKi9cbiAgICBcdFZpZGVvLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBcdFx0dmFyIHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KSxcbiAgICBcdFx0XHRpdGVtID0gdGFyZ2V0LmNsb3Nlc3QoJy4nICsgdGhpcy5fY29yZS5zZXR0aW5ncy5pdGVtQ2xhc3MpLFxuICAgIFx0XHRcdHZpZGVvID0gdGhpcy5fdmlkZW9zW2l0ZW0uYXR0cignZGF0YS12aWRlbycpXSxcbiAgICBcdFx0XHR3aWR0aCA9IHZpZGVvLndpZHRoIHx8ICcxMDAlJyxcbiAgICBcdFx0XHRoZWlnaHQgPSB2aWRlby5oZWlnaHQgfHwgdGhpcy5fY29yZS4kc3RhZ2UuaGVpZ2h0KCksXG4gICAgXHRcdFx0aHRtbCxcbiAgICBcdFx0XHRpZnJhbWU7XG5cbiAgICBcdFx0aWYgKHRoaXMuX3BsYXlpbmcpIHtcbiAgICBcdFx0XHRyZXR1cm47XG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLl9jb3JlLmVudGVyKCdwbGF5aW5nJyk7XG4gICAgXHRcdHRoaXMuX2NvcmUudHJpZ2dlcigncGxheScsIG51bGwsICd2aWRlbycpO1xuXG4gICAgXHRcdGl0ZW0gPSB0aGlzLl9jb3JlLml0ZW1zKHRoaXMuX2NvcmUucmVsYXRpdmUoaXRlbS5pbmRleCgpKSk7XG5cbiAgICBcdFx0dGhpcy5fY29yZS5yZXNldChpdGVtLmluZGV4KCkpO1xuXG4gICAgXHRcdGh0bWwgPSAkKCAnPGlmcmFtZSBmcmFtZWJvcmRlcj1cIjBcIiBhbGxvd2Z1bGxzY3JlZW4gbW96YWxsb3dmdWxsc2NyZWVuIHdlYmtpdEFsbG93RnVsbFNjcmVlbiA+PC9pZnJhbWU+JyApO1xuICAgIFx0XHRodG1sLmF0dHIoICdoZWlnaHQnLCBoZWlnaHQgKTtcbiAgICBcdFx0aHRtbC5hdHRyKCAnd2lkdGgnLCB3aWR0aCApO1xuICAgIFx0XHRpZiAodmlkZW8udHlwZSA9PT0gJ3lvdXR1YmUnKSB7XG4gICAgXHRcdFx0aHRtbC5hdHRyKCAnc3JjJywgJy8vd3d3LnlvdXR1YmUuY29tL2VtYmVkLycgKyB2aWRlby5pZCArICc/YXV0b3BsYXk9MSZyZWw9MCZ2PScgKyB2aWRlby5pZCApO1xuICAgIFx0XHR9IGVsc2UgaWYgKHZpZGVvLnR5cGUgPT09ICd2aW1lbycpIHtcbiAgICBcdFx0XHRodG1sLmF0dHIoICdzcmMnLCAnLy9wbGF5ZXIudmltZW8uY29tL3ZpZGVvLycgKyB2aWRlby5pZCArICc/YXV0b3BsYXk9MScgKTtcbiAgICBcdFx0fSBlbHNlIGlmICh2aWRlby50eXBlID09PSAndnphYXInKSB7XG4gICAgXHRcdFx0aHRtbC5hdHRyKCAnc3JjJywgJy8vdmlldy52emFhci5jb20vJyArIHZpZGVvLmlkICsgJy9wbGF5ZXI/YXV0b3BsYXk9dHJ1ZScgKTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmcmFtZSA9ICQoaHRtbCkud3JhcCggJzxkaXYgY2xhc3M9XCJvd2wtdmlkZW8tZnJhbWVcIiAvPicgKS5pbnNlcnRBZnRlcihpdGVtLmZpbmQoJy5vd2wtdmlkZW8nKSk7XG5cbiAgICBcdFx0dGhpcy5fcGxheWluZyA9IGl0ZW0uYWRkQ2xhc3MoJ293bC12aWRlby1wbGF5aW5nJyk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIENoZWNrcyB3aGV0aGVyIGFuIHZpZGVvIGlzIGN1cnJlbnRseSBpbiBmdWxsIHNjcmVlbiBtb2RlIG9yIG5vdC5cbiAgICBcdCAqIEB0b2RvIEJhZCBzdHlsZSBiZWNhdXNlIGxvb2tzIGxpa2UgYSByZWFkb25seSBtZXRob2QgYnV0IGNoYW5nZXMgbWVtYmVycy5cbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgIFx0ICovXG4gICAgXHRWaWRlby5wcm90b3R5cGUuaXNJbkZ1bGxTY3JlZW4gPSBmdW5jdGlvbigpIHtcbiAgICBcdFx0dmFyIGVsZW1lbnQgPSBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fFxuICAgIFx0XHRcdFx0ZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQ7XG5cbiAgICBcdFx0cmV0dXJuIGVsZW1lbnQgJiYgJChlbGVtZW50KS5wYXJlbnQoKS5oYXNDbGFzcygnb3dsLXZpZGVvLWZyYW1lJyk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXG4gICAgXHQgKi9cbiAgICBcdFZpZGVvLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgXHRcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcblxuICAgIFx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZignY2xpY2sub3dsLnZpZGVvJyk7XG5cbiAgICBcdFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XG4gICAgXHRcdFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xuICAgIFx0XHR9XG4gICAgXHRcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcbiAgICBcdFx0XHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcbiAgICBcdFx0fVxuICAgIFx0fTtcblxuICAgIFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLlZpZGVvID0gVmlkZW87XG5cbiAgICB9KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG4gICAgKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXG4gICAgXHQvKipcbiAgICBcdCAqIENyZWF0ZXMgdGhlIGFuaW1hdGUgcGx1Z2luLlxuICAgIFx0ICogQGNsYXNzIFRoZSBOYXZpZ2F0aW9uIFBsdWdpblxuICAgIFx0ICogQHBhcmFtIHtPd2x9IHNjb3BlIC0gVGhlIE93bCBDYXJvdXNlbFxuICAgIFx0ICovXG4gICAgXHR2YXIgQW5pbWF0ZSA9IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgXHRcdHRoaXMuY29yZSA9IHNjb3BlO1xuICAgIFx0XHR0aGlzLmNvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBbmltYXRlLkRlZmF1bHRzLCB0aGlzLmNvcmUub3B0aW9ucyk7XG4gICAgXHRcdHRoaXMuc3dhcHBpbmcgPSB0cnVlO1xuICAgIFx0XHR0aGlzLnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgIFx0XHR0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG5cbiAgICBcdFx0dGhpcy5oYW5kbGVycyA9IHtcbiAgICBcdFx0XHQnY2hhbmdlLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PSAncG9zaXRpb24nKSB7XG4gICAgXHRcdFx0XHRcdHRoaXMucHJldmlvdXMgPSB0aGlzLmNvcmUuY3VycmVudCgpO1xuICAgIFx0XHRcdFx0XHR0aGlzLm5leHQgPSBlLnByb3BlcnR5LnZhbHVlO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpLFxuICAgIFx0XHRcdCdkcmFnLm93bC5jYXJvdXNlbCBkcmFnZ2VkLm93bC5jYXJvdXNlbCB0cmFuc2xhdGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0aWYgKGUubmFtZXNwYWNlKSB7XG4gICAgXHRcdFx0XHRcdHRoaXMuc3dhcHBpbmcgPSBlLnR5cGUgPT0gJ3RyYW5zbGF0ZWQnO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpLFxuICAgIFx0XHRcdCd0cmFuc2xhdGUub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5zd2FwcGluZyAmJiAodGhpcy5jb3JlLm9wdGlvbnMuYW5pbWF0ZU91dCB8fCB0aGlzLmNvcmUub3B0aW9ucy5hbmltYXRlSW4pKSB7XG4gICAgXHRcdFx0XHRcdHRoaXMuc3dhcCgpO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpXG4gICAgXHRcdH07XG5cbiAgICBcdFx0dGhpcy5jb3JlLiRlbGVtZW50Lm9uKHRoaXMuaGFuZGxlcnMpO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBEZWZhdWx0IG9wdGlvbnMuXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKi9cbiAgICBcdEFuaW1hdGUuRGVmYXVsdHMgPSB7XG4gICAgXHRcdGFuaW1hdGVPdXQ6IGZhbHNlLFxuICAgIFx0XHRhbmltYXRlSW46IGZhbHNlXG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFRvZ2dsZXMgdGhlIGFuaW1hdGlvbiBjbGFzc2VzIHdoZW5ldmVyIGFuIHRyYW5zbGF0aW9ucyBzdGFydHMuXG4gICAgXHQgKiBAcHJvdGVjdGVkXG4gICAgXHQgKiBAcmV0dXJucyB7Qm9vbGVhbnx1bmRlZmluZWR9XG4gICAgXHQgKi9cbiAgICBcdEFuaW1hdGUucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRpZiAodGhpcy5jb3JlLnNldHRpbmdzLml0ZW1zICE9PSAxKSB7XG4gICAgXHRcdFx0cmV0dXJuO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCEkLnN1cHBvcnQuYW5pbWF0aW9uIHx8ICEkLnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgIFx0XHRcdHJldHVybjtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuY29yZS5zcGVlZCgwKTtcblxuICAgIFx0XHR2YXIgbGVmdCxcbiAgICBcdFx0XHRjbGVhciA9ICQucHJveHkodGhpcy5jbGVhciwgdGhpcyksXG4gICAgXHRcdFx0cHJldmlvdXMgPSB0aGlzLmNvcmUuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5wcmV2aW91cyksXG4gICAgXHRcdFx0bmV4dCA9IHRoaXMuY29yZS4kc3RhZ2UuY2hpbGRyZW4oKS5lcSh0aGlzLm5leHQpLFxuICAgIFx0XHRcdGluY29taW5nID0gdGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVJbixcbiAgICBcdFx0XHRvdXRnb2luZyA9IHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlT3V0O1xuXG4gICAgXHRcdGlmICh0aGlzLmNvcmUuY3VycmVudCgpID09PSB0aGlzLnByZXZpb3VzKSB7XG4gICAgXHRcdFx0cmV0dXJuO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKG91dGdvaW5nKSB7XG4gICAgXHRcdFx0bGVmdCA9IHRoaXMuY29yZS5jb29yZGluYXRlcyh0aGlzLnByZXZpb3VzKSAtIHRoaXMuY29yZS5jb29yZGluYXRlcyh0aGlzLm5leHQpO1xuICAgIFx0XHRcdHByZXZpb3VzLm9uZSgkLnN1cHBvcnQuYW5pbWF0aW9uLmVuZCwgY2xlYXIpXG4gICAgXHRcdFx0XHQuY3NzKCB7ICdsZWZ0JzogbGVmdCArICdweCcgfSApXG4gICAgXHRcdFx0XHQuYWRkQ2xhc3MoJ2FuaW1hdGVkIG93bC1hbmltYXRlZC1vdXQnKVxuICAgIFx0XHRcdFx0LmFkZENsYXNzKG91dGdvaW5nKTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmIChpbmNvbWluZykge1xuICAgIFx0XHRcdG5leHQub25lKCQuc3VwcG9ydC5hbmltYXRpb24uZW5kLCBjbGVhcilcbiAgICBcdFx0XHRcdC5hZGRDbGFzcygnYW5pbWF0ZWQgb3dsLWFuaW1hdGVkLWluJylcbiAgICBcdFx0XHRcdC5hZGRDbGFzcyhpbmNvbWluZyk7XG4gICAgXHRcdH1cbiAgICBcdH07XG5cbiAgICBcdEFuaW1hdGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oZSkge1xuICAgIFx0XHQkKGUudGFyZ2V0KS5jc3MoIHsgJ2xlZnQnOiAnJyB9IClcbiAgICBcdFx0XHQucmVtb3ZlQ2xhc3MoJ2FuaW1hdGVkIG93bC1hbmltYXRlZC1vdXQgb3dsLWFuaW1hdGVkLWluJylcbiAgICBcdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVJbilcbiAgICBcdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVPdXQpO1xuICAgIFx0XHR0aGlzLmNvcmUub25UcmFuc2l0aW9uRW5kKCk7XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKi9cbiAgICBcdEFuaW1hdGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICBcdFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xuXG4gICAgXHRcdGZvciAoaGFuZGxlciBpbiB0aGlzLmhhbmRsZXJzKSB7XG4gICAgXHRcdFx0dGhpcy5jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLmhhbmRsZXJzW2hhbmRsZXJdKTtcbiAgICBcdFx0fVxuICAgIFx0XHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG4gICAgXHRcdFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XG4gICAgXHRcdH1cbiAgICBcdH07XG5cbiAgICBcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5BbmltYXRlID0gQW5pbWF0ZTtcblxuICAgIH0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcbiAgICAoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cbiAgICBcdC8qKlxuICAgIFx0ICogQ3JlYXRlcyB0aGUgYXV0b3BsYXkgcGx1Z2luLlxuICAgIFx0ICogQGNsYXNzIFRoZSBBdXRvcGxheSBQbHVnaW5cbiAgICBcdCAqIEBwYXJhbSB7T3dsfSBzY29wZSAtIFRoZSBPd2wgQ2Fyb3VzZWxcbiAgICBcdCAqL1xuICAgIFx0dmFyIEF1dG9wbGF5ID0gZnVuY3Rpb24oY2Fyb3VzZWwpIHtcbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKiBAdHlwZSB7T3dsfVxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBUaGUgYXV0b3BsYXkgdGltZW91dCBpZC5cbiAgICBcdFx0ICogQHR5cGUge051bWJlcn1cbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX2NhbGwgPSBudWxsO1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBEZXBlbmRpbmcgb24gdGhlIHN0YXRlIG9mIHRoZSBwbHVnaW4sIHRoaXMgdmFyaWFibGUgY29udGFpbnMgZWl0aGVyXG4gICAgXHRcdCAqIHRoZSBzdGFydCB0aW1lIG9mIHRoZSB0aW1lciBvciB0aGUgY3VycmVudCB0aW1lciB2YWx1ZSBpZiBpdCdzXG4gICAgXHRcdCAqIHBhdXNlZC4gU2luY2Ugd2Ugc3RhcnQgaW4gYSBwYXVzZWQgc3RhdGUgd2UgaW5pdGlhbGl6ZSB0aGUgdGltZXJcbiAgICBcdFx0ICogdmFsdWUuXG4gICAgXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl90aW1lID0gMDtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogU3RvcmVzIHRoZSB0aW1lb3V0IGN1cnJlbnRseSB1c2VkLlxuICAgIFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fdGltZW91dCA9IDA7XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIEluZGljYXRlcyB3aGVuZXZlciB0aGUgYXV0b3BsYXkgaXMgcGF1c2VkLlxuICAgIFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX3BhdXNlZCA9IHRydWU7XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIEFsbCBldmVudCBoYW5kbGVycy5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5faGFuZGxlcnMgPSB7XG4gICAgXHRcdFx0J2NoYW5nZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAnc2V0dGluZ3MnKSB7XG4gICAgXHRcdFx0XHRcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5KSB7XG4gICAgXHRcdFx0XHRcdFx0dGhpcy5wbGF5KCk7XG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0XHRcdFx0dGhpcy5zdG9wKCk7XG4gICAgXHRcdFx0XHRcdH1cbiAgICBcdFx0XHRcdH0gZWxzZSBpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAncG9zaXRpb24nICYmIHRoaXMuX3BhdXNlZCkge1xuICAgIFx0XHRcdFx0XHQvLyBSZXNldCB0aGUgdGltZXIuIFRoaXMgY29kZSBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgcG9zaXRpb25cbiAgICBcdFx0XHRcdFx0Ly8gb2YgdGhlIGNhcm91c2VsIHdhcyBjaGFuZ2VkIHRocm91Z2ggdXNlciBpbnRlcmFjdGlvbi5cbiAgICBcdFx0XHRcdFx0dGhpcy5fdGltZSA9IDA7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcyksXG4gICAgXHRcdFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcbiAgICBcdFx0XHRcdFx0dGhpcy5wbGF5KCk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcyksXG4gICAgXHRcdFx0J3BsYXkub3dsLmF1dG9wbGF5JzogJC5wcm94eShmdW5jdGlvbihlLCB0LCBzKSB7XG4gICAgXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UpIHtcbiAgICBcdFx0XHRcdFx0dGhpcy5wbGF5KHQsIHMpO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpLFxuICAgIFx0XHRcdCdzdG9wLm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0aWYgKGUubmFtZXNwYWNlKSB7XG4gICAgXHRcdFx0XHRcdHRoaXMuc3RvcCgpO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpLFxuICAgIFx0XHRcdCdtb3VzZW92ZXIub3dsLmF1dG9wbGF5JzogJC5wcm94eShmdW5jdGlvbigpIHtcbiAgICBcdFx0XHRcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSAmJiB0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XG4gICAgXHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHR9LCB0aGlzKSxcbiAgICBcdFx0XHQnbW91c2VsZWF2ZS5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uKCkge1xuICAgIFx0XHRcdFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlIb3ZlclBhdXNlICYmIHRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcbiAgICBcdFx0XHRcdFx0dGhpcy5wbGF5KCk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcyksXG4gICAgXHRcdFx0J3RvdWNoc3RhcnQub3dsLmNvcmUnOiAkLnByb3h5KGZ1bmN0aW9uKCkge1xuICAgIFx0XHRcdFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlIb3ZlclBhdXNlICYmIHRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcbiAgICBcdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpLFxuICAgIFx0XHRcdCd0b3VjaGVuZC5vd2wuY29yZSc6ICQucHJveHkoZnVuY3Rpb24oKSB7XG4gICAgXHRcdFx0XHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UpIHtcbiAgICBcdFx0XHRcdFx0dGhpcy5wbGF5KCk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcylcbiAgICBcdFx0fTtcblxuICAgIFx0XHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICAgIFx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcblxuICAgIFx0XHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgXHRcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBdXRvcGxheS5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogRGVmYXVsdCBvcHRpb25zLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICovXG4gICAgXHRBdXRvcGxheS5EZWZhdWx0cyA9IHtcbiAgICBcdFx0YXV0b3BsYXk6IGZhbHNlLFxuICAgIFx0XHRhdXRvcGxheVRpbWVvdXQ6IDUwMDAsXG4gICAgXHRcdGF1dG9wbGF5SG92ZXJQYXVzZTogZmFsc2UsXG4gICAgXHRcdGF1dG9wbGF5U3BlZWQ6IGZhbHNlXG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc2xpZGUgYW5kIHNldCBhIHRpbWVvdXQgZm9yIHRoZSBuZXh0IHRyYW5zaXRpb24uXG4gICAgXHQgKiBAcHJpdmF0ZVxuICAgIFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkIGZvciB0aGUgYW5pbWF0aW9ucy5cbiAgICBcdCAqL1xuICAgIFx0QXV0b3BsYXkucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24oc3BlZWQpIHtcbiAgICBcdFx0dGhpcy5fY2FsbCA9IHdpbmRvdy5zZXRUaW1lb3V0KFxuICAgIFx0XHRcdCQucHJveHkodGhpcy5fbmV4dCwgdGhpcywgc3BlZWQpLFxuICAgIFx0XHRcdHRoaXMuX3RpbWVvdXQgKiAoTWF0aC5yb3VuZCh0aGlzLnJlYWQoKSAvIHRoaXMuX3RpbWVvdXQpICsgMSkgLSB0aGlzLnJlYWQoKVxuICAgIFx0XHQpO1xuXG4gICAgXHRcdGlmICh0aGlzLl9jb3JlLmlzKCdpbnRlcmFjdGluZycpIHx8IGRvY3VtZW50LmhpZGRlbikge1xuICAgIFx0XHRcdHJldHVybjtcbiAgICBcdFx0fVxuICAgIFx0XHR0aGlzLl9jb3JlLm5leHQoc3BlZWQgfHwgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheVNwZWVkKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogUmVhZHMgdGhlIGN1cnJlbnQgdGltZXIgdmFsdWUgd2hlbiB0aGUgdGltZXIgaXMgcGxheWluZy5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqL1xuICAgIFx0QXV0b3BsYXkucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbigpIHtcbiAgICBcdFx0cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fdGltZTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogU3RhcnRzIHRoZSBhdXRvcGxheS5cbiAgICBcdCAqIEBwdWJsaWNcbiAgICBcdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW91dF0gLSBUaGUgaW50ZXJ2YWwgYmVmb3JlIHRoZSBuZXh0IGFuaW1hdGlvbiBzdGFydHMuXG4gICAgXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSBhbmltYXRpb24gc3BlZWQgZm9yIHRoZSBhbmltYXRpb25zLlxuICAgIFx0ICovXG4gICAgXHRBdXRvcGxheS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHRpbWVvdXQsIHNwZWVkKSB7XG4gICAgXHRcdHZhciBlbGFwc2VkO1xuXG4gICAgXHRcdGlmICghdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xuICAgIFx0XHRcdHRoaXMuX2NvcmUuZW50ZXIoJ3JvdGF0aW5nJyk7XG4gICAgXHRcdH1cblxuICAgIFx0XHR0aW1lb3V0ID0gdGltZW91dCB8fCB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5VGltZW91dDtcblxuICAgIFx0XHQvLyBDYWxjdWxhdGUgdGhlIGVsYXBzZWQgdGltZSBzaW5jZSB0aGUgbGFzdCB0cmFuc2l0aW9uLiBJZiB0aGUgY2Fyb3VzZWxcbiAgICBcdFx0Ly8gd2Fzbid0IHBsYXlpbmcgdGhpcyBjYWxjdWxhdGlvbiB3aWxsIHlpZWxkIHplcm8uXG4gICAgXHRcdGVsYXBzZWQgPSBNYXRoLm1pbih0aGlzLl90aW1lICUgKHRoaXMuX3RpbWVvdXQgfHwgdGltZW91dCksIHRpbWVvdXQpO1xuXG4gICAgXHRcdGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICBcdFx0XHQvLyBTdGFydCB0aGUgY2xvY2suXG4gICAgXHRcdFx0dGhpcy5fdGltZSA9IHRoaXMucmVhZCgpO1xuICAgIFx0XHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIFx0XHR9IGVsc2Uge1xuICAgIFx0XHRcdC8vIENsZWFyIHRoZSBhY3RpdmUgdGltZW91dCB0byBhbGxvdyByZXBsYWNlbWVudC5cbiAgICBcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2NhbGwpO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gQWRqdXN0IHRoZSBvcmlnaW4gb2YgdGhlIHRpbWVyIHRvIG1hdGNoIHRoZSBuZXcgdGltZW91dCB2YWx1ZS5cbiAgICBcdFx0dGhpcy5fdGltZSArPSB0aGlzLnJlYWQoKSAlIHRpbWVvdXQgLSBlbGFwc2VkO1xuXG4gICAgXHRcdHRoaXMuX3RpbWVvdXQgPSB0aW1lb3V0O1xuICAgIFx0XHR0aGlzLl9jYWxsID0gd2luZG93LnNldFRpbWVvdXQoJC5wcm94eSh0aGlzLl9uZXh0LCB0aGlzLCBzcGVlZCksIHRpbWVvdXQgLSBlbGFwc2VkKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogU3RvcHMgdGhlIGF1dG9wbGF5LlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICovXG4gICAgXHRBdXRvcGxheS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIFx0XHRpZiAodGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xuICAgIFx0XHRcdC8vIFJlc2V0IHRoZSBjbG9jay5cbiAgICBcdFx0XHR0aGlzLl90aW1lID0gMDtcbiAgICBcdFx0XHR0aGlzLl9wYXVzZWQgPSB0cnVlO1xuXG4gICAgXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9jYWxsKTtcbiAgICBcdFx0XHR0aGlzLl9jb3JlLmxlYXZlKCdyb3RhdGluZycpO1xuICAgIFx0XHR9XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFBhdXNlcyB0aGUgYXV0b3BsYXkuXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKi9cbiAgICBcdEF1dG9wbGF5LnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIFx0XHRpZiAodGhpcy5fY29yZS5pcygncm90YXRpbmcnKSAmJiAhdGhpcy5fcGF1c2VkKSB7XG4gICAgXHRcdFx0Ly8gUGF1c2UgdGhlIGNsb2NrLlxuICAgIFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLnJlYWQoKTtcbiAgICBcdFx0XHR0aGlzLl9wYXVzZWQgPSB0cnVlO1xuXG4gICAgXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9jYWxsKTtcbiAgICBcdFx0fVxuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxuICAgIFx0ICovXG4gICAgXHRBdXRvcGxheS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIFx0XHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XG5cbiAgICBcdFx0dGhpcy5zdG9wKCk7XG5cbiAgICBcdFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XG4gICAgXHRcdFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xuICAgIFx0XHR9XG4gICAgXHRcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcbiAgICBcdFx0XHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcbiAgICBcdFx0fVxuICAgIFx0fTtcblxuICAgIFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLmF1dG9wbGF5ID0gQXV0b3BsYXk7XG5cbiAgICB9KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG4gICAgKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXG4gICAgXHQvKipcbiAgICBcdCAqIENyZWF0ZXMgdGhlIG5hdmlnYXRpb24gcGx1Z2luLlxuICAgIFx0ICogQGNsYXNzIFRoZSBOYXZpZ2F0aW9uIFBsdWdpblxuICAgIFx0ICogQHBhcmFtIHtPd2x9IGNhcm91c2VsIC0gVGhlIE93bCBDYXJvdXNlbC5cbiAgICBcdCAqL1xuICAgIFx0dmFyIE5hdmlnYXRpb24gPSBmdW5jdGlvbihjYXJvdXNlbCkge1xuICAgIFx0XHQvKipcbiAgICBcdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxuICAgIFx0XHQgKiBAcHJvdGVjdGVkXG4gICAgXHRcdCAqIEB0eXBlIHtPd2x9XG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQgb3Igbm90LlxuICAgIFx0XHQgKiBAcHJvdGVjdGVkXG4gICAgXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogVGhlIGN1cnJlbnQgcGFnaW5nIGluZGV4ZXMuXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICogQHR5cGUge0FycmF5fVxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5fcGFnZXMgPSBbXTtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogQWxsIERPTSBlbGVtZW50cyBvZiB0aGUgdXNlciBpbnRlcmZhY2UuXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICogQHR5cGUge09iamVjdH1cbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX2NvbnRyb2xzID0ge307XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIE1hcmt1cCBmb3IgYW4gaW5kaWNhdG9yLlxuICAgIFx0XHQgKiBAcHJvdGVjdGVkXG4gICAgXHRcdCAqIEB0eXBlIHtBcnJheS48U3RyaW5nPn1cbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX3RlbXBsYXRlcyA9IFtdO1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBUaGUgY2Fyb3VzZWwgZWxlbWVudC5cbiAgICBcdFx0ICogQHR5cGUge2pRdWVyeX1cbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuJGVsZW1lbnQgPSB0aGlzLl9jb3JlLiRlbGVtZW50O1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBPdmVycmlkZGVuIG1ldGhvZHMgb2YgdGhlIGNhcm91c2VsLlxuICAgIFx0XHQgKiBAcHJvdGVjdGVkXG4gICAgXHRcdCAqIEB0eXBlIHtPYmplY3R9XG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl9vdmVycmlkZXMgPSB7XG4gICAgXHRcdFx0bmV4dDogdGhpcy5fY29yZS5uZXh0LFxuICAgIFx0XHRcdHByZXY6IHRoaXMuX2NvcmUucHJldixcbiAgICBcdFx0XHR0bzogdGhpcy5fY29yZS50b1xuICAgIFx0XHR9O1xuXG4gICAgXHRcdC8qKlxuICAgIFx0XHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXG4gICAgXHRcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdFx0ICogQHR5cGUge09iamVjdH1cbiAgICBcdFx0ICovXG4gICAgXHRcdHRoaXMuX2hhbmRsZXJzID0ge1xuICAgIFx0XHRcdCdwcmVwYXJlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICBcdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmRvdHNEYXRhKSB7XG4gICAgXHRcdFx0XHRcdHRoaXMuX3RlbXBsYXRlcy5wdXNoKCc8ZGl2IGNsYXNzPVwiJyArIHRoaXMuX2NvcmUuc2V0dGluZ3MuZG90Q2xhc3MgKyAnXCI+JyArXG4gICAgXHRcdFx0XHRcdFx0JChlLmNvbnRlbnQpLmZpbmQoJ1tkYXRhLWRvdF0nKS5hZGRCYWNrKCdbZGF0YS1kb3RdJykuYXR0cignZGF0YS1kb3QnKSArICc8L2Rpdj4nKTtcbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHR9LCB0aGlzKSxcbiAgICBcdFx0XHQnYWRkZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSkge1xuICAgIFx0XHRcdFx0XHR0aGlzLl90ZW1wbGF0ZXMuc3BsaWNlKGUucG9zaXRpb24sIDAsIHRoaXMuX3RlbXBsYXRlcy5wb3AoKSk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcyksXG4gICAgXHRcdFx0J3JlbW92ZS5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICBcdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmRvdHNEYXRhKSB7XG4gICAgXHRcdFx0XHRcdHRoaXMuX3RlbXBsYXRlcy5zcGxpY2UoZS5wb3NpdGlvbiwgMSk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcyksXG4gICAgXHRcdFx0J2NoYW5nZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09ICdwb3NpdGlvbicpIHtcbiAgICBcdFx0XHRcdFx0dGhpcy5kcmF3KCk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcyksXG4gICAgXHRcdFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmICF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgIFx0XHRcdFx0XHR0aGlzLl9jb3JlLnRyaWdnZXIoJ2luaXRpYWxpemUnLCBudWxsLCAnbmF2aWdhdGlvbicpO1xuICAgIFx0XHRcdFx0XHR0aGlzLmluaXRpYWxpemUoKTtcbiAgICBcdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcbiAgICBcdFx0XHRcdFx0dGhpcy5kcmF3KCk7XG4gICAgXHRcdFx0XHRcdHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBcdFx0XHRcdFx0dGhpcy5fY29yZS50cmlnZ2VyKCdpbml0aWFsaXplZCcsIG51bGwsICduYXZpZ2F0aW9uJyk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcyksXG4gICAgXHRcdFx0J3JlZnJlc2hlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICBcdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9pbml0aWFsaXplZCkge1xuICAgIFx0XHRcdFx0XHR0aGlzLl9jb3JlLnRyaWdnZXIoJ3JlZnJlc2gnLCBudWxsLCAnbmF2aWdhdGlvbicpO1xuICAgIFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuICAgIFx0XHRcdFx0XHR0aGlzLmRyYXcoKTtcbiAgICBcdFx0XHRcdFx0dGhpcy5fY29yZS50cmlnZ2VyKCdyZWZyZXNoZWQnLCBudWxsLCAnbmF2aWdhdGlvbicpO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpXG4gICAgXHRcdH07XG5cbiAgICBcdFx0Ly8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIFx0XHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTmF2aWdhdGlvbi5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcblxuICAgIFx0XHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICAgIFx0XHR0aGlzLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogRGVmYXVsdCBvcHRpb25zLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICogQHRvZG8gUmVuYW1lIGBzbGlkZUJ5YCB0byBgbmF2QnlgXG4gICAgXHQgKi9cbiAgICBcdE5hdmlnYXRpb24uRGVmYXVsdHMgPSB7XG4gICAgXHRcdG5hdjogZmFsc2UsXG4gICAgXHRcdG5hdlRleHQ6IFtcbiAgICBcdFx0XHQnPHNwYW4gYXJpYS1sYWJlbD1cIicgKyAnUHJldmlvdXMnICsgJ1wiPiYjeDIwMzk7PC9zcGFuPicsXG4gICAgXHRcdFx0JzxzcGFuIGFyaWEtbGFiZWw9XCInICsgJ05leHQnICsgJ1wiPiYjeDIwM2E7PC9zcGFuPidcbiAgICBcdFx0XSxcbiAgICBcdFx0bmF2U3BlZWQ6IGZhbHNlLFxuICAgIFx0XHRuYXZFbGVtZW50OiAnYnV0dG9uIHR5cGU9XCJidXR0b25cIiByb2xlPVwicHJlc2VudGF0aW9uXCInLFxuICAgIFx0XHRuYXZDb250YWluZXI6IGZhbHNlLFxuICAgIFx0XHRuYXZDb250YWluZXJDbGFzczogJ293bC1uYXYnLFxuICAgIFx0XHRuYXZDbGFzczogW1xuICAgIFx0XHRcdCdvd2wtcHJldicsXG4gICAgXHRcdFx0J293bC1uZXh0J1xuICAgIFx0XHRdLFxuICAgIFx0XHRzbGlkZUJ5OiAxLFxuICAgIFx0XHRkb3RDbGFzczogJ293bC1kb3QnLFxuICAgIFx0XHRkb3RzQ2xhc3M6ICdvd2wtZG90cycsXG4gICAgXHRcdGRvdHM6IHRydWUsXG4gICAgXHRcdGRvdHNFYWNoOiBmYWxzZSxcbiAgICBcdFx0ZG90c0RhdGE6IGZhbHNlLFxuICAgIFx0XHRkb3RzU3BlZWQ6IGZhbHNlLFxuICAgIFx0XHRkb3RzQ29udGFpbmVyOiBmYWxzZVxuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBJbml0aWFsaXplcyB0aGUgbGF5b3V0IG9mIHRoZSBwbHVnaW4gYW5kIGV4dGVuZHMgdGhlIGNhcm91c2VsLlxuICAgIFx0ICogQHByb3RlY3RlZFxuICAgIFx0ICovXG4gICAgXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgXHRcdHZhciBvdmVycmlkZSxcbiAgICBcdFx0XHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XG5cbiAgICBcdFx0Ly8gY3JlYXRlIERPTSBzdHJ1Y3R1cmUgZm9yIHJlbGF0aXZlIG5hdmlnYXRpb25cbiAgICBcdFx0dGhpcy5fY29udHJvbHMuJHJlbGF0aXZlID0gKHNldHRpbmdzLm5hdkNvbnRhaW5lciA/ICQoc2V0dGluZ3MubmF2Q29udGFpbmVyKVxuICAgIFx0XHRcdDogJCgnPGRpdj4nKS5hZGRDbGFzcyhzZXR0aW5ncy5uYXZDb250YWluZXJDbGFzcykuYXBwZW5kVG8odGhpcy4kZWxlbWVudCkpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuXG4gICAgXHRcdHRoaXMuX2NvbnRyb2xzLiRwcmV2aW91cyA9ICQoJzwnICsgc2V0dGluZ3MubmF2RWxlbWVudCArICc+JylcbiAgICBcdFx0XHQuYWRkQ2xhc3Moc2V0dGluZ3MubmF2Q2xhc3NbMF0pXG4gICAgXHRcdFx0Lmh0bWwoc2V0dGluZ3MubmF2VGV4dFswXSlcbiAgICBcdFx0XHQucHJlcGVuZFRvKHRoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZSlcbiAgICBcdFx0XHQub24oJ2NsaWNrJywgJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgXHRcdFx0XHR0aGlzLnByZXYoc2V0dGluZ3MubmF2U3BlZWQpO1xuICAgIFx0XHRcdH0sIHRoaXMpKTtcbiAgICBcdFx0dGhpcy5fY29udHJvbHMuJG5leHQgPSAkKCc8JyArIHNldHRpbmdzLm5hdkVsZW1lbnQgKyAnPicpXG4gICAgXHRcdFx0LmFkZENsYXNzKHNldHRpbmdzLm5hdkNsYXNzWzFdKVxuICAgIFx0XHRcdC5odG1sKHNldHRpbmdzLm5hdlRleHRbMV0pXG4gICAgXHRcdFx0LmFwcGVuZFRvKHRoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZSlcbiAgICBcdFx0XHQub24oJ2NsaWNrJywgJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgXHRcdFx0XHR0aGlzLm5leHQoc2V0dGluZ3MubmF2U3BlZWQpO1xuICAgIFx0XHRcdH0sIHRoaXMpKTtcblxuICAgIFx0XHQvLyBjcmVhdGUgRE9NIHN0cnVjdHVyZSBmb3IgYWJzb2x1dGUgbmF2aWdhdGlvblxuICAgIFx0XHRpZiAoIXNldHRpbmdzLmRvdHNEYXRhKSB7XG4gICAgXHRcdFx0dGhpcy5fdGVtcGxhdGVzID0gWyAkKCc8YnV0dG9uIHJvbGU9XCJidXR0b25cIj4nKVxuICAgIFx0XHRcdFx0LmFkZENsYXNzKHNldHRpbmdzLmRvdENsYXNzKVxuICAgIFx0XHRcdFx0LmFwcGVuZCgkKCc8c3Bhbj4nKSlcbiAgICBcdFx0XHRcdC5wcm9wKCdvdXRlckhUTUwnKSBdO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlID0gKHNldHRpbmdzLmRvdHNDb250YWluZXIgPyAkKHNldHRpbmdzLmRvdHNDb250YWluZXIpXG4gICAgXHRcdFx0OiAkKCc8ZGl2PicpLmFkZENsYXNzKHNldHRpbmdzLmRvdHNDbGFzcykuYXBwZW5kVG8odGhpcy4kZWxlbWVudCkpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuXG4gICAgXHRcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5vbignY2xpY2snLCAnYnV0dG9uJywgJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgXHRcdFx0dmFyIGluZGV4ID0gJChlLnRhcmdldCkucGFyZW50KCkuaXModGhpcy5fY29udHJvbHMuJGFic29sdXRlKVxuICAgIFx0XHRcdFx0PyAkKGUudGFyZ2V0KS5pbmRleCgpIDogJChlLnRhcmdldCkucGFyZW50KCkuaW5kZXgoKTtcblxuICAgIFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIFx0XHRcdHRoaXMudG8oaW5kZXgsIHNldHRpbmdzLmRvdHNTcGVlZCk7XG4gICAgXHRcdH0sIHRoaXMpKTtcblxuICAgIFx0XHQvKiRlbC5vbignZm9jdXNpbicsIGZ1bmN0aW9uKCkge1xuICAgIFx0XHRcdCQoZG9jdW1lbnQpLm9mZihcIi5jYXJvdXNlbFwiKTtcblxuICAgIFx0XHRcdCQoZG9jdW1lbnQpLm9uKCdrZXlkb3duLmNhcm91c2VsJywgZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0aWYoZS5rZXlDb2RlID09IDM3KSB7XG4gICAgXHRcdFx0XHRcdCRlbC50cmlnZ2VyKCdwcmV2Lm93bCcpXG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0XHRpZihlLmtleUNvZGUgPT0gMzkpIHtcbiAgICBcdFx0XHRcdFx0JGVsLnRyaWdnZXIoJ25leHQub3dsJylcbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHR9KTtcbiAgICBcdFx0fSk7Ki9cblxuICAgIFx0XHQvLyBvdmVycmlkZSBwdWJsaWMgbWV0aG9kcyBvZiB0aGUgY2Fyb3VzZWxcbiAgICBcdFx0Zm9yIChvdmVycmlkZSBpbiB0aGlzLl9vdmVycmlkZXMpIHtcbiAgICBcdFx0XHR0aGlzLl9jb3JlW292ZXJyaWRlXSA9ICQucHJveHkodGhpc1tvdmVycmlkZV0sIHRoaXMpO1xuICAgIFx0XHR9XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXG4gICAgXHQgKiBAcHJvdGVjdGVkXG4gICAgXHQgKi9cbiAgICBcdE5hdmlnYXRpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICBcdFx0dmFyIGhhbmRsZXIsIGNvbnRyb2wsIHByb3BlcnR5LCBvdmVycmlkZSwgc2V0dGluZ3M7XG4gICAgXHRcdHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncztcblxuICAgIFx0XHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcbiAgICBcdFx0XHR0aGlzLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XG4gICAgXHRcdH1cbiAgICBcdFx0Zm9yIChjb250cm9sIGluIHRoaXMuX2NvbnRyb2xzKSB7XG4gICAgXHRcdFx0aWYgKGNvbnRyb2wgPT09ICckcmVsYXRpdmUnICYmIHNldHRpbmdzLm5hdkNvbnRhaW5lcikge1xuICAgIFx0XHRcdFx0dGhpcy5fY29udHJvbHNbY29udHJvbF0uaHRtbCgnJyk7XG4gICAgXHRcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHRcdHRoaXMuX2NvbnRyb2xzW2NvbnRyb2xdLnJlbW92ZSgpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0XHRmb3IgKG92ZXJyaWRlIGluIHRoaXMub3ZlcmlkZXMpIHtcbiAgICBcdFx0XHR0aGlzLl9jb3JlW292ZXJyaWRlXSA9IHRoaXMuX292ZXJyaWRlc1tvdmVycmlkZV07XG4gICAgXHRcdH1cbiAgICBcdFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xuICAgIFx0XHRcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xuICAgIFx0XHR9XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIFVwZGF0ZXMgdGhlIGludGVybmFsIHN0YXRlLlxuICAgIFx0ICogQHByb3RlY3RlZFxuICAgIFx0ICovXG4gICAgXHROYXZpZ2F0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBcdFx0dmFyIGksIGosIGssXG4gICAgXHRcdFx0bG93ZXIgPSB0aGlzLl9jb3JlLmNsb25lcygpLmxlbmd0aCAvIDIsXG4gICAgXHRcdFx0dXBwZXIgPSBsb3dlciArIHRoaXMuX2NvcmUuaXRlbXMoKS5sZW5ndGgsXG4gICAgXHRcdFx0bWF4aW11bSA9IHRoaXMuX2NvcmUubWF4aW11bSh0cnVlKSxcbiAgICBcdFx0XHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXG4gICAgXHRcdFx0c2l6ZSA9IHNldHRpbmdzLmNlbnRlciB8fCBzZXR0aW5ncy5hdXRvV2lkdGggfHwgc2V0dGluZ3MuZG90c0RhdGFcbiAgICBcdFx0XHRcdD8gMSA6IHNldHRpbmdzLmRvdHNFYWNoIHx8IHNldHRpbmdzLml0ZW1zO1xuXG4gICAgXHRcdGlmIChzZXR0aW5ncy5zbGlkZUJ5ICE9PSAncGFnZScpIHtcbiAgICBcdFx0XHRzZXR0aW5ncy5zbGlkZUJ5ID0gTWF0aC5taW4oc2V0dGluZ3Muc2xpZGVCeSwgc2V0dGluZ3MuaXRlbXMpO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKHNldHRpbmdzLmRvdHMgfHwgc2V0dGluZ3Muc2xpZGVCeSA9PSAncGFnZScpIHtcbiAgICBcdFx0XHR0aGlzLl9wYWdlcyA9IFtdO1xuXG4gICAgXHRcdFx0Zm9yIChpID0gbG93ZXIsIGogPSAwLCBrID0gMDsgaSA8IHVwcGVyOyBpKyspIHtcbiAgICBcdFx0XHRcdGlmIChqID49IHNpemUgfHwgaiA9PT0gMCkge1xuICAgIFx0XHRcdFx0XHR0aGlzLl9wYWdlcy5wdXNoKHtcbiAgICBcdFx0XHRcdFx0XHRzdGFydDogTWF0aC5taW4obWF4aW11bSwgaSAtIGxvd2VyKSxcbiAgICBcdFx0XHRcdFx0XHRlbmQ6IGkgLSBsb3dlciArIHNpemUgLSAxXG4gICAgXHRcdFx0XHRcdH0pO1xuICAgIFx0XHRcdFx0XHRpZiAoTWF0aC5taW4obWF4aW11bSwgaSAtIGxvd2VyKSA9PT0gbWF4aW11bSkge1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHR9XG4gICAgXHRcdFx0XHRcdGogPSAwLCArK2s7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0XHRqICs9IHRoaXMuX2NvcmUubWVyZ2Vycyh0aGlzLl9jb3JlLnJlbGF0aXZlKGkpKTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogRHJhd3MgdGhlIHVzZXIgaW50ZXJmYWNlLlxuICAgIFx0ICogQHRvZG8gVGhlIG9wdGlvbiBgZG90c0RhdGFgIHdvbnQgd29yay5cbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqL1xuICAgIFx0TmF2aWdhdGlvbi5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIFx0XHR2YXIgZGlmZmVyZW5jZSxcbiAgICBcdFx0XHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXG4gICAgXHRcdFx0ZGlzYWJsZWQgPSB0aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoIDw9IHNldHRpbmdzLml0ZW1zLFxuICAgIFx0XHRcdGluZGV4ID0gdGhpcy5fY29yZS5yZWxhdGl2ZSh0aGlzLl9jb3JlLmN1cnJlbnQoKSksXG4gICAgXHRcdFx0bG9vcCA9IHNldHRpbmdzLmxvb3AgfHwgc2V0dGluZ3MucmV3aW5kO1xuXG4gICAgXHRcdHRoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZS50b2dnbGVDbGFzcygnZGlzYWJsZWQnLCAhc2V0dGluZ3MubmF2IHx8IGRpc2FibGVkKTtcblxuICAgIFx0XHRpZiAoc2V0dGluZ3MubmF2KSB7XG4gICAgXHRcdFx0dGhpcy5fY29udHJvbHMuJHByZXZpb3VzLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsICFsb29wICYmIGluZGV4IDw9IHRoaXMuX2NvcmUubWluaW11bSh0cnVlKSk7XG4gICAgXHRcdFx0dGhpcy5fY29udHJvbHMuJG5leHQudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJywgIWxvb3AgJiYgaW5kZXggPj0gdGhpcy5fY29yZS5tYXhpbXVtKHRydWUpKTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS50b2dnbGVDbGFzcygnZGlzYWJsZWQnLCAhc2V0dGluZ3MuZG90cyB8fCBkaXNhYmxlZCk7XG5cbiAgICBcdFx0aWYgKHNldHRpbmdzLmRvdHMpIHtcbiAgICBcdFx0XHRkaWZmZXJlbmNlID0gdGhpcy5fcGFnZXMubGVuZ3RoIC0gdGhpcy5fY29udHJvbHMuJGFic29sdXRlLmNoaWxkcmVuKCkubGVuZ3RoO1xuXG4gICAgXHRcdFx0aWYgKHNldHRpbmdzLmRvdHNEYXRhICYmIGRpZmZlcmVuY2UgIT09IDApIHtcbiAgICBcdFx0XHRcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5odG1sKHRoaXMuX3RlbXBsYXRlcy5qb2luKCcnKSk7XG4gICAgXHRcdFx0fSBlbHNlIGlmIChkaWZmZXJlbmNlID4gMCkge1xuICAgIFx0XHRcdFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmFwcGVuZChuZXcgQXJyYXkoZGlmZmVyZW5jZSArIDEpLmpvaW4odGhpcy5fdGVtcGxhdGVzWzBdKSk7XG4gICAgXHRcdFx0fSBlbHNlIGlmIChkaWZmZXJlbmNlIDwgMCkge1xuICAgIFx0XHRcdFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmNoaWxkcmVuKCkuc2xpY2UoZGlmZmVyZW5jZSkucmVtb3ZlKCk7XG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgXHRcdFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmNoaWxkcmVuKCkuZXEoJC5pbkFycmF5KHRoaXMuY3VycmVudCgpLCB0aGlzLl9wYWdlcykpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICBcdFx0fVxuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBFeHRlbmRzIGV2ZW50IGRhdGEuXG4gICAgXHQgKiBAcHJvdGVjdGVkXG4gICAgXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3Qgd2hpY2ggZ2V0cyB0aHJvd24uXG4gICAgXHQgKi9cbiAgICBcdE5hdmlnYXRpb24ucHJvdG90eXBlLm9uVHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgXHRcdHZhciBzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XG5cbiAgICBcdFx0ZXZlbnQucGFnZSA9IHtcbiAgICBcdFx0XHRpbmRleDogJC5pbkFycmF5KHRoaXMuY3VycmVudCgpLCB0aGlzLl9wYWdlcyksXG4gICAgXHRcdFx0Y291bnQ6IHRoaXMuX3BhZ2VzLmxlbmd0aCxcbiAgICBcdFx0XHRzaXplOiBzZXR0aW5ncyAmJiAoc2V0dGluZ3MuY2VudGVyIHx8IHNldHRpbmdzLmF1dG9XaWR0aCB8fCBzZXR0aW5ncy5kb3RzRGF0YVxuICAgIFx0XHRcdFx0PyAxIDogc2V0dGluZ3MuZG90c0VhY2ggfHwgc2V0dGluZ3MuaXRlbXMpXG4gICAgXHRcdH07XG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIEdldHMgdGhlIGN1cnJlbnQgcGFnZSBwb3NpdGlvbiBvZiB0aGUgY2Fyb3VzZWwuXG4gICAgXHQgKiBAcHJvdGVjdGVkXG4gICAgXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgIFx0ICovXG4gICAgXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgXHRcdHZhciBjdXJyZW50ID0gdGhpcy5fY29yZS5yZWxhdGl2ZSh0aGlzLl9jb3JlLmN1cnJlbnQoKSk7XG4gICAgXHRcdHJldHVybiAkLmdyZXAodGhpcy5fcGFnZXMsICQucHJveHkoZnVuY3Rpb24ocGFnZSwgaW5kZXgpIHtcbiAgICBcdFx0XHRyZXR1cm4gcGFnZS5zdGFydCA8PSBjdXJyZW50ICYmIHBhZ2UuZW5kID49IGN1cnJlbnQ7XG4gICAgXHRcdH0sIHRoaXMpKS5wb3AoKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogR2V0cyB0aGUgY3VycmVudCBzdWNjZXNvci9wcmVkZWNlc3NvciBwb3NpdGlvbi5cbiAgICBcdCAqIEBwcm90ZWN0ZWRcbiAgICBcdCAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgXHQgKi9cbiAgICBcdE5hdmlnYXRpb24ucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oc3VjY2Vzc29yKSB7XG4gICAgXHRcdHZhciBwb3NpdGlvbiwgbGVuZ3RoLFxuICAgIFx0XHRcdHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncztcblxuICAgIFx0XHRpZiAoc2V0dGluZ3Muc2xpZGVCeSA9PSAncGFnZScpIHtcbiAgICBcdFx0XHRwb3NpdGlvbiA9ICQuaW5BcnJheSh0aGlzLmN1cnJlbnQoKSwgdGhpcy5fcGFnZXMpO1xuICAgIFx0XHRcdGxlbmd0aCA9IHRoaXMuX3BhZ2VzLmxlbmd0aDtcbiAgICBcdFx0XHRzdWNjZXNzb3IgPyArK3Bvc2l0aW9uIDogLS1wb3NpdGlvbjtcbiAgICBcdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3BhZ2VzWygocG9zaXRpb24gJSBsZW5ndGgpICsgbGVuZ3RoKSAlIGxlbmd0aF0uc3RhcnQ7XG4gICAgXHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKTtcbiAgICBcdFx0XHRsZW5ndGggPSB0aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoO1xuICAgIFx0XHRcdHN1Y2Nlc3NvciA/IHBvc2l0aW9uICs9IHNldHRpbmdzLnNsaWRlQnkgOiBwb3NpdGlvbiAtPSBzZXR0aW5ncy5zbGlkZUJ5O1xuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHBvc2l0aW9uO1xuICAgIFx0fTtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBTbGlkZXMgdG8gdGhlIG5leHQgaXRlbSBvciBwYWdlLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZD1mYWxzZV0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxuICAgIFx0ICovXG4gICAgXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oc3BlZWQpIHtcbiAgICBcdFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksIHNwZWVkKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogU2xpZGVzIHRvIHRoZSBwcmV2aW91cyBpdGVtIG9yIHBhZ2UuXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkPWZhbHNlXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXG4gICAgXHQgKi9cbiAgICBcdE5hdmlnYXRpb24ucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbihzcGVlZCkge1xuICAgIFx0XHQkLnByb3h5KHRoaXMuX292ZXJyaWRlcy50bywgdGhpcy5fY29yZSkodGhpcy5nZXRQb3NpdGlvbihmYWxzZSksIHNwZWVkKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogU2xpZGVzIHRvIHRoZSBzcGVjaWZpZWQgaXRlbSBvciBwYWdlLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIG9yIHBhZ2UuXG4gICAgXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXG4gICAgXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGFuZGFyZD1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSB0aGUgc3RhbmRhcmQgYmVoYXZpb3VyIG9yIG5vdC5cbiAgICBcdCAqL1xuICAgIFx0TmF2aWdhdGlvbi5wcm90b3R5cGUudG8gPSBmdW5jdGlvbihwb3NpdGlvbiwgc3BlZWQsIHN0YW5kYXJkKSB7XG4gICAgXHRcdHZhciBsZW5ndGg7XG5cbiAgICBcdFx0aWYgKCFzdGFuZGFyZCAmJiB0aGlzLl9wYWdlcy5sZW5ndGgpIHtcbiAgICBcdFx0XHRsZW5ndGggPSB0aGlzLl9wYWdlcy5sZW5ndGg7XG4gICAgXHRcdFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHRoaXMuX3BhZ2VzWygocG9zaXRpb24gJSBsZW5ndGgpICsgbGVuZ3RoKSAlIGxlbmd0aF0uc3RhcnQsIHNwZWVkKTtcbiAgICBcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHQkLnByb3h5KHRoaXMuX292ZXJyaWRlcy50bywgdGhpcy5fY29yZSkocG9zaXRpb24sIHNwZWVkKTtcbiAgICBcdFx0fVxuICAgIFx0fTtcblxuICAgIFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLk5hdmlnYXRpb24gPSBOYXZpZ2F0aW9uO1xuXG4gICAgfSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xuICAgIChmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblxuICAgIFx0LyoqXG4gICAgXHQgKiBDcmVhdGVzIHRoZSBoYXNoIHBsdWdpbi5cbiAgICBcdCAqIEBjbGFzcyBUaGUgSGFzaCBQbHVnaW5cbiAgICBcdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcbiAgICBcdCAqL1xuICAgIFx0dmFyIEhhc2ggPSBmdW5jdGlvbihjYXJvdXNlbCkge1xuICAgIFx0XHQvKipcbiAgICBcdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxuICAgIFx0XHQgKiBAcHJvdGVjdGVkXG4gICAgXHRcdCAqIEB0eXBlIHtPd2x9XG4gICAgXHRcdCAqL1xuICAgIFx0XHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIEhhc2ggaW5kZXggZm9yIHRoZSBpdGVtcy5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5faGFzaGVzID0ge307XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIFRoZSBjYXJvdXNlbCBlbGVtZW50LlxuICAgIFx0XHQgKiBAdHlwZSB7alF1ZXJ5fVxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy4kZWxlbWVudCA9IHRoaXMuX2NvcmUuJGVsZW1lbnQ7XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIEFsbCBldmVudCBoYW5kbGVycy5cbiAgICBcdFx0ICogQHByb3RlY3RlZFxuICAgIFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuICAgIFx0XHQgKi9cbiAgICBcdFx0dGhpcy5faGFuZGxlcnMgPSB7XG4gICAgXHRcdFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3Muc3RhcnRQb3NpdGlvbiA9PT0gJ1VSTEhhc2gnKSB7XG4gICAgXHRcdFx0XHRcdCQod2luZG93KS50cmlnZ2VyKCdoYXNoY2hhbmdlLm93bC5uYXZpZ2F0aW9uJyk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcyksXG4gICAgXHRcdFx0J3ByZXBhcmVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgIFx0XHRcdFx0aWYgKGUubmFtZXNwYWNlKSB7XG4gICAgXHRcdFx0XHRcdHZhciBoYXNoID0gJChlLmNvbnRlbnQpLmZpbmQoJ1tkYXRhLWhhc2hdJykuYWRkQmFjaygnW2RhdGEtaGFzaF0nKS5hdHRyKCdkYXRhLWhhc2gnKTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIWhhc2gpIHtcbiAgICBcdFx0XHRcdFx0XHRyZXR1cm47XG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR0aGlzLl9oYXNoZXNbaGFzaF0gPSBlLmNvbnRlbnQ7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSwgdGhpcyksXG4gICAgXHRcdFx0J2NoYW5nZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAncG9zaXRpb24nKSB7XG4gICAgXHRcdFx0XHRcdHZhciBjdXJyZW50ID0gdGhpcy5fY29yZS5pdGVtcyh0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKSksXG4gICAgXHRcdFx0XHRcdFx0aGFzaCA9ICQubWFwKHRoaXMuX2hhc2hlcywgZnVuY3Rpb24oaXRlbSwgaGFzaCkge1xuICAgIFx0XHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW0gPT09IGN1cnJlbnQgPyBoYXNoIDogbnVsbDtcbiAgICBcdFx0XHRcdFx0XHR9KS5qb2luKCk7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCFoYXNoIHx8IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpID09PSBoYXNoKSB7XG4gICAgXHRcdFx0XHRcdFx0cmV0dXJuO1xuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0d2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sIHRoaXMpXG4gICAgXHRcdH07XG5cbiAgICBcdFx0Ly8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIFx0XHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgSGFzaC5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcblxuICAgIFx0XHQvLyByZWdpc3RlciB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICBcdFx0dGhpcy4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyk7XG5cbiAgICBcdFx0Ly8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXIgZm9yIGhhc2ggbmF2aWdhdGlvblxuICAgIFx0XHQkKHdpbmRvdykub24oJ2hhc2hjaGFuZ2Uub3dsLm5hdmlnYXRpb24nLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICBcdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKSxcbiAgICBcdFx0XHRcdGl0ZW1zID0gdGhpcy5fY29yZS4kc3RhZ2UuY2hpbGRyZW4oKSxcbiAgICBcdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5faGFzaGVzW2hhc2hdICYmIGl0ZW1zLmluZGV4KHRoaXMuX2hhc2hlc1toYXNoXSk7XG5cbiAgICBcdFx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA9PT0gdGhpcy5fY29yZS5jdXJyZW50KCkpIHtcbiAgICBcdFx0XHRcdHJldHVybjtcbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLl9jb3JlLnRvKHRoaXMuX2NvcmUucmVsYXRpdmUocG9zaXRpb24pLCBmYWxzZSwgdHJ1ZSk7XG4gICAgXHRcdH0sIHRoaXMpKTtcbiAgICBcdH07XG5cbiAgICBcdC8qKlxuICAgIFx0ICogRGVmYXVsdCBvcHRpb25zLlxuICAgIFx0ICogQHB1YmxpY1xuICAgIFx0ICovXG4gICAgXHRIYXNoLkRlZmF1bHRzID0ge1xuICAgIFx0XHRVUkxoYXNoTGlzdGVuZXI6IGZhbHNlXG4gICAgXHR9O1xuXG4gICAgXHQvKipcbiAgICBcdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXG4gICAgXHQgKiBAcHVibGljXG4gICAgXHQgKi9cbiAgICBcdEhhc2gucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICBcdFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xuXG4gICAgXHRcdCQod2luZG93KS5vZmYoJ2hhc2hjaGFuZ2Uub3dsLm5hdmlnYXRpb24nKTtcblxuICAgIFx0XHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcbiAgICBcdFx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XG4gICAgXHRcdH1cbiAgICBcdFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xuICAgIFx0XHRcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xuICAgIFx0XHR9XG4gICAgXHR9O1xuXG4gICAgXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuSGFzaCA9IEhhc2g7XG5cbiAgICB9KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG4gICAgKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXG4gICAgXHR2YXIgc3R5bGUgPSAkKCc8c3VwcG9ydD4nKS5nZXQoMCkuc3R5bGUsXG4gICAgXHRcdHByZWZpeGVzID0gJ1dlYmtpdCBNb3ogTyBtcycuc3BsaXQoJyAnKSxcbiAgICBcdFx0ZXZlbnRzID0ge1xuICAgIFx0XHRcdHRyYW5zaXRpb246IHtcbiAgICBcdFx0XHRcdGVuZDoge1xuICAgIFx0XHRcdFx0XHRXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgXHRcdFx0XHRcdE1velRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcbiAgICBcdFx0XHRcdFx0T1RyYW5zaXRpb246ICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgXHRcdFx0XHRcdHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH0sXG4gICAgXHRcdFx0YW5pbWF0aW9uOiB7XG4gICAgXHRcdFx0XHRlbmQ6IHtcbiAgICBcdFx0XHRcdFx0V2Via2l0QW5pbWF0aW9uOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcbiAgICBcdFx0XHRcdFx0TW96QW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJyxcbiAgICBcdFx0XHRcdFx0T0FuaW1hdGlvbjogJ29BbmltYXRpb25FbmQnLFxuICAgIFx0XHRcdFx0XHRhbmltYXRpb246ICdhbmltYXRpb25lbmQnXG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9LFxuICAgIFx0XHR0ZXN0cyA9IHtcbiAgICBcdFx0XHRjc3N0cmFuc2Zvcm1zOiBmdW5jdGlvbigpIHtcbiAgICBcdFx0XHRcdHJldHVybiAhIXRlc3QoJ3RyYW5zZm9ybScpO1xuICAgIFx0XHRcdH0sXG4gICAgXHRcdFx0Y3NzdHJhbnNmb3JtczNkOiBmdW5jdGlvbigpIHtcbiAgICBcdFx0XHRcdHJldHVybiAhIXRlc3QoJ3BlcnNwZWN0aXZlJyk7XG4gICAgXHRcdFx0fSxcbiAgICBcdFx0XHRjc3N0cmFuc2l0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgXHRcdFx0XHRyZXR1cm4gISF0ZXN0KCd0cmFuc2l0aW9uJyk7XG4gICAgXHRcdFx0fSxcbiAgICBcdFx0XHRjc3NhbmltYXRpb25zOiBmdW5jdGlvbigpIHtcbiAgICBcdFx0XHRcdHJldHVybiAhIXRlc3QoJ2FuaW1hdGlvbicpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fTtcblxuICAgIFx0ZnVuY3Rpb24gdGVzdChwcm9wZXJ0eSwgcHJlZml4ZWQpIHtcbiAgICBcdFx0dmFyIHJlc3VsdCA9IGZhbHNlLFxuICAgIFx0XHRcdHVwcGVyID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICAgIFx0XHQkLmVhY2goKHByb3BlcnR5ICsgJyAnICsgcHJlZml4ZXMuam9pbih1cHBlciArICcgJykgKyB1cHBlcikuc3BsaXQoJyAnKSwgZnVuY3Rpb24oaSwgcHJvcGVydHkpIHtcbiAgICBcdFx0XHRpZiAoc3R5bGVbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICBcdFx0XHRcdHJlc3VsdCA9IHByZWZpeGVkID8gcHJvcGVydHkgOiB0cnVlO1xuICAgIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fSk7XG5cbiAgICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcHJlZml4ZWQocHJvcGVydHkpIHtcbiAgICBcdFx0cmV0dXJuIHRlc3QocHJvcGVydHksIHRydWUpO1xuICAgIFx0fVxuXG4gICAgXHRpZiAodGVzdHMuY3NzdHJhbnNpdGlvbnMoKSkge1xuICAgIFx0XHQvKiBqc2hpbnQgLVcwNTMgKi9cbiAgICBcdFx0JC5zdXBwb3J0LnRyYW5zaXRpb24gPSBuZXcgU3RyaW5nKHByZWZpeGVkKCd0cmFuc2l0aW9uJykpO1xuICAgIFx0XHQkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQgPSBldmVudHMudHJhbnNpdGlvbi5lbmRbICQuc3VwcG9ydC50cmFuc2l0aW9uIF07XG4gICAgXHR9XG5cbiAgICBcdGlmICh0ZXN0cy5jc3NhbmltYXRpb25zKCkpIHtcbiAgICBcdFx0LyoganNoaW50IC1XMDUzICovXG4gICAgXHRcdCQuc3VwcG9ydC5hbmltYXRpb24gPSBuZXcgU3RyaW5nKHByZWZpeGVkKCdhbmltYXRpb24nKSk7XG4gICAgXHRcdCQuc3VwcG9ydC5hbmltYXRpb24uZW5kID0gZXZlbnRzLmFuaW1hdGlvbi5lbmRbICQuc3VwcG9ydC5hbmltYXRpb24gXTtcbiAgICBcdH1cblxuICAgIFx0aWYgKHRlc3RzLmNzc3RyYW5zZm9ybXMoKSkge1xuICAgIFx0XHQvKiBqc2hpbnQgLVcwNTMgKi9cbiAgICBcdFx0JC5zdXBwb3J0LnRyYW5zZm9ybSA9IG5ldyBTdHJpbmcocHJlZml4ZWQoJ3RyYW5zZm9ybScpKTtcbiAgICBcdFx0JC5zdXBwb3J0LnRyYW5zZm9ybTNkID0gdGVzdHMuY3NzdHJhbnNmb3JtczNkKCk7XG4gICAgXHR9XG5cbiAgICB9KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG5cbiAgICB2YXIgJCA9IHdpbmRvdy5qUXVlcnk7XHJcbiAgICB2YXIgUmVhY3RPd2xDYXJvdXNlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUmVhY3RPd2xDYXJvdXNlbCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBSZWFjdE93bENhcm91c2VsKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5jb250YWluZXJSZWYgPSBmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGFpbmVyID0gaW5zdDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIF9hID0gZmlsdGVyT3B0aW9ucyhfdGhpcy5wcm9wcyksIG9wdGlvbnMgPSBfYVswXSwgcHJvcHNXaXRob3V0T3B0aW9ucyA9IF9hWzFdO1xyXG4gICAgICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICAgICAgX3RoaXMucHJvcHNXaXRob3V0T3B0aW9ucyA9IHByb3BzV2l0aG91dE9wdGlvbnM7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVhY3RPd2xDYXJvdXNlbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGVsZSA9ICQodGhpcy5jb250YWluZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVhY3RPd2xDYXJvdXNlbC5wcm90b3R5cGUuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdG9yeSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVhY3RPd2xDYXJvdXNlbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBmaWx0ZXJPcHRpb25zKHRoaXMucHJvcHMpLCBvcHRpb25zID0gX2FbMF0sIHByb3BzV2l0aG91dE9wdGlvbnMgPSBfYVsxXTtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICAgICAgdGhpcy5wcm9wc1dpdGhvdXRPcHRpb25zID0gcHJvcHNXaXRob3V0T3B0aW9ucztcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlYWN0T3dsQ2Fyb3VzZWwucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLiRlbGUpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ093bENhcm91c2VsIGlzIG5vdCBjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BlZWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGUudHJpZ2dlcignbmV4dC5vd2wuY2Fyb3VzZWwnLCBbc3BlZWRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGVsZS50cmlnZ2VyKCduZXh0Lm93bC5jYXJvdXNlbCcsIHNwZWVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVhY3RPd2xDYXJvdXNlbC5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uIChzcGVlZCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuJGVsZSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3dsQ2Fyb3VzZWwgaXMgbm90IGNyZWF0ZWQnKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGVsZS50cmlnZ2VyKCdwcmV2Lm93bC5jYXJvdXNlbCcsIFtzcGVlZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlLnRyaWdnZXIoJ3ByZXYub3dsLmNhcm91c2VsJywgc3BlZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZWFjdE93bENhcm91c2VsLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLiRlbGUpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ093bENhcm91c2VsIGlzIG5vdCBjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInICYmIHR5cGVvZiBzcGVlZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGVsZS50cmlnZ2VyKCd0by5vd2wuY2Fyb3VzZWwnLCBbcG9zaXRpb24sIHNwZWVkXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGUudHJpZ2dlcigndG8ub3dsLmNhcm91c2VsJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlYWN0T3dsQ2Fyb3VzZWwucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy4kZWxlKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPd2xDYXJvdXNlbCBpcyBub3QgY3JlYXRlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLiRlbGUub3dsQ2Fyb3VzZWwob3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVhY3RPd2xDYXJvdXNlbC5wcm90b3R5cGUuZGVzdG9yeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLiRlbGUpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ093bENhcm91c2VsIGlzIG5vdCBjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuJGVsZS50cmlnZ2VyKCdkZXN0cm95Lm93bC5jYXJvdXNlbCcpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVhY3RPd2xDYXJvdXNlbC5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICh0aW1lb3V0LCBzcGVlZCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuJGVsZSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3dsQ2Fyb3VzZWwgaXMgbm90IGNyZWF0ZWQnKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc3BlZWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGUudHJpZ2dlcigncGxheS5vd2wuYXV0b3BsYXknLCBbdGltZW91dCwgc3BlZWRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGVsZS50cmlnZ2VyKCdwbGF5Lm93bC5hdXRvcGxheScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZWFjdE93bENhcm91c2VsLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuJGVsZSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3dsQ2Fyb3VzZWwgaXMgbm90IGNyZWF0ZWQnKTtcclxuICAgICAgICAgICAgdGhpcy4kZWxlLnRyaWdnZXIoJ3N0b3Aub3dsLmF1dG9wbGF5Jyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZWFjdE93bENhcm91c2VsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHNXaXRob3V0T3B0aW9ucywgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2xhc3NOYW1lXCJdKTtcclxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBcIm93bC1jYXJvdXNlbCBcIiArIGNsYXNzTmFtZSwgcmVmOiB0aGlzLmNvbnRhaW5lclJlZiB9LCBwcm9wcykpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSZWFjdE93bENhcm91c2VsO1xyXG4gICAgfShSZWFjdC5Db21wb25lbnQpKTtcclxuICAgIHZhciBPUFRJT05TID0gbmV3IFNldChbXHJcbiAgICAgICAgJ2l0ZW1zJyxcclxuICAgICAgICAnbWFyZ2luJyxcclxuICAgICAgICAnbG9vcCcsXHJcbiAgICAgICAgJ2NlbnRlcicsXHJcbiAgICAgICAgJ21vdXNlRHJhZycsXHJcbiAgICAgICAgJ3RvdWNoRHJhZycsXHJcbiAgICAgICAgJ3B1bGxEcmFnJyxcclxuICAgICAgICAnZnJlZURyYWcnLFxyXG4gICAgICAgICdzdGFnZVBhZGRpbmcnLFxyXG4gICAgICAgICdtZXJnZScsXHJcbiAgICAgICAgJ21lcmdlRml0JyxcclxuICAgICAgICAnYXV0b1dpZHRoJyxcclxuICAgICAgICAnc3RhcnRQb3NpdGlvbicsXHJcbiAgICAgICAgJ1VSTGhhc2hMaXN0ZW5lcicsXHJcbiAgICAgICAgJ25hdicsXHJcbiAgICAgICAgJ3Jld2luZCcsXHJcbiAgICAgICAgJ25hdlRleHQnLFxyXG4gICAgICAgICduYXZFbGVtZW50JyxcclxuICAgICAgICAnc2xpZGVCeScsXHJcbiAgICAgICAgJ2RvdHMnLFxyXG4gICAgICAgICdkb3RzRWFjaCcsXHJcbiAgICAgICAgJ2RvdERhdGEnLFxyXG4gICAgICAgICdsYXp5TG9hZCcsXHJcbiAgICAgICAgJ2xhenlDb250ZW50JyxcclxuICAgICAgICAnYXV0b3BsYXknLFxyXG4gICAgICAgICdhdXRvcGxheVRpbWVvdXQnLFxyXG4gICAgICAgICdhdXRvcGxheUhvdmVyUGF1c2UnLFxyXG4gICAgICAgICdzbWFydFNwZWVkJyxcclxuICAgICAgICAnZmx1aWRTcGVlZCcsXHJcbiAgICAgICAgJ2F1dG9wbGF5U3BlZWQnLFxyXG4gICAgICAgICduYXZTcGVlZCcsXHJcbiAgICAgICAgJ2RvdHNTcGVlZCcsXHJcbiAgICAgICAgJ2RyYWdFbmRTcGVlZCcsXHJcbiAgICAgICAgJ2NhbGxiYWNrcycsXHJcbiAgICAgICAgJ3Jlc3BvbnNpdmUnLFxyXG4gICAgICAgICdyZXNwb25zaXZlUmVmcmVzaFJhdGUnLFxyXG4gICAgICAgICdyZXNwb25zaXZlQmFzZUVsZW1lbnQnLFxyXG4gICAgICAgICd2aWRlbycsXHJcbiAgICAgICAgJ3ZpZGVvSGVpZ2h0JyxcclxuICAgICAgICAndmlkZW9XaWR0aCcsXHJcbiAgICAgICAgJ2FuaW1hdGVPdXQnLFxyXG4gICAgICAgICdhbmltYXRlSW4nLFxyXG4gICAgICAgICdmYWxsYmFja0Vhc2luZycsXHJcbiAgICAgICAgJ2luZm8nLFxyXG4gICAgICAgICduZXN0ZWRJdGVtU2VsZWN0b3InLFxyXG4gICAgICAgICdpdGVtRWxlbWVudCcsXHJcbiAgICAgICAgJ3N0YWdlRWxlbWVudCcsXHJcbiAgICAgICAgJ25hdkNvbnRhaW5lcicsXHJcbiAgICAgICAgJ2RvdHNDb250YWluZXInLFxyXG4gICAgICAgIC8vICdDTEFTU0VTJ1xyXG4gICAgICAgICdyZWZyZXNoQ2xhc3MnLFxyXG4gICAgICAgICdsb2FkaW5nQ2xhc3MnLFxyXG4gICAgICAgICdsb2FkZWRDbGFzcycsXHJcbiAgICAgICAgJ3J0bENsYXNzJyxcclxuICAgICAgICAnZHJhZ0NsYXNzJyxcclxuICAgICAgICAnZ3JhYkNsYXNzJyxcclxuICAgICAgICAnc3RhZ2VDbGFzcycsXHJcbiAgICAgICAgJ3N0YWdlT3V0ZXJDbGFzcycsXHJcbiAgICAgICAgJ25hdkNvbnRhaW5lckNsYXNzJyxcclxuICAgICAgICAnbmF2Q2xhc3MnLFxyXG4gICAgICAgICdjb250cm9sc0NsYXNzJyxcclxuICAgICAgICAnZG90Q2xhc3MnLFxyXG4gICAgICAgICdkb3RzQ2xhc3MnLFxyXG4gICAgICAgICdhdXRvSGVpZ2h0Q2xhc3MnLFxyXG4gICAgICAgICdyZXNwb25zaXZlQ2xhc3MnLFxyXG4gICAgICAgIC8vICdFVkVOVFMnXHJcbiAgICAgICAgJ29uSW5pdGlhbGl6ZScsXHJcbiAgICAgICAgJ29uSW5pdGlhbGl6ZWQnLFxyXG4gICAgICAgICdvblJlc2l6ZScsXHJcbiAgICAgICAgJ29uUmVzaXplZCcsXHJcbiAgICAgICAgJ29uUmVmcmVzaCcsXHJcbiAgICAgICAgJ29uUmVmcmVzaGVkJyxcclxuICAgICAgICAnb25EcmFnJyxcclxuICAgICAgICAnb25EcmFnZ2VkJyxcclxuICAgICAgICAnb25UcmFuc2xhdGUnLFxyXG4gICAgICAgICdvblRyYW5zbGF0ZWQnLFxyXG4gICAgICAgICdvbkNoYW5nZScsXHJcbiAgICAgICAgJ29uQ2hhbmdlZCcsXHJcbiAgICAgICAgJ29uTG9hZExhenknLFxyXG4gICAgICAgICdvbkxvYWRlZExhenknLFxyXG4gICAgICAgICdvblN0b3BWaWRlbycsXHJcbiAgICAgICAgJ29uUGxheVZpZGVvJyxcclxuICAgIF0pO1xyXG4gICAgZnVuY3Rpb24gZmlsdGVyT3B0aW9ucyhpdGVtKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICB2YXIgcHJvcHNXaXRob3V0T3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGl0ZW0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoT1BUSU9OUy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gaXRlbVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJvcHNXaXRob3V0T3B0aW9uc1trZXldID0gaXRlbVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFtvcHRpb25zLCBwcm9wc1dpdGhvdXRPcHRpb25zXTtcclxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdE93bENhcm91c2VsO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-owl-carousel/umd/OwlCarousel.js\n"));

/***/ })

}]);